<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NederLingo | 日本語⇔オランダ語フレーズ学習</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f7f7fb;
      --fg: #1f2933;
      --accent: #ff7a59;
      --accent-dark: #c24e31;
      --card-bg: #ffffff;
      --muted: #5f6c7b;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f172a;
        --fg: #e2e8f0;
        --card-bg: #16203a;
        --muted: #8ea4c4;
      }

      .speech-feedback {
        background: rgba(148, 163, 184, 0.12);
        border-color: rgba(148, 163, 184, 0.2);
      }
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Helvetica Neue", sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px 20px 16px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 4vw, 2.4rem);
      letter-spacing: 0.04em;
    }

    header p {
      margin: 12px auto 0;
      max-width: 720px;
      font-size: 1rem;
      color: var(--muted);
      line-height: 1.6;
    }

    main {
      flex: 1;
      width: min(960px, 92vw);
      margin: 0 auto 48px;
    }

    .main-container {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-switcher {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .mode-button {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(31, 41, 51, 0.12);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease-in-out, border 0.2s ease-in-out, color 0.2s ease-in-out;
    }

    .mode-button:hover,
    .mode-button:focus-visible {
      background: rgba(31, 41, 51, 0.08);
      border-color: rgba(31, 41, 51, 0.24);
      outline: none;
    }

    .mode-button[aria-selected="true"] {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
    }

    .mode-panel-group {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-panel {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      border: 1px solid rgba(15, 23, 42, 0.05);
    }

    .setup-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .setup-list li {
      padding: 14px 16px;
      border-radius: 16px;
      background: rgba(255, 122, 89, 0.08);
      border: 1px dashed rgba(255, 122, 89, 0.4);
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .phrase-dutch {
      display: inline-block;
      font-weight: 600;
    }

    .phrase-note {
      display: block;
      margin-top: 4px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .phrase-actions {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid rgba(31, 41, 51, 0.16);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
    }

    .icon-button:hover,
    .icon-button:focus-visible {
      background: rgba(31, 41, 51, 0.1);
      border-color: rgba(31, 41, 51, 0.32);
      outline: none;
      transform: translateY(-1px);
    }

    .icon-button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
    }

    .icon-button.is-active,
    .icon-button.is-recording {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .speech-toolbar {
      position: sticky;
      top: 12px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 16px;
      border-radius: 16px;
      background: var(--card-bg);
      border: 1px solid rgba(15, 23, 42, 0.08);
      box-shadow: 0 16px 36px rgba(15, 23, 42, 0.12);
    }

    .speech-toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: stretch;
    }

    .speech-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 0.9rem;
      color: var(--muted);
      flex: 1 1 200px;
    }

    .speech-controls label {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-controls input[type="range"] {
      accent-color: var(--accent);
      min-width: 140px;
    }

    .speech-feedback {
      flex: 1 1 280px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.95rem;
      background: rgba(15, 23, 42, 0.05);
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(15, 23, 42, 0.08);
    }

    .speech-feedback-target {
      margin: 0;
      font-size: clamp(1.15rem, 2.8vw, 1.4rem);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .speech-feedback-live {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .speech-feedback-live[hidden] {
      display: none;
    }

    .speech-feedback-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.95rem;
    }

    .speech-feedback-text {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-feedback-score {
      font-weight: 600;
      color: var(--fg);
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .speech-notice {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .intro-card p {
      margin-bottom: 16px;
      line-height: 1.7;
      color: var(--muted);
    }

    .phrase-browser {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .phrase-section-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .phrase-section-header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.7;
      font-size: 0.95rem;
    }

    .phrase-filter-form {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .filter-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .filter-field span {
      font-weight: 600;
      color: var(--fg);
    }

    .filter-field select {
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.02);
      font-size: 0.95rem;
      color: inherit;
    }

    .filter-field select:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-filter {
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 16px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(15, 23, 42, 0.02);
    }

    .tag-filter legend {
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .tag-filter-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .tag-chip {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .tag-chip input {
      position: absolute;
      opacity: 0;
      width: 1px;
      height: 1px;
      margin: 0;
      border: 0;
      padding: 0;
      clip: rect(0, 0, 0, 0);
    }

    .tag-chip span {
      display: inline-flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.05);
      font-size: 0.85rem;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      cursor: pointer;
    }

    .tag-chip input:checked + span {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .tag-chip input:focus-visible + span {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-clear-button,
    .filter-reset-button {
      align-self: flex-start;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .tag-clear-button:hover,
    .tag-clear-button:focus-visible,
    .filter-reset-button:hover,
    .filter-reset-button:focus-visible {
      background: rgba(15, 23, 42, 0.08);
      border-color: rgba(15, 23, 42, 0.32);
      outline: none;
    }

    .filter-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .phrase-count {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .phrase-status {
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.05);
      border: 1px solid rgba(15, 23, 42, 0.1);
      font-size: 0.9rem;
      color: var(--muted);
    }

    .scenario-list {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .scenario-card {
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 18px;
      padding: 20px 20px 24px;
      background: var(--card-bg);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
    }

    .scenario-card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .scenario-card-header h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .scenario-count {
      font-size: 0.85rem;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.08);
    }

    .scenario-category + .scenario-category {
      margin-top: 20px;
    }

    .scenario-category h4 {
      margin: 0 0 12px;
      font-size: 1.05rem;
    }

    .phrase-meta {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .phrase-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: rgba(15, 23, 42, 0.1);
      color: var(--muted);
    }

    .phrase-badge-level {
      background: rgba(255, 122, 89, 0.18);
      color: var(--accent-dark);
    }

    .phrase-badge-tag {
      background: rgba(15, 23, 42, 0.08);
    }

    .is-hidden {
      display: none !important;
    }

    .game-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .game-intro p {
      margin: 0;
      line-height: 1.6;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .game-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      align-items: center;
    }

    .game-meta .meta-box {
      border-radius: 14px;
      background: rgba(31, 41, 51, 0.06);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .meta-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .meta-value {
      font-size: 1.35rem;
      font-weight: 700;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .meta-value small {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--muted);
    }

    .meta-box-timer {
      gap: 8px;
    }

    .countdown-bar {
      position: relative;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(31, 41, 51, 0.12);
      overflow: hidden;
    }

    .countdown-bar-fill {
      width: 100%;
      height: 100%;
      background: var(--accent);
      transform-origin: left center;
      transition: width 120ms linear, background 180ms ease-in-out;
    }

    .countdown-bar-fill.is-warning {
      background: #f59e0b;
    }

    .countdown-bar-fill.is-danger {
      background: #ef4444;
    }

    .game-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .game-button {
      padding: 10px 18px;
      border-radius: 12px;
      border: none;
      font-size: 0.95rem;
      cursor: pointer;
      background: var(--accent);
      color: #ffffff;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    .game-button:hover,
    .game-button:focus-visible {
      background: var(--accent-dark);
      transform: translateY(-1px);
      outline: none;
    }

    .game-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .game-button.secondary {
      background: rgba(31, 41, 51, 0.08);
      color: var(--fg);
    }

    .game-status {
      min-height: 1.4em;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .game-card-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 20px;
      align-items: start;
    }

    .game-card-column {
      display: grid;
      grid-template-rows: repeat(5, minmax(0, auto));
      gap: 12px;
    }

    .game-card {
      position: relative;
      border-radius: 16px;
      padding: 6px;
      background: var(--card-bg);
      border: 2px solid transparent;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      transition: transform 0.18s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .game-card[data-lang="ja"] {
      background: linear-gradient(135deg, rgba(255, 225, 215, 0.45), rgba(255, 255, 255, 0.8));
    }

    .game-card[data-lang="nl"] {
      background: linear-gradient(135deg, rgba(210, 230, 255, 0.4), rgba(255, 255, 255, 0.85));
    }

    .game-card-main {
      width: 100%;
      min-height: 68px;
      border: none;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.35;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .game-card-text {
      display: block;
      line-height: 1.4;
    }

    .game-card[data-lang="nl"] .game-card-main {
      font-size: 1rem;
    }

    .game-card-main:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .game-card.is-selected {
      border-color: var(--accent);
      transform: translateY(-4px);
    }

    .game-card.is-matched {
      border-color: var(--accent);
      animation: cardMatch 520ms ease;
      box-shadow: 0 16px 32px rgba(255, 122, 89, 0.32);
    }

    .game-card.is-disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    .score-pulse {
      animation: scorePulse 420ms ease;
    }

    @keyframes scorePulse {
      0% {
        transform: scale(1);
      }

      40% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
      }
    }

    @keyframes cardMatch {
      0% {
        transform: scale(0.96);
      }

      60% {
        transform: scale(1.08);
      }

      100% {
        transform: scale(1);
      }
    }

    .phrase-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.02);
    }

    .phrase-table th,
    .phrase-table td {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      text-align: left;
      vertical-align: top;
    }

    .phrase-table thead th {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .phrase-table tbody tr:last-child td {
      border-bottom: none;
    }

    .phrase-table td strong {
      display: block;
      font-size: 1rem;
    }

    @media (max-width: 640px) {
      .game-meta {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

      .game-card-grid {
        gap: 16px;
      }

      .game-card-column {
        gap: 10px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 60px;
        padding: 10px 8px;
        font-size: 0.95rem;
      }

      .phrase-table thead {
        display: none;
      }

      .phrase-table,
      .phrase-table tbody,
      .phrase-table tr,
      .phrase-table td {
        display: block;
        width: 100%;
      }

      .phrase-table tr {
        padding: 12px 0;
        border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      }

      .phrase-table tbody tr:last-child {
        border-bottom: none;
      }

      .phrase-table td {
        border: none;
        padding: 6px 0;
      }

      .phrase-table td::before {
        content: attr(data-label);
        display: block;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .phrase-actions {
        margin-top: 10px;
      }

      .icon-button {
        width: 34px;
        height: 34px;
      }
    }

    @media (max-width: 480px) {
      .game-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .game-card-grid {
        gap: 14px;
      }

      .game-card-column {
        gap: 8px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 56px;
        font-size: 0.95rem;
      }
    }

    [hidden] {
      display: none !important;
    }

    footer {
      text-align: center;
      padding: 24px 16px 32px;
      font-size: 0.85rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>NederLingo</h1>
    <p>
      日本語とオランダ語のフレーズ練習を、目的に合わせて切り替えられるマルチモード学習体験にアップデートしました。
    </p>
    <p>
      落ち着いて発音や意味を確認できる「フレーズ学習モード」と、今後公開予定の対戦要素を備えた「フレーズチャレンジモード」を切り替えて、自分に合ったリズムで学びましょう。
    </p>
  </header>

  <main>
    <div class="main-container" data-active-mode="study">
      <div class="mode-switcher" role="tablist" aria-label="学習モードの選択">
        <button
          id="mode-tab-study"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-study"
          aria-selected="true"
          data-mode="study"
        >
          フレーズ学習モード
        </button>
        <button
          id="mode-tab-game"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-game"
          aria-selected="false"
          tabindex="-1"
          data-mode="game"
        >
          フレーズチャレンジモード
        </button>
      </div>

      <div class="mode-panel-group">
        <section
          id="mode-panel-study"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-study"
          aria-hidden="false"
          data-mode-panel="study"
        >
          <section class="card intro-card">
            <h2>旅のシナリオに合わせて学ぶ</h2>
            <p>
              長期滞在の旅行者が直面するシチュエーションを想定し、日常会話から空港・交通、宿泊、食事、観光、ショッピング、緊急対応まで58フレーズを整理しました。音声の再生と発話トレーニングを活用して、滞在中に必要な表現を実践的に身につけましょう。
            </p>
            <ul class="setup-list">
              <li>日常・移動・宿泊・食事・観光・緊急の7シナリオをカバー</li>
              <li>シナリオ・レベル・タグによる柔軟なフィルターと並び替え</li>
              <li>全フレーズで音声再生とマイクによる発話チェックが可能</li>
            </ul>
          </section>

          <section class="speech-toolbar" aria-label="音声サポート">
            <div class="speech-toolbar-row">
              <div class="speech-controls">
                <label for="speech-rate">再生速度 <span id="speech-rate-value">1.0x</span></label>
                <input
                  type="range"
                  id="speech-rate"
                  name="speech-rate"
                  min="0.6"
                  max="1.4"
                  step="0.1"
                  value="1"
                >
              </div>
              <div id="speech-feedback" class="speech-feedback" aria-live="polite">
                <p id="recognition-target" class="speech-feedback-target">-</p>
                <p id="recognition-live" class="speech-feedback-live" hidden>
                  <span class="speech-feedback-icon" aria-hidden="true">🎙</span>
                  <span id="recognition-text" class="speech-feedback-text">-</span>
                  <span id="recognition-score" class="speech-feedback-score">-</span>
                </p>
                <span id="recognition-status" class="visually-hidden">録音待機中です。</span>
              </div>
            </div>
            <p id="speech-recognition-notice" class="speech-notice is-hidden" aria-live="polite"></p>
          </section>
          <section class="card phrase-browser">
            <div class="phrase-section-header">
              <h2>シナリオ別フレーズ</h2>
              <p>
                空港、交通、宿泊、食事、観光、ショッピング、緊急時などマルチウィーク滞在で出会う場面をカバーしています。シナリオやレベル、興味のあるタグで絞り込み、必要なフレーズから重点的に練習しましょう。
              </p>
            </div>
            <form id="phrase-filter-form" class="phrase-filter-form" autocomplete="off">
              <div class="filter-grid">
                <label class="filter-field">
                  <span>シナリオ</span>
                  <select id="filter-scenario" name="scenario"></select>
                </label>
                <label class="filter-field">
                  <span>レベル</span>
                  <select id="filter-level" name="level"></select>
                </label>
                <label class="filter-field">
                  <span>並び順</span>
                  <select id="filter-sort" name="sort"></select>
                </label>
              </div>
              <fieldset class="tag-filter">
                <legend>タグで絞り込む</legend>
                <div id="tag-filter-options" class="tag-filter-options"></div>
                <button type="button" id="tag-clear-button" class="tag-clear-button">タグをクリア</button>
              </fieldset>
              <div class="filter-footer">
                <span id="phrase-count" class="phrase-count" aria-live="polite">- 件のフレーズ</span>
                <button type="reset" class="filter-reset-button">条件をリセット</button>
              </div>
            </form>
            <div id="phrase-loading" class="phrase-status" role="status" aria-live="polite">
              フレーズデータを読み込んでいます…
            </div>
            <div id="phrase-error" class="phrase-status is-hidden" role="status" aria-live="polite"></div>
            <div id="phrase-empty" class="phrase-status is-hidden" role="status" aria-live="polite">
              条件に一致するフレーズが見つかりませんでした。
            </div>
            <div id="study-content" class="scenario-list" aria-live="polite"></div>
          </section>
        </section>

        <section
          id="mode-panel-game"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-game"
          data-mode-panel="game"
          hidden
          aria-hidden="true"
        >
          <section class="card game-section">
            <div class="game-intro">
              <h2>フレーズチャレンジモード</h2>
              <p>
                日本語カードとオランダ語カードをタップしてペアを見つける、テンポの良いマッチングゲームです。耳と目を同時に使いながら、短時間で何度も遊んでみましょう。
              </p>
            </div>
            <div class="game-meta">
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Stage</span>
                <span class="meta-value">
                  <span id="game-stage">0</span><small>段</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Score</span>
                <span class="meta-value">
                  <span id="game-score">0</span><small>pt</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">連続正解</span>
                <span class="meta-value">
                  <span id="game-streak">0</span><small id="game-best">BEST 0</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">正解数</span>
                <span class="meta-value">
                  <span id="game-correct">0</span><small>組</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">ミス</span>
                <span class="meta-value">
                  <span id="game-mistakes">0</span><small>回</small>
                </span>
              </div>
              <div class="meta-box meta-box-timer" aria-live="polite">
                <span class="meta-label">残り時間</span>
                <span class="meta-value">
                  <span id="game-time">60</span><small>秒</small>
                </span>
                <div class="countdown-bar" role="presentation" aria-hidden="true">
                  <div id="game-timer-fill" class="countdown-bar-fill"></div>
                </div>
              </div>
            </div>
            <div class="game-controls">
              <button id="game-start-button" class="game-button" type="button">ステージを始める</button>
              <button id="game-reset-button" class="game-button secondary" type="button">スコアをリセット</button>
            </div>
            <p id="game-status" class="game-status" aria-live="polite">ステージを始めて制限時間60秒以内にカードをマッチさせましょう！</p>
            <p id="game-speech-instruction" class="visually-hidden">
              オランダ語カードはタップすると発音が再生されます。音声のヒントを聞きながら対応する日本語カードを探してみましょう。
            </p>
            <div
              id="game-grid"
              class="game-card-grid"
              aria-label="日本語とオランダ語のカードをマッチさせるグリッド"
              aria-describedby="game-speech-instruction"
              aria-live="polite"
            ></div>
          </section>
        </section>
      </div>
    </div>
  </main>

  <footer>
    &copy; 2024 NederLingo. All rights reserved.
  </footer>

  <script>
    // フレーズデータは外部JSONから読み込みます。


    const DATA_URL = 'data/phrases.json';
    const LEVEL_ORDER = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];

    const loadPhraseData = async () => {
      const response = await fetch(DATA_URL, { cache: 'no-store' });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const payload = await response.json();

      if (!payload || !Array.isArray(payload.phrases)) {
        throw new Error('フレーズデータの形式が正しくありません。');
      }

      return payload.phrases;
    };

    const createPhraseModel = (phrases) => {
      const normalized = phrases.map((phrase, index) => {
        const scenario = Array.isArray(phrase.scenario)
          ? phrase.scenario.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const level = Array.isArray(phrase.level)
          ? phrase.level.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const tags = Array.isArray(phrase.tags)
          ? phrase.tags.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];

        return {
          ...phrase,
          scenario: scenario.length > 0 ? scenario : ['その他'],
          level: level.length > 0 ? level : ['A1'],
          tags,
          note: typeof phrase.note === 'string' ? phrase.note : '',
          order: index,
        };
      });

      const lookup = new Map(normalized.map((phrase) => [phrase.id, phrase]));
      const scenarioOrder = [];
      const categoryOrderMap = new Map();
      const tagSet = new Set();
      const levelSet = new Set();

      normalized.forEach((phrase) => {
        const categoryName = phrase.category ?? 'その他';

        phrase.scenario.forEach((scenarioName) => {
          if (!scenarioOrder.includes(scenarioName)) {
            scenarioOrder.push(scenarioName);
          }

          const storedOrder = categoryOrderMap.get(scenarioName);

          if (storedOrder) {
            if (!storedOrder.includes(categoryName)) {
              storedOrder.push(categoryName);
            }
          } else {
            categoryOrderMap.set(scenarioName, [categoryName]);
          }
        });

        phrase.tags.forEach((tag) => tagSet.add(tag));
        phrase.level.forEach((levelValue) => levelSet.add(levelValue));
      });

      const levelOptions = Array.from(levelSet).sort((a, b) => {
        const indexA = LEVEL_ORDER.indexOf(a);
        const indexB = LEVEL_ORDER.indexOf(b);

        if (indexA === -1 && indexB === -1) {
          return a.localeCompare(b, 'ja');
        }

        if (indexA === -1) {
          return 1;
        }

        if (indexB === -1) {
          return -1;
        }

        return indexA - indexB;
      });

      const tagOptions = Array.from(tagSet).sort((a, b) => a.localeCompare(b, 'ja'));

      const filter = ({ scenario, level, tags }) =>
        normalized.filter((phrase) => {
          const matchesScenario =
            !scenario || scenario === 'all' || phrase.scenario.includes(scenario);
          const matchesLevel = !level || level === 'all' || phrase.level.includes(level);
          const matchesTags =
            !tags || tags.length === 0 || tags.every((tag) => phrase.tags.includes(tag));

          return matchesScenario && matchesLevel && matchesTags;
        });

      const comparators = {
        default: (a, b) => a.order - b.order,
        ja: (a, b) => a.ja.localeCompare(b.ja, 'ja'),
        nl: (a, b) => a.nl.localeCompare(b.nl, 'nl'),
        level: (a, b) => {
          const indexFromPhrase = (phrase) => {
            const indexes = phrase.level
              .map((levelValue) => {
                const index = LEVEL_ORDER.indexOf(levelValue);
                return index === -1 ? Number.POSITIVE_INFINITY : index;
              })
              .sort((x, y) => x - y);

            return indexes.length > 0 ? indexes[0] : Number.POSITIVE_INFINITY;
          };

          const indexA = indexFromPhrase(a);
          const indexB = indexFromPhrase(b);

          if (indexA === indexB) {
            return a.ja.localeCompare(b.ja, 'ja');
          }

          return indexA - indexB;
        },
      };

      const sort = (phrases, sortKey) => {
        const comparator = comparators[sortKey] ?? comparators.default;
        return [...phrases].sort(comparator);
      };

      const group = (phrases, scenarioFilter) => {
        const activeScenarioNames =
          scenarioFilter && scenarioFilter !== 'all'
            ? new Set([scenarioFilter])
            : new Set(scenarioOrder);

        const scenarioMap = new Map();

        phrases.forEach((phrase) => {
          const categoryName = phrase.category ?? 'その他';

          phrase.scenario.forEach((scenarioName) => {
            if (!activeScenarioNames.has(scenarioName)) {
              return;
            }

            let scenarioEntry = scenarioMap.get(scenarioName);

            if (!scenarioEntry) {
              scenarioEntry = {
                name: scenarioName,
                categories: new Map(),
                order: scenarioOrder.indexOf(scenarioName),
              };
              scenarioMap.set(scenarioName, scenarioEntry);
            }

            let categoryEntry = scenarioEntry.categories.get(categoryName);

            if (!categoryEntry) {
              categoryEntry = { name: categoryName, phrases: [] };
              scenarioEntry.categories.set(categoryName, categoryEntry);
            }

            categoryEntry.phrases.push(phrase);
          });
        });

        const groupedScenarios = Array.from(scenarioMap.values()).sort((a, b) => {
          const orderA = a.order === -1 ? Number.MAX_SAFE_INTEGER : a.order;
          const orderB = b.order === -1 ? Number.MAX_SAFE_INTEGER : b.order;

          if (orderA === orderB) {
            return a.name.localeCompare(b.name, 'ja');
          }

          return orderA - orderB;
        });

        return groupedScenarios.map((scenarioEntry) => {
          const baseOrder = categoryOrderMap.get(scenarioEntry.name) ?? [];
          const categories = Array.from(scenarioEntry.categories.values()).sort((a, b) => {
            const orderA = baseOrder.indexOf(a.name);
            const orderB = baseOrder.indexOf(b.name);

            if (orderA === -1 && orderB === -1) {
              return a.name.localeCompare(b.name, 'ja');
            }

            if (orderA === -1) {
              return 1;
            }

            if (orderB === -1) {
              return -1;
            }

            return orderA - orderB;
          });

          return {
            name: scenarioEntry.name,
            categories,
          };
        });
      };

      const filterByLevel = (level) => filter({ scenario: null, level, tags: [] });
      const filterByTags = (tags) => filter({ scenario: null, level: null, tags });

      return {
        phrases: normalized,
        lookup,
        scenarioOrder,
        levelOptions,
        tagOptions,
        filter,
        sort,
        group,
        filterByLevel,
        filterByTags,
      };
    };

    let phraseModel = null;

    const getPhraseById = (id) =>
      phraseModel ? phraseModel.lookup.get(id) ?? null : null;

    const getAllPhrases = () => (phraseModel ? phraseModel.phrases : []);


    const renderStudyMode = (model) => {
      const scenarioSelect = document.getElementById('filter-scenario');
      const levelSelect = document.getElementById('filter-level');
      const sortSelect = document.getElementById('filter-sort');
      const tagContainer = document.getElementById('tag-filter-options');
      const tagClearButton = document.getElementById('tag-clear-button');
      const filterForm = document.getElementById('phrase-filter-form');
      const loadingIndicator = document.getElementById('phrase-loading');
      const errorIndicator = document.getElementById('phrase-error');
      const emptyIndicator = document.getElementById('phrase-empty');
      const summaryIndicator = document.getElementById('phrase-count');
      const contentContainer = document.getElementById('study-content');

      if (
        !scenarioSelect ||
        !levelSelect ||
        !sortSelect ||
        !tagContainer ||
        !filterForm ||
        !contentContainer
      ) {
        return;
      }

      if (errorIndicator) {
        errorIndicator.classList.add('is-hidden');
        errorIndicator.textContent = '';
      }

      const getSelectedTags = () =>
        Array.from(tagContainer.querySelectorAll('input[type="checkbox"]:checked')).map(
          (input) => input.value
        );

      const updateSummary = (count) => {
        if (summaryIndicator) {
          summaryIndicator.textContent = `${count}件のフレーズ`;
        }
      };

      scenarioSelect.innerHTML = '';
      const scenarioDefaultOption = document.createElement('option');
      scenarioDefaultOption.value = 'all';
      scenarioDefaultOption.textContent = 'すべてのシナリオ';
      scenarioSelect.appendChild(scenarioDefaultOption);

      model.scenarioOrder.forEach((scenarioName) => {
        const option = document.createElement('option');
        option.value = scenarioName;
        option.textContent = scenarioName;
        scenarioSelect.appendChild(option);
      });

      levelSelect.innerHTML = '';
      const levelDefaultOption = document.createElement('option');
      levelDefaultOption.value = 'all';
      levelDefaultOption.textContent = 'すべてのレベル';
      levelSelect.appendChild(levelDefaultOption);

      model.levelOptions.forEach((level) => {
        const option = document.createElement('option');
        option.value = level;
        option.textContent = level;
        levelSelect.appendChild(option);
      });

      sortSelect.innerHTML = '';
      [
        { value: 'default', label: '登録順' },
        { value: 'ja', label: '日本語の五十音順' },
        { value: 'nl', label: 'オランダ語のアルファベット順' },
        { value: 'level', label: 'レベル順' },
      ].forEach(({ value, label }) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        sortSelect.appendChild(option);
      });

      tagContainer.innerHTML = '';
      model.tagOptions.forEach((tag, index) => {
        const label = document.createElement('label');
        label.className = 'tag-chip';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.name = 'tags';
        input.value = tag;
        input.id = `tag-filter-${index}`;
        const text = document.createElement('span');
        text.textContent = tag;
        label.appendChild(input);
        label.appendChild(text);
        tagContainer.appendChild(label);
      });

      const createBadge = (textContent, type) => {
        const badge = document.createElement('span');
        badge.className = `phrase-badge phrase-badge-${type}`;
        badge.textContent = textContent;
        return badge;
      };

      const createPhraseRow = (phrase) => {
        const row = document.createElement('tr');
        row.dataset.phraseId = phrase.id;

        const jaCell = document.createElement('td');
        jaCell.dataset.label = '日本語';
        const jaStrong = document.createElement('strong');
        jaStrong.textContent = phrase.ja;
        jaCell.appendChild(jaStrong);

        if (phrase.note) {
          const note = document.createElement('span');
          note.className = 'phrase-note';
          note.textContent = phrase.note;
          jaCell.appendChild(note);
        }

        const meta = document.createElement('div');
        meta.className = 'phrase-meta';

        phrase.level.forEach((levelValue) => {
          meta.appendChild(createBadge(`Lv ${levelValue}`, 'level'));
        });

        phrase.tags.forEach((tag) => {
          meta.appendChild(createBadge(tag, 'tag'));
        });

        if (meta.childElementCount > 0) {
          jaCell.appendChild(meta);
        }

        const nlCell = document.createElement('td');
        nlCell.dataset.label = 'オランダ語';
        const nlSpan = document.createElement('span');
        nlSpan.className = 'phrase-dutch';
        nlSpan.textContent = phrase.nl;
        nlCell.appendChild(nlSpan);

        const actionGroup = document.createElement('div');
        actionGroup.className = 'phrase-actions';
        actionGroup.setAttribute('role', 'group');
        actionGroup.setAttribute('aria-label', '音声操作');

        const speakButton = document.createElement('button');
        speakButton.type = 'button';
        speakButton.className = 'icon-button speak-control';
        speakButton.dataset.phraseId = phrase.id;
        const speakLabel = `「${phrase.ja}」をオランダ語で再生`;
        speakButton.dataset.defaultLabel = speakLabel;
        speakButton.dataset.activeLabel = `「${phrase.ja}」を再生中`;
        speakButton.setAttribute('aria-label', speakLabel);
        speakButton.innerHTML = '<span aria-hidden="true">🔊</span>';
        actionGroup.appendChild(speakButton);

        const recognizeButton = document.createElement('button');
        recognizeButton.type = 'button';
        recognizeButton.className = 'icon-button recognize-control';
        recognizeButton.dataset.phraseId = phrase.id;
        const recognizeLabel = `マイクで「${phrase.nl}」（${phrase.ja}）を発声してみよう`;
        recognizeButton.dataset.defaultLabel = recognizeLabel;
        recognizeButton.dataset.activeLabel = `「${phrase.nl}」を録音中`;
        recognizeButton.setAttribute('aria-label', recognizeLabel);
        recognizeButton.innerHTML = '<span aria-hidden="true">🎤</span>';
        actionGroup.appendChild(recognizeButton);

        nlCell.appendChild(actionGroup);

        const hintCell = document.createElement('td');
        hintCell.dataset.label = 'カタカナ・発音ヒント';
        const hintSpan = document.createElement('span');
        hintSpan.textContent = phrase.hint ?? '―';
        hintCell.appendChild(hintSpan);

        row.appendChild(jaCell);
        row.appendChild(nlCell);
        row.appendChild(hintCell);

        return row;
      };

      const createCategorySection = (category) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'scenario-category';

        const heading = document.createElement('h4');
        heading.textContent = category.name;
        wrapper.appendChild(heading);

        const table = document.createElement('table');
        table.className = 'phrase-table';
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['日本語', 'オランダ語', 'カタカナ・発音ヒント'].forEach((label) => {
          const th = document.createElement('th');
          th.scope = 'col';
          th.textContent = label;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        category.phrases.forEach((phrase) => {
          tbody.appendChild(createPhraseRow(phrase));
        });
        table.appendChild(tbody);

        wrapper.appendChild(table);
        return wrapper;
      };

      const render = () => {
        const scenarioValue = scenarioSelect.value;
        const levelValue = levelSelect.value;
        const sortValue = sortSelect.value;
        const selectedTags = getSelectedTags();

        const filtered = model.filter({
          scenario: scenarioValue,
          level: levelValue,
          tags: selectedTags,
        });
        const sorted = model.sort(filtered, sortValue);
        const grouped = model.group(sorted, scenarioValue);

        if (loadingIndicator) {
          loadingIndicator.classList.add('is-hidden');
        }

        contentContainer.innerHTML = '';

        if (sorted.length === 0) {
          updateSummary(0);
          if (emptyIndicator) {
            emptyIndicator.classList.remove('is-hidden');
          }
          return;
        }

        if (emptyIndicator) {
          emptyIndicator.classList.add('is-hidden');
        }

        updateSummary(sorted.length);

        grouped.forEach((scenarioEntry) => {
          const scenarioSection = document.createElement('section');
          scenarioSection.className = 'scenario-card';

          const header = document.createElement('div');
          header.className = 'scenario-card-header';
          const title = document.createElement('h3');
          title.textContent = scenarioEntry.name;
          header.appendChild(title);
          const count = document.createElement('span');
          count.className = 'scenario-count';
          const phraseCount = scenarioEntry.categories.reduce(
            (acc, category) => acc + category.phrases.length,
            0
          );
          count.textContent = `${phraseCount}件`;
          header.appendChild(count);
          scenarioSection.appendChild(header);

          scenarioEntry.categories.forEach((category) => {
            scenarioSection.appendChild(createCategorySection(category));
          });

          contentContainer.appendChild(scenarioSection);
        });

        if (typeof syncRecognitionControls === 'function') {
          syncRecognitionControls();
        }
      };

      scenarioSelect.addEventListener('change', render);
      levelSelect.addEventListener('change', render);
      sortSelect.addEventListener('change', render);
      tagContainer.addEventListener('change', (event) => {
        if (event.target && event.target.matches('input[type="checkbox"]')) {
          render();
        }
      });

      if (tagClearButton) {
        tagClearButton.addEventListener('click', () => {
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        });
      }

      filterForm.addEventListener('reset', () => {
        window.setTimeout(() => {
          scenarioSelect.value = 'all';
          levelSelect.value = 'all';
          sortSelect.value = 'default';
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        }, 0);
      });

      render();
    };

    const attachPhraseData = (model) => {
      phraseModel = model;
      if (!window.NederLingo) {
        window.NederLingo = {};
      }
      window.NederLingo.phraseModel = {
        getAll: () => model.phrases,
        filterByLevel: model.filterByLevel,
        filterByTags: model.filterByTags,
      };
    };


    const showPhraseDataError = (message) => {
      const errorIndicator = document.getElementById('phrase-error');
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.add('is-hidden');
      }

      if (errorIndicator) {
        errorIndicator.textContent = message;
        errorIndicator.classList.remove('is-hidden');
      }
    };

    const bootstrapPhraseData = async () => {
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.remove('is-hidden');
      }

      try {
        const phrases = await loadPhraseData();
        const model = createPhraseModel(phrases);
        attachPhraseData(model);
        renderStudyMode(model);
        return model;
      } catch (error) {
        console.error(error);
        showPhraseDataError(`フレーズデータの読み込みに失敗しました: ${error.message}`);
        return null;
      }
    };

    const phraseDataPromise = bootstrapPhraseData();

    const shuffleArray = (input) => {
      const array = [...input];

      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }

      return array;
    };

    const modeContainer = document.querySelector('.main-container');
    const modeButtons = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode]'))
      : [];
    const modePanels = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode-panel]'))
      : [];

    if (modeContainer && modeButtons.length > 0 && modePanels.length > 0) {
      const setActiveMode = (mode) => {
        modeContainer.dataset.activeMode = mode;

        modeButtons.forEach((button) => {
          const targetMode = button.getAttribute('data-mode');
          const isActive = targetMode === mode;

          button.setAttribute('aria-selected', String(isActive));
          button.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        modePanels.forEach((panel) => {
          const panelMode = panel.getAttribute('data-mode-panel');
          const isActive = panelMode === mode;

          panel.toggleAttribute('hidden', !isActive);
          panel.setAttribute('aria-hidden', String(!isActive));
        });
      };

      const availableModes = modeButtons
        .map((button) => button.getAttribute('data-mode'))
        .filter((value) => typeof value === 'string' && value.length > 0);

      let initialMode = modeContainer.dataset.activeMode;

      if (!initialMode || !availableModes.includes(initialMode)) {
        initialMode = availableModes[0];
      }

      setActiveMode(initialMode);

      modeButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const mode = button.getAttribute('data-mode');

          if (!mode) {
            return;
          }

          setActiveMode(mode);
        });

        button.addEventListener('keydown', (event) => {
          const currentIndex = modeButtons.indexOf(button);
          let targetIndex = null;

          if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
            targetIndex = (currentIndex + 1) % modeButtons.length;
          } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
            targetIndex =
              (currentIndex - 1 + modeButtons.length) % modeButtons.length;
          } else if (event.key === 'Home') {
            targetIndex = 0;
          } else if (event.key === 'End') {
            targetIndex = modeButtons.length - 1;
          }

          if (targetIndex !== null) {
            event.preventDefault();

            const targetButton = modeButtons[targetIndex];
            const mode = targetButton?.getAttribute('data-mode');

            if (mode) {
              setActiveMode(mode);
              targetButton.focus();
            }
          }
        });
      });
    }

    const rateSlider = document.getElementById('speech-rate');
    const rateValue = document.getElementById('speech-rate-value');
    const speechFeedback = document.getElementById('speech-feedback');
    const recognitionStatus = document.getElementById('recognition-status');
    const recognitionTarget = document.getElementById('recognition-target');
    const recognitionText = document.getElementById('recognition-text');
    const recognitionScore = document.getElementById('recognition-score');
    const recognitionLive = document.getElementById('recognition-live');
    const recognitionNotice = document.getElementById('speech-recognition-notice');

    let speakDutchPhrase = null;

    const defaultStatusMessage =
      recognitionStatus?.textContent?.trim() || '録音待機中です。';

    let recognitionAudioContext = null;

    const ensureRecognitionAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!recognitionAudioContext) {
        recognitionAudioContext = new AudioContextClass();
      }

      if (recognitionAudioContext.state === 'suspended') {
        recognitionAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return recognitionAudioContext;
    };

    const playRecognitionTone = (isPerfectMatch) => {
      const context = ensureRecognitionAudioContext();

      if (!context) {
        return;
      }

      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      const now = context.currentTime;

      oscillator.type = isPerfectMatch ? 'triangle' : 'sine';

      if (isPerfectMatch) {
        oscillator.frequency.setValueAtTime(880, now);
        oscillator.frequency.exponentialRampToValueAtTime(1320, now + 0.22);
      } else {
        oscillator.frequency.setValueAtTime(320, now);
        oscillator.frequency.exponentialRampToValueAtTime(220, now + 0.22);
      }

      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.25, now + 0.04);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);

      oscillator.connect(gainNode);
      gainNode.connect(context.destination);

      oscillator.start(now);
      oscillator.stop(now + 0.34);
    };

    const showRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = false;
      }
    };

    const hideRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = true;
      }
    };

    if (recognitionStatus) {
      recognitionStatus.dataset.defaultMessage = defaultStatusMessage;
      recognitionStatus.dataset.state = recognitionStatus.dataset.state || 'idle';
    }

    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;

    const syncRecognitionControls = () => {
      document.querySelectorAll('.recognize-control').forEach((button) => {
        const baseLabel =
          button.dataset.defaultLabel || 'オランダ語フレーズの発声をテスト';

        if (!SpeechRecognition) {
          button.setAttribute(
            'aria-label',
            `${baseLabel} (音声認識は利用できません)`
          );
          button.disabled = true;
        } else {
          button.setAttribute('aria-label', baseLabel);
          button.disabled = false;
        }
      });
    };

    if (rateSlider && rateValue) {
      const updateRateLabel = () => {
        rateValue.textContent = `${parseFloat(rateSlider.value).toFixed(1)}x`;
      };

      rateSlider.addEventListener('input', updateRateLabel);
      updateRateLabel();
    }

    if ('speechSynthesis' in window) {
      const synthesis = window.speechSynthesis;
      let availableVoices = [];
      let activeButton = null;

      const restoreStatusAfterSpeech = () => {
        if (
          recognitionStatus &&
          recognitionStatus.dataset.state === 'speaking'
        ) {
          const previous =
            recognitionStatus.dataset.previousStatus || defaultStatusMessage;
          recognitionStatus.textContent = previous;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
        }
      };

      const markStatusForSpeech = () => {
        if (!recognitionStatus) {
          return;
        }

        recognitionStatus.dataset.previousStatus =
          recognitionStatus.textContent?.trim() || defaultStatusMessage;
        recognitionStatus.dataset.state = 'speaking';
        recognitionStatus.textContent = '再生中です…';
      };

      const refreshVoices = () => {
        availableVoices = synthesis
          .getVoices()
          .filter((voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl'));

        if (availableVoices.length === 0) {
          availableVoices = synthesis.getVoices();
        }
      };

      const resetActiveButton = () => {
        restoreStatusAfterSpeech();

        if (activeButton) {
          activeButton.disabled = false;
          activeButton.classList.remove('is-active');
          const defaultLabel =
            activeButton.dataset.defaultLabel ?? 'オランダ語フレーズを再生';
          activeButton.setAttribute('aria-label', defaultLabel);
          activeButton = null;
        }
      };

      speakDutchPhrase = ({ phraseId, triggerButton = null } = {}) => {
        if (!phraseId) {
          return false;
        }

        const phrase = getPhraseById(phraseId);
        const dutchText = phrase?.nl?.trim();

        if (!phrase || !dutchText) {
          return false;
        }

        if (availableVoices.length === 0) {
          refreshVoices();
        }

        if (synthesis.speaking || synthesis.pending) {
          synthesis.cancel();
        }

        resetActiveButton();

        const utterance = new SpeechSynthesisUtterance(dutchText);
        utterance.lang = 'nl-NL';

        if (rateSlider) {
          const parsedRate = parseFloat(rateSlider.value);
          if (!Number.isNaN(parsedRate)) {
            utterance.rate = parsedRate;
          }
        }

        const selectedVoice = availableVoices.find(
          (voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl')
        );

        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }

        if (speechFeedback) {
          speechFeedback.classList.remove('is-hidden');
        }

        if (recognitionTarget) {
          recognitionTarget.textContent = dutchText;
        }

        markStatusForSpeech();

        if (triggerButton) {
          if (!triggerButton.dataset.defaultLabel) {
            const currentLabel = triggerButton.getAttribute('aria-label');
            if (currentLabel) {
              triggerButton.dataset.defaultLabel = currentLabel;
            }
          }

          activeButton = triggerButton;
          triggerButton.disabled = true;
          triggerButton.classList.add('is-active');
          const activeLabel = triggerButton.dataset.activeLabel ?? '再生中…';
          triggerButton.setAttribute('aria-label', activeLabel);
        }

        const clearAfterSpeech = () => {
          if (triggerButton && activeButton === triggerButton) {
            resetActiveButton();
          } else {
            restoreStatusAfterSpeech();
          }
        };

        utterance.onend = clearAfterSpeech;
        utterance.onerror = clearAfterSpeech;

        synthesis.speak(utterance);

        return true;
      };

      const handleSpeakClick = (event) => {
        const button = event.target.closest('.speak-control');

        if (!button || typeof speakDutchPhrase !== 'function') {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        speakDutchPhrase({
          phraseId: button.dataset.phraseId,
          triggerButton: button,
        });
      };

      refreshVoices();
      synthesis.addEventListener('voiceschanged', refreshVoices);
      document.addEventListener('click', handleSpeakClick);
    }

    const sanitizePhrase = (text) =>
      text
        .toLowerCase()
        .replace(/[^a-zà-ž\s']/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim();

    const computeSimilarity = (a, b) => {
      const source = sanitizePhrase(a);
      const target = sanitizePhrase(b);

      if (!source && !target) {
        return 1;
      }

      if (!source || !target) {
        return 0;
      }

      const rows = source.length + 1;
      const cols = target.length + 1;
      const dp = Array.from({ length: rows }, () => new Array(cols).fill(0));

      for (let i = 0; i < rows; i += 1) {
        dp[i][0] = i;
      }

      for (let j = 0; j < cols; j += 1) {
        dp[0][j] = j;
      }

      for (let i = 1; i < rows; i += 1) {
        for (let j = 1; j < cols; j += 1) {
          const cost = source[i - 1] === target[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }

      const distance = dp[rows - 1][cols - 1];
      const longest = Math.max(source.length, target.length);

      return longest === 0 ? 1 : 1 - distance / longest;
    };

      if (
        recognitionNotice &&
        speechFeedback &&
        recognitionStatus &&
        recognitionTarget &&
        recognitionText &&
        recognitionScore
      ) {
        syncRecognitionControls();

        if (!SpeechRecognition) {
          if (speechFeedback) {
            speechFeedback.classList.add('is-hidden');
          }
          recognitionNotice.textContent =
            'お使いのブラウザは音声認識に対応していません。Chromeなどの対応ブラウザでお試しください。';
          recognitionNotice.classList.remove('is-hidden');
          recognitionStatus.textContent = '音声認識は利用できません。';
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
          return;
        }

        speechFeedback.classList.remove('is-hidden');
        recognitionNotice.textContent = '初回利用時はマイクアイコンを押す際にブラウザのマイク許可が求められます。';
        recognitionNotice.classList.remove('is-hidden');
        recognitionStatus.textContent = defaultStatusMessage;
        recognitionStatus.dataset.state = 'idle';
        delete recognitionStatus.dataset.previousStatus;

        const recognition = new SpeechRecognition();
        recognition.lang = 'nl-NL';
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        let activeRecognitionButton = null;
        let targetPhrase = '';

        const releaseRecognitionButton = () => {
          if (activeRecognitionButton) {
            activeRecognitionButton.disabled = false;
            activeRecognitionButton.classList.remove('is-recording');
            const defaultLabel =
              activeRecognitionButton.dataset.defaultLabel ?? 'オランダ語フレーズの発声をテスト';
            activeRecognitionButton.setAttribute('aria-label', defaultLabel);
            activeRecognitionButton = null;
          }
        };

        recognition.addEventListener('start', () => {
          showRecognitionLive();

          if (recognitionText) {
            recognitionText.textContent = '聴き取り中…';
          }

          if (recognitionScore) {
            recognitionScore.textContent = '-';
          }

          if (recognitionStatus) {
            recognitionStatus.dataset.previousStatus =
              recognitionStatus.textContent?.trim() || defaultStatusMessage;
            recognitionStatus.dataset.state = 'recognition';
            recognitionStatus.textContent = '録音中です。話し終えたら自動的に判定します。';
          }
        });

        recognition.addEventListener('result', (event) => {
          const transcript = event.results[0][0]?.transcript?.trim() ?? '';
          recognitionText.textContent = transcript || '-';
          recognitionTarget.textContent = targetPhrase || '-';

          const similarity = computeSimilarity(transcript, targetPhrase);
          const percentage = Math.round(similarity * 100);
          recognitionScore.textContent = Number.isNaN(percentage) ? '-' : `${percentage}%`;

          if (transcript && targetPhrase) {
            const isPerfectMatch = !Number.isNaN(percentage) && percentage === 100;
            playRecognitionTone(isPerfectMatch);
          }
        });

        recognition.addEventListener('error', (event) => {
          recognitionStatus.textContent = `エラーが発生しました: ${event.error}`;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
          recognitionText.textContent = '-';
          recognitionScore.textContent = '-';
          hideRecognitionLive();
          releaseRecognitionButton();
        });

        recognition.addEventListener('nomatch', () => {
          recognitionStatus.textContent = '音声を認識できませんでした。もう一度お試しください。';
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
          recognitionText.textContent = '-';
          recognitionScore.textContent = '-';
          hideRecognitionLive();
        });

        recognition.addEventListener('end', () => {
          releaseRecognitionButton();

          if (recognitionStatus) {
            if (recognitionStatus.dataset.state === 'recognition') {
              recognitionStatus.textContent =
                recognitionStatus.dataset.previousStatus || defaultStatusMessage;
            }
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
          }
        });

        const handleRecognitionClick = (event) => {
          const button = event.target.closest('.recognize-control');

          if (!button) {
            return;
          }

          event.preventDefault();
          event.stopPropagation();

          const phraseId = button.dataset.phraseId;
          const phrase = phraseId ? getPhraseById(phraseId) : null;
          const dutchText = phrase?.nl?.trim();

          if (!phrase || !dutchText) {
            return;
          }

          if (activeRecognitionButton) {
            try {
              recognition.abort();
            } catch (error) {
              /* noop */
            }
            releaseRecognitionButton();
          }

          targetPhrase = dutchText;
          recognitionTarget.textContent = dutchText;
          recognitionText.textContent = '-';
          recognitionScore.textContent = '-';
          hideRecognitionLive();

          activeRecognitionButton = button;
          button.disabled = true;
          button.classList.add('is-recording');
          const activeLabel = button.dataset.activeLabel ?? '録音中…';
          button.setAttribute('aria-label', activeLabel);

          try {
            recognition.start();
          } catch (error) {
            recognitionStatus.textContent =
              '音声認識の開始に失敗しました。もう一度お試しください。';
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
            releaseRecognitionButton();
            targetPhrase = '';
            recognitionTarget.textContent = '-';
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();
          }
        };

        document.addEventListener('click', handleRecognitionClick);

        window.addEventListener('beforeunload', () => {
          try {
            recognition.stop();
          } catch (error) {
            /* noop */
          }
        });
      }
    }

    const gameGrid = document.getElementById('game-grid');
    const gameStatus = document.getElementById('game-status');
    const stageDisplay = document.getElementById('game-stage');
    const scoreDisplay = document.getElementById('game-score');
    const streakDisplay = document.getElementById('game-streak');
    const bestDisplay = document.getElementById('game-best');
    const startButton = document.getElementById('game-start-button');
    const resetButton = document.getElementById('game-reset-button');
    const timeDisplay = document.getElementById('game-time');
    const countdownFill = document.getElementById('game-timer-fill');
    const correctDisplay = document.getElementById('game-correct');
    const mistakesDisplay = document.getElementById('game-mistakes');

    const TIME_LIMIT_SECONDS = 60;
    const TIME_LIMIT_MS = TIME_LIMIT_SECONDS * 1000;
    let timerAnimationFrame = null;

    const gameState = {
      stage: 0,
      score: 0,
      streak: 0,
      best: 0,
      matchesRemaining: 0,
      selection: [],
      busy: false,
      phraseQueue: [],
      columns: null,
      timeRemainingMs: TIME_LIMIT_MS,
      correctMatches: 0,
      mistakes: 0,
      timerStartedAt: null,
      roundActive: false,
    };

    const pulseElement = (element) => {
      if (!element) {
        return;
      }

      element.classList.remove('score-pulse');
      void element.offsetWidth;
      element.classList.add('score-pulse');
    };

    const MAX_VISIBLE_PAIRS = 5;

    const stagePairCount = (stage = 1) => {
      const totalPhrases = getAllPhrases().length;

      if (totalPhrases <= 0) {
        return 0;
      }

      return Math.min(stage * MAX_VISIBLE_PAIRS, totalPhrases);
    };

    const setStatus = (message) => {
      if (gameStatus) {
        gameStatus.textContent = message;
      }
    };

    const formatStatusWithSpeechCue = (didSpeak, message) =>
      didSpeak ? `🔊 オランダ語カードの発音を再生したよ。${message}` : message;

    const updateScoreboard = () => {
      if (stageDisplay) {
        stageDisplay.textContent = gameState.stage;
      }

      if (scoreDisplay) {
        scoreDisplay.textContent = gameState.score;
      }

      if (streakDisplay) {
        streakDisplay.textContent = gameState.streak;
      }

      if (bestDisplay) {
        bestDisplay.textContent = `BEST ${gameState.best}`;
      }

      if (correctDisplay) {
        correctDisplay.textContent = gameState.correctMatches;
      }

      if (mistakesDisplay) {
        mistakesDisplay.textContent = gameState.mistakes;
      }

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
        timeDisplay.textContent = seconds.toString();
      }
    };

    const setTimeRemaining = (remainingMs) => {
      const clamped = Math.max(0, Math.min(TIME_LIMIT_MS, remainingMs));
      gameState.timeRemainingMs = clamped;

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(clamped / 1000));
        timeDisplay.textContent = seconds.toString();
      }

      if (countdownFill) {
        const percentage = TIME_LIMIT_MS === 0 ? 0 : (clamped / TIME_LIMIT_MS) * 100;
        countdownFill.style.width = `${percentage}%`;
        countdownFill.classList.toggle('is-warning', percentage <= 50 && percentage > 20);
        countdownFill.classList.toggle('is-danger', percentage <= 20);
      }
    };

    const stopTimer = ({ resetToFull = false } = {}) => {
      if (timerAnimationFrame !== null) {
        cancelAnimationFrame(timerAnimationFrame);
        timerAnimationFrame = null;
      }

      gameState.roundActive = false;
      gameState.timerStartedAt = null;

      if (resetToFull) {
        setTimeRemaining(TIME_LIMIT_MS);
      }
    };

    const handleTimeUp = () => {
      if (gameState.matchesRemaining <= 0) {
        return;
      }

      setTimeRemaining(0);
      gameState.busy = true;
      gameState.roundActive = false;
      gameState.selection = [];
      gameState.streak = 0;

      if (gameGrid) {
        gameGrid.querySelectorAll('.game-card').forEach((card) => {
          card.classList.add('is-disabled');
          card.classList.remove('is-selected');
        });
      }

      const remainingPairs = gameState.matchesRemaining;
      const remainingPenalty = remainingPairs * 5;

      if (remainingPenalty > 0) {
        gameState.score = Math.max(0, gameState.score - remainingPenalty);
      }

      updateScoreboard();

      if (remainingPenalty > 0) {
        pulseElement(scoreDisplay);
      }

      pulseElement(streakDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'もう一度挑戦';
      }

      const summary = `⏰ タイムアップ！${gameState.correctMatches}組正解、ミス${gameState.mistakes}回。`;

      if (remainingPenalty > 0) {
        setStatus(
          `${summary}残り${remainingPairs}組で${remainingPenalty}点の減点…次の挑戦で挽回しよう！`
        );
      } else {
        setStatus(`${summary}あと少しだったね！`);
      }

      gameState.matchesRemaining = 0;
    };

    const tickTimer = (timestamp) => {
      if (!gameState.roundActive) {
        return;
      }

      if (gameState.timerStartedAt === null) {
        gameState.timerStartedAt = timestamp;
      }

      const elapsed = timestamp - gameState.timerStartedAt;
      const remaining = TIME_LIMIT_MS - elapsed;

      if (remaining <= 0) {
        stopTimer();
        handleTimeUp();
        return;
      }

      setTimeRemaining(remaining);
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const startTimer = () => {
      stopTimer();
      gameState.roundActive = true;
      gameState.timerStartedAt = null;
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const createGameCard = (phrase, lang) => {
      const card = document.createElement('div');
      card.className = 'game-card';
      card.dataset.pairId = phrase.id;
      card.dataset.lang = lang;

      const mainButton = document.createElement('button');
      mainButton.type = 'button';
      mainButton.className = 'game-card-main';

      const labelText = lang === 'ja' ? '日本語カード' : 'オランダ語カード';
      const displayText = lang === 'ja' ? phrase.ja : phrase.nl;
      const actionHint =
        lang === 'nl'
          ? '。タップするとオランダ語の発音が再生されます。'
          : '。タップして対応するカードを見つけましょう。';
      mainButton.setAttribute('aria-label', `${labelText}: ${displayText}${actionHint}`);

      if (lang === 'nl') {
        mainButton.title = 'タップするとオランダ語の発音が再生されます';
        mainButton.setAttribute('aria-describedby', 'game-speech-instruction');
      } else {
        mainButton.title = 'タップして対応するカードを探しましょう';
      }

      const textSpan = document.createElement('span');
      textSpan.className = 'game-card-text';
      textSpan.textContent = displayText;

      mainButton.append(textSpan);

      card.append(mainButton);

      return card;
    };

    const speakCardIfDutch = ({ lang, pairId, alreadySelected = false } = {}) => {
      if (alreadySelected || lang !== 'nl' || !pairId) {
        return false;
      }

      if (typeof speakDutchPhrase !== 'function') {
        return false;
      }

      return speakDutchPhrase({ phraseId: pairId });
    };

    const createCardColumn = (lang) => {
      const column = document.createElement('div');
      column.className = 'game-card-column';
      column.dataset.lang = lang;
      column.setAttribute(
        'aria-label',
        lang === 'nl' ? 'オランダ語のカード' : '日本語のカード'
      );
      column.setAttribute('role', 'group');
      return column;
    };

    const rebuildGameColumns = () => {
      if (!gameGrid) {
        return null;
      }

      gameGrid.innerHTML = '';

      const dutchColumn = createCardColumn('nl');
      const japaneseColumn = createCardColumn('ja');

      const fragment = document.createDocumentFragment();
      fragment.append(dutchColumn, japaneseColumn);

      gameGrid.appendChild(fragment);

      return { dutchColumn, japaneseColumn };
    };

    const insertCardRandomly = (column, card) => {
      if (!column || !card) {
        return;
      }

      const insertionIndex = Math.floor(Math.random() * (column.childElementCount + 1));

      if (insertionIndex >= column.childElementCount) {
        column.appendChild(card);
        return;
      }

      column.insertBefore(card, column.children[insertionIndex]);
    };

    const dealPhrasePair = (phrase) => {
      if (!phrase || !gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      const dutchCard = createGameCard(phrase, 'nl');
      const japaneseCard = createGameCard(phrase, 'ja');

      insertCardRandomly(dutchColumn, dutchCard);
      insertCardRandomly(japaneseColumn, japaneseCard);
    };

    const replenishBoard = () => {
      if (!gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      while (
        gameState.phraseQueue.length > 0 &&
        dutchColumn.childElementCount < MAX_VISIBLE_PAIRS &&
        japaneseColumn.childElementCount < MAX_VISIBLE_PAIRS
      ) {
        const nextPhrase = gameState.phraseQueue.shift();

        if (!nextPhrase) {
          break;
        }

        dealPhrasePair(nextPhrase);
      }
    };

    const resetGame = (announce = true) => {
      stopTimer({ resetToFull: true });
      gameState.stage = 0;
      gameState.score = 0;
      gameState.streak = 0;
      gameState.best = 0;
      gameState.matchesRemaining = 0;
      gameState.selection = [];
      gameState.busy = false;
      gameState.phraseQueue = [];
      gameState.columns = null;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;
      gameState.timeRemainingMs = TIME_LIMIT_MS;
      updateScoreboard();

      if (gameGrid) {
        rebuildGameColumns();
        gameGrid.removeAttribute('aria-busy');
      }

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'ステージを始める';
      }

      if (announce) {
        setStatus(
          `ステージを始めて制限時間${TIME_LIMIT_SECONDS}秒以内にカードをマッチさせましょう！オランダ語カードをタップすると発音が流れます。`
        );
      }
    };

    const stageClearFeedback = () => {
      stopTimer();
      const remainingSeconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
      const timeBonus = Math.max(20, remainingSeconds * 2);
      gameState.score += timeBonus;
      updateScoreboard();
      pulseElement(scoreDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = '次のステージへ';
      }

      setStatus(
        `✨ ステージ${gameState.stage}クリア！${gameState.correctMatches}組正解、ミス${gameState.mistakes}回。残り${remainingSeconds}秒でボーナス${timeBonus}点を獲得したよ。`
      );
    };

    let feedbackAudioContext = null;

    const ensureFeedbackAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!feedbackAudioContext) {
        try {
          feedbackAudioContext = new AudioContextClass();
        } catch (error) {
          feedbackAudioContext = null;
          return null;
        }
      }

      if (feedbackAudioContext.state === 'suspended') {
        feedbackAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return feedbackAudioContext;
    };

    const playMatchFeedbackTone = (isMatch) => {
      const context = ensureFeedbackAudioContext();

      if (!context) {
        return;
      }

      try {
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        const now = context.currentTime;

        oscillator.type = 'sine';

        if (isMatch) {
          oscillator.frequency.setValueAtTime(660, now);
          oscillator.frequency.exponentialRampToValueAtTime(990, now + 0.18);
        } else {
          oscillator.frequency.setValueAtTime(240, now);
          oscillator.frequency.exponentialRampToValueAtTime(180, now + 0.18);
        }

        gainNode.gain.setValueAtTime(0.0001, now);
        gainNode.gain.exponentialRampToValueAtTime(0.18, now + 0.04);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

        oscillator.connect(gainNode);
        gainNode.connect(context.destination);

        oscillator.start(now);
        oscillator.stop(now + 0.3);
      } catch (error) {
        /* noop */
      }
    };

    const evaluateSelection = ({ didSpeak = false } = {}) => {
      if (gameState.selection.length < 2) {
        return;
      }

      gameState.busy = true;

      const [first, second] = gameState.selection;
      const isMatch = first.pairId === second.pairId && first.lang !== second.lang;

      const setStatusWithCue = (message) => {
        setStatus(formatStatusWithSpeechCue(didSpeak, message));
      };

      if (isMatch) {
        playMatchFeedbackTone(true);
        const phrase = getPhraseById(first.pairId);
        const matchedCards = [first.card, second.card];

        matchedCards.forEach((card) => {
          card.classList.remove('is-selected');
          card.classList.add('is-matched', 'is-disabled');
        });

        gameState.matchesRemaining -= 1;
        gameState.streak += 1;
        gameState.correctMatches += 1;

        if (gameState.streak > gameState.best) {
          gameState.best = gameState.streak;
        }

        const gained = 10 + gameState.streak * 2;
        gameState.score += gained;
        updateScoreboard();
        pulseElement(scoreDisplay);
        pulseElement(streakDisplay);
        pulseElement(correctDisplay);

        if (phrase) {
          setStatusWithCue(
            `🎉 正解！${gameState.correctMatches}組目の「${phrase.ja}」と「${phrase.nl}」で${gained}点ゲット！`
          );
        } else {
          setStatusWithCue(
            `🎉 正解！${gameState.correctMatches}組目で${gained}点ゲット！`
          );
        }

        gameState.selection = [];
        matchedCards.forEach((card) => {
          if (card && typeof card.remove === 'function') {
            card.remove();
          }
        });

        replenishBoard();

        gameState.busy = false;

        if (gameState.matchesRemaining === 0) {
          stageClearFeedback();
        }

        return;
      }

      playMatchFeedbackTone(false);
      gameState.mistakes += 1;
      const penalty = Math.max(5, 3 + gameState.stage * 2);

      if (penalty > 0) {
        gameState.score = Math.max(0, gameState.score - penalty);
      }

      gameState.streak = 0;
      updateScoreboard();
      pulseElement(streakDisplay);
      pulseElement(mistakesDisplay);

      if (penalty > 0) {
        pulseElement(scoreDisplay);
      }

      setStatusWithCue(
        penalty > 0
          ? `😅 ミス${gameState.mistakes}回目。${penalty}点減点だけど、まだ巻き返せるよ！`
          : `😅 ミス${gameState.mistakes}回目。次は当ててみよう！`
      );

      const [firstCard, secondCard] = [first.card, second.card];

      setTimeout(() => {
        firstCard.classList.remove('is-selected');
        secondCard.classList.remove('is-selected');
        gameState.selection = [];
        gameState.busy = false;
      }, 700);
    };

    const handleCardSelection = (card) => {
      if (!card || gameState.busy || !gameState.roundActive) {
        return;
      }

      if (card.classList.contains('is-matched') || card.classList.contains('is-disabled')) {
        return;
      }

      const pairId = card.getAttribute('data-pair-id');
      const lang = card.getAttribute('data-lang');

      if (!pairId || !lang) {
        return;
      }

      const isAlreadySelected = card.classList.contains('is-selected');

      if (gameState.selection.length === 0) {
        const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
        gameState.selection.push({ card, pairId, lang });
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'もう1枚選んでペアを作ろう！'));
        return;
      }

      const [firstSelection] = gameState.selection;

      if (firstSelection.card === card) {
        card.classList.remove('is-selected');
        gameState.selection = [];
        setStatus(formatStatusWithSpeechCue(false, 'カードを選び直したよ。'));
        return;
      }

      if (firstSelection.lang === lang) {
        const didSpeak = speakCardIfDutch({ lang, pairId });
        firstSelection.card.classList.remove('is-selected');
        gameState.selection = [{ card, pairId, lang }];
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'もう1枚選んでペアを作ろう！'));
        return;
      }

      const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
      gameState.selection.push({ card, pairId, lang });
      card.classList.add('is-selected');
      evaluateSelection({ didSpeak });
    };

    const startStage = () => {
      if (!gameGrid) {
        return;
      }

      stopTimer({ resetToFull: true });

      const nextStage = gameState.stage + 1;
      const pairCount = stagePairCount(nextStage);

      if (pairCount <= 0) {
        setStatus('フレーズデータを読み込み中です。少し待ってからもう一度お試しください。');
        return;
      }

      const availablePhrases = getAllPhrases();

      if (availablePhrases.length === 0) {
        setStatus('フレーズデータを読み込み中です。少し待ってからもう一度お試しください。');
        return;
      }

      const selectedPairs = shuffleArray(availablePhrases).slice(0, pairCount);

      gameGrid.setAttribute('aria-busy', 'true');

      const columns = rebuildGameColumns();

      if (!columns) {
        gameGrid.removeAttribute('aria-busy');
        return;
      }

      gameState.columns = columns;
      gameState.phraseQueue = [...selectedPairs];

      replenishBoard();

      gameGrid.removeAttribute('aria-busy');

      gameState.stage = nextStage;
      gameState.matchesRemaining = selectedPairs.length;
      gameState.selection = [];
      gameState.busy = false;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;

      if (startButton) {
        startButton.disabled = true;
        startButton.textContent = 'プレイ中…';
      }

      updateScoreboard();
      startTimer();
      setStatus(
        `ステージ${gameState.stage}スタート！制限時間${TIME_LIMIT_SECONDS}秒以内に同じ意味のカードをタップしてね。オランダ語カードはタップで発音が流れるよ。`
      );
    };

    if (gameGrid) {
      gameGrid.addEventListener('click', (event) => {
        const mainButton = event.target.closest('.game-card-main');

        if (mainButton) {
          event.preventDefault();
          const card = mainButton.closest('.game-card');
          handleCardSelection(card);
        }
      });
    }

    if (startButton) {
      startButton.addEventListener('click', () => {
        if (startButton.disabled) {
          return;
        }

        startStage();
      });
    }

    if (resetButton) {
      resetButton.addEventListener('click', () => {
        resetGame();
        if (startButton) {
          startButton.focus();
        }
      });
    }

    resetGame();
  </script>

</body>
</html>
