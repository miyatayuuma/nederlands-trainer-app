<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NederLingo | æ—¥æœ¬èªâ‡”ã‚ªãƒ©ãƒ³ãƒ€èªãƒ•ãƒ¬ãƒ¼ã‚ºå­¦ç¿’</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f7f7fb;
      --fg: #1f2933;
      --accent: #ff7a59;
      --accent-dark: #c24e31;
      --card-bg: #ffffff;
      --muted: #5f6c7b;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f172a;
        --fg: #e2e8f0;
        --card-bg: #16203a;
        --muted: #8ea4c4;
      }

      .speech-feedback {
        background: rgba(148, 163, 184, 0.12);
        border-color: rgba(148, 163, 184, 0.2);
      }
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Helvetica Neue", sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px 20px 16px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 4vw, 2.4rem);
      letter-spacing: 0.04em;
    }

    header p {
      margin: 12px auto 0;
      max-width: 720px;
      font-size: 1rem;
      color: var(--muted);
      line-height: 1.6;
    }

    main {
      flex: 1;
      width: min(960px, 92vw);
      margin: 0 auto 48px;
    }

    .main-container {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-switcher {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .mode-button {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(31, 41, 51, 0.12);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease-in-out, border 0.2s ease-in-out, color 0.2s ease-in-out;
    }

    .mode-button:hover,
    .mode-button:focus-visible {
      background: rgba(31, 41, 51, 0.08);
      border-color: rgba(31, 41, 51, 0.24);
      outline: none;
    }

    .mode-button[aria-selected="true"] {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
    }

    .mode-panel-group {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-panel {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      border: 1px solid rgba(15, 23, 42, 0.05);
    }

    .setup-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .setup-list li {
      padding: 14px 16px;
      border-radius: 16px;
      background: rgba(255, 122, 89, 0.08);
      border: 1px dashed rgba(255, 122, 89, 0.4);
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .phrase-dutch {
      display: inline-block;
      font-weight: 600;
    }

    .phrase-note {
      display: block;
      margin-top: 4px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .phrase-actions {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid rgba(31, 41, 51, 0.16);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
    }

    .icon-button:hover,
    .icon-button:focus-visible {
      background: rgba(31, 41, 51, 0.1);
      border-color: rgba(31, 41, 51, 0.32);
      outline: none;
      transform: translateY(-1px);
    }

    .icon-button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
    }

    .icon-button.is-active,
    .icon-button.is-recording {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .speech-toolbar {
      position: sticky;
      top: 12px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 16px;
      border-radius: 16px;
      background: var(--card-bg);
      border: 1px solid rgba(15, 23, 42, 0.08);
      box-shadow: 0 16px 36px rgba(15, 23, 42, 0.12);
    }

    .speech-toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: stretch;
    }

    .speech-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 0.9rem;
      color: var(--muted);
      flex: 1 1 200px;
    }

    .speech-controls label {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-controls input[type="range"] {
      accent-color: var(--accent);
      min-width: 140px;
    }

    .speech-feedback {
      flex: 1 1 280px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.95rem;
      background: rgba(15, 23, 42, 0.05);
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(15, 23, 42, 0.08);
    }

    .speech-feedback-target {
      margin: 0;
      font-size: clamp(1.15rem, 2.8vw, 1.4rem);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .speech-feedback-live {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .speech-feedback-live[hidden] {
      display: none;
    }

    .speech-feedback-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.95rem;
    }

    .speech-feedback-text {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-feedback-score {
      font-weight: 600;
      color: var(--fg);
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .speech-notice {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .intro-card p {
      margin-bottom: 16px;
      line-height: 1.7;
      color: var(--muted);
    }

    .phrase-browser {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .phrase-section-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .phrase-section-header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.7;
      font-size: 0.95rem;
    }

    .phrase-filter-form {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .filter-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .filter-field span {
      font-weight: 600;
      color: var(--fg);
    }

    .filter-field select {
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.02);
      font-size: 0.95rem;
      color: inherit;
    }

    .filter-field select:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-filter {
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 16px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(15, 23, 42, 0.02);
    }

    .tag-filter legend {
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .tag-filter-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .tag-chip {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .tag-chip input {
      position: absolute;
      opacity: 0;
      width: 1px;
      height: 1px;
      margin: 0;
      border: 0;
      padding: 0;
      clip: rect(0, 0, 0, 0);
    }

    .tag-chip span {
      display: inline-flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.05);
      font-size: 0.85rem;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      cursor: pointer;
    }

    .tag-chip input:checked + span {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .tag-chip input:focus-visible + span {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-clear-button,
    .filter-reset-button {
      align-self: flex-start;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .tag-clear-button:hover,
    .tag-clear-button:focus-visible,
    .filter-reset-button:hover,
    .filter-reset-button:focus-visible {
      background: rgba(15, 23, 42, 0.08);
      border-color: rgba(15, 23, 42, 0.32);
      outline: none;
    }

    .filter-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .phrase-count {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .phrase-status {
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.05);
      border: 1px solid rgba(15, 23, 42, 0.1);
      font-size: 0.9rem;
      color: var(--muted);
    }

    .scenario-list {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .scenario-card {
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 18px;
      padding: 20px 20px 24px;
      background: var(--card-bg);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
    }

    .scenario-card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .scenario-card-header h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .scenario-count {
      font-size: 0.85rem;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.08);
    }

    .scenario-note {
      margin: 0 0 16px;
      color: var(--muted);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .scenario-category + .scenario-category {
      margin-top: 20px;
    }

    .scenario-category h4 {
      margin: 0 0 12px;
      font-size: 1.05rem;
    }

    .phrase-meta {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .phrase-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: rgba(15, 23, 42, 0.1);
      color: var(--muted);
    }

    .phrase-badge-level {
      background: rgba(255, 122, 89, 0.18);
      color: var(--accent-dark);
    }

    .phrase-badge-tag {
      background: rgba(15, 23, 42, 0.08);
    }

    .is-hidden {
      display: none !important;
    }

    .game-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .game-intro p {
      margin: 0;
      line-height: 1.6;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .game-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      align-items: center;
    }

    .game-meta .meta-box {
      border-radius: 14px;
      background: rgba(31, 41, 51, 0.06);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .meta-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .meta-value {
      font-size: 1.35rem;
      font-weight: 700;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .meta-value small {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--muted);
    }

    .meta-box-timer {
      gap: 8px;
    }

    .countdown-bar {
      position: relative;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(31, 41, 51, 0.12);
      overflow: hidden;
    }

    .countdown-bar-fill {
      width: 100%;
      height: 100%;
      background: var(--accent);
      transform-origin: left center;
      transition: width 120ms linear, background 180ms ease-in-out;
    }

    .countdown-bar-fill.is-warning {
      background: #f59e0b;
    }

    .countdown-bar-fill.is-danger {
      background: #ef4444;
    }

    .game-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .game-button {
      padding: 10px 18px;
      border-radius: 12px;
      border: none;
      font-size: 0.95rem;
      cursor: pointer;
      background: var(--accent);
      color: #ffffff;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    .game-button:hover,
    .game-button:focus-visible {
      background: var(--accent-dark);
      transform: translateY(-1px);
      outline: none;
    }

    .game-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .game-button.secondary {
      background: rgba(31, 41, 51, 0.08);
      color: var(--fg);
    }

    .game-status {
      min-height: 1.4em;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .game-card-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 20px;
      align-items: start;
    }

    .game-card-column {
      display: grid;
      grid-template-rows: repeat(5, minmax(0, auto));
      gap: 12px;
    }

    .game-card {
      position: relative;
      border-radius: 16px;
      padding: 6px;
      background: var(--card-bg);
      border: 2px solid transparent;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      transition: transform 0.18s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .game-card[data-lang="ja"] {
      background: linear-gradient(135deg, rgba(255, 225, 215, 0.45), rgba(255, 255, 255, 0.8));
    }

    .game-card[data-lang="nl"] {
      background: linear-gradient(135deg, rgba(210, 230, 255, 0.4), rgba(255, 255, 255, 0.85));
    }

    .game-card-main {
      width: 100%;
      min-height: 68px;
      border: none;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.35;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .game-card-text {
      display: block;
      line-height: 1.4;
    }

    .game-card[data-lang="nl"] .game-card-main {
      font-size: 1rem;
    }

    .game-card-main:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .game-card.is-selected {
      border-color: var(--accent);
      transform: translateY(-4px);
    }

    .game-card.is-matched {
      border-color: var(--accent);
      animation: cardMatch 520ms ease;
      box-shadow: 0 16px 32px rgba(255, 122, 89, 0.32);
    }

    .game-card.is-disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    .score-pulse {
      animation: scorePulse 420ms ease;
    }

    @keyframes scorePulse {
      0% {
        transform: scale(1);
      }

      40% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
      }
    }

    @keyframes cardMatch {
      0% {
        transform: scale(0.96);
      }

      60% {
        transform: scale(1.08);
      }

      100% {
        transform: scale(1);
      }
    }

    .phrase-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.02);
    }

    .phrase-table th,
    .phrase-table td {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      text-align: left;
      vertical-align: top;
    }

    .phrase-table thead th {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .phrase-table tbody tr:last-child td {
      border-bottom: none;
    }

    .phrase-table td strong {
      display: block;
      font-size: 1rem;
    }

    @media (max-width: 640px) {
      .game-meta {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

      .game-card-grid {
        gap: 16px;
      }

      .game-card-column {
        gap: 10px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 60px;
        padding: 10px 8px;
        font-size: 0.95rem;
      }

      .phrase-table thead {
        display: none;
      }

      .phrase-table,
      .phrase-table tbody,
      .phrase-table tr,
      .phrase-table td {
        display: block;
        width: 100%;
      }

      .phrase-table tr {
        padding: 12px 0;
        border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      }

      .phrase-table tbody tr:last-child {
        border-bottom: none;
      }

      .phrase-table td {
        border: none;
        padding: 6px 0;
      }

      .phrase-table td::before {
        content: attr(data-label);
        display: block;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .phrase-actions {
        margin-top: 10px;
      }

      .icon-button {
        width: 34px;
        height: 34px;
      }
    }

    @media (max-width: 480px) {
      .game-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .game-card-grid {
        gap: 14px;
      }

      .game-card-column {
        gap: 8px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 56px;
        font-size: 0.95rem;
      }
    }

    [hidden] {
      display: none !important;
    }

    footer {
      text-align: center;
      padding: 24px 16px 32px;
      font-size: 0.85rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>NederLingo</h1>
    <p>
      æ—¥æœ¬èªã¨ã‚ªãƒ©ãƒ³ãƒ€èªã®ãƒ•ãƒ¬ãƒ¼ã‚ºç·´ç¿’ã‚’ã€ç›®çš„ã«åˆã‚ã›ã¦åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ‰å­¦ç¿’ä½“é¨“ã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã—ã¾ã—ãŸã€‚
    </p>
    <p>
      è½ã¡ç€ã„ã¦ç™ºéŸ³ã‚„æ„å‘³ã‚’ç¢ºèªã§ãã‚‹ã€Œãƒ•ãƒ¬ãƒ¼ã‚ºå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã€ã¨ã€ä»Šå¾Œå…¬é–‹äºˆå®šã®å¯¾æˆ¦è¦ç´ ã‚’å‚™ãˆãŸã€Œãƒ•ãƒ¬ãƒ¼ã‚ºãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ¢ãƒ¼ãƒ‰ã€ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã€è‡ªåˆ†ã«åˆã£ãŸãƒªã‚ºãƒ ã§å­¦ã³ã¾ã—ã‚‡ã†ã€‚
    </p>
  </header>

  <main>
    <div class="main-container" data-active-mode="study">
      <div class="mode-switcher" role="tablist" aria-label="å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã®é¸æŠ">
        <button
          id="mode-tab-study"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-study"
          aria-selected="true"
          data-mode="study"
        >
          ãƒ•ãƒ¬ãƒ¼ã‚ºå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰
        </button>
        <button
          id="mode-tab-game"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-game"
          aria-selected="false"
          tabindex="-1"
          data-mode="game"
        >
          ãƒ•ãƒ¬ãƒ¼ã‚ºãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ¢ãƒ¼ãƒ‰
        </button>
      </div>

      <div class="mode-panel-group">
        <section
          id="mode-panel-study"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-study"
          aria-hidden="false"
          data-mode-panel="study"
        >
          <section class="card intro-card">
            <h2>æ—…ã®ã‚·ãƒŠãƒªã‚ªã«åˆã‚ã›ã¦å­¦ã¶</h2>
            <p>
              é•·æœŸæ»åœ¨ã®æ—…è¡Œè€…ãŒç›´é¢ã™ã‚‹ã‚·ãƒãƒ¥ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æƒ³å®šã—ã€æ—¥å¸¸ä¼šè©±ã‹ã‚‰ç©ºæ¸¯ãƒ»äº¤é€šã€å®¿æ³Šã€é£Ÿäº‹ã€è¦³å…‰ã€ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã€ç·Šæ€¥å¯¾å¿œã¾ã§58ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’æ•´ç†ã—ã¾ã—ãŸã€‚éŸ³å£°ã®å†ç”Ÿã¨ç™ºè©±ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’æ´»ç”¨ã—ã¦ã€æ»åœ¨ä¸­ã«å¿…è¦ãªè¡¨ç¾ã‚’å®Ÿè·µçš„ã«èº«ã«ã¤ã‘ã¾ã—ã‚‡ã†ã€‚
            </p>
            <ul class="setup-list">
              <li>æ—¥å¸¸ãƒ»ç§»å‹•ãƒ»å®¿æ³Šãƒ»é£Ÿäº‹ãƒ»è¦³å…‰ãƒ»ç·Šæ€¥ã®7ã‚·ãƒŠãƒªã‚ªã‚’ã‚«ãƒãƒ¼</li>
              <li>ã‚·ãƒŠãƒªã‚ªãƒ»ãƒ¬ãƒ™ãƒ«ãƒ»ã‚¿ã‚°ã«ã‚ˆã‚‹æŸ”è»Ÿãªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã¨ä¸¦ã³æ›¿ãˆ</li>
              <li>å…¨ãƒ•ãƒ¬ãƒ¼ã‚ºã§éŸ³å£°å†ç”Ÿã¨ãƒã‚¤ã‚¯ã«ã‚ˆã‚‹ç™ºè©±ãƒã‚§ãƒƒã‚¯ãŒå¯èƒ½</li>
            </ul>
          </section>

          <section class="speech-toolbar" aria-label="éŸ³å£°ã‚µãƒãƒ¼ãƒˆ">
            <div class="speech-toolbar-row">
              <div class="speech-controls">
                <label for="speech-rate">å†ç”Ÿé€Ÿåº¦ <span id="speech-rate-value">1.0x</span></label>
                <input
                  type="range"
                  id="speech-rate"
                  name="speech-rate"
                  min="0.6"
                  max="1.4"
                  step="0.1"
                  value="1"
                >
              </div>
              <div id="speech-feedback" class="speech-feedback" aria-live="polite">
                <p id="recognition-target" class="speech-feedback-target">-</p>
                <p id="recognition-live" class="speech-feedback-live" hidden>
                  <span class="speech-feedback-icon" aria-hidden="true">ğŸ™</span>
                  <span id="recognition-text" class="speech-feedback-text">-</span>
                  <span id="recognition-score" class="speech-feedback-score">-</span>
                </p>
                <span id="recognition-status" class="visually-hidden">éŒ²éŸ³å¾…æ©Ÿä¸­ã§ã™ã€‚</span>
              </div>
            </div>
            <p id="speech-recognition-notice" class="speech-notice is-hidden" aria-live="polite"></p>
          </section>
          <section class="card phrase-browser">
            <div class="phrase-section-header">
              <h2>ã‚·ãƒŠãƒªã‚ªåˆ¥ãƒ•ãƒ¬ãƒ¼ã‚º</h2>
              <p>
                ç©ºæ¸¯ã€äº¤é€šã€å®¿æ³Šã€é£Ÿäº‹ã€è¦³å…‰ã€ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã€ç·Šæ€¥æ™‚ãªã©ãƒãƒ«ãƒã‚¦ã‚£ãƒ¼ã‚¯æ»åœ¨ã§å‡ºä¼šã†å ´é¢ã‚’ã‚«ãƒãƒ¼ã—ã¦ã„ã¾ã™ã€‚ã‚·ãƒŠãƒªã‚ªã‚„ãƒ¬ãƒ™ãƒ«ã€èˆˆå‘³ã®ã‚ã‚‹ã‚¿ã‚°ã§çµã‚Šè¾¼ã¿ã€å¿…è¦ãªãƒ•ãƒ¬ãƒ¼ã‚ºã‹ã‚‰é‡ç‚¹çš„ã«ç·´ç¿’ã—ã¾ã—ã‚‡ã†ã€‚
              </p>
            </div>
            <form id="phrase-filter-form" class="phrase-filter-form" autocomplete="off">
              <div class="filter-grid">
                <label class="filter-field">
                  <span>ã‚·ãƒŠãƒªã‚ª</span>
                  <select id="filter-scenario" name="scenario"></select>
                </label>
                <label class="filter-field">
                  <span>ãƒ¬ãƒ™ãƒ«</span>
                  <select id="filter-level" name="level"></select>
                </label>
                <label class="filter-field">
                  <span>ä¸¦ã³é †</span>
                  <select id="filter-sort" name="sort"></select>
                </label>
              </div>
              <fieldset class="tag-filter">
                <legend>ã‚¿ã‚°ã§çµã‚Šè¾¼ã‚€</legend>
                <div id="tag-filter-options" class="tag-filter-options"></div>
                <button type="button" id="tag-clear-button" class="tag-clear-button">ã‚¿ã‚°ã‚’ã‚¯ãƒªã‚¢</button>
              </fieldset>
              <div class="filter-footer">
                <span id="phrase-count" class="phrase-count" aria-live="polite">- ä»¶ã®ãƒ•ãƒ¬ãƒ¼ã‚º</span>
                <button type="reset" class="filter-reset-button">æ¡ä»¶ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
              </div>
            </form>
            <div id="phrase-loading" class="phrase-status" role="status" aria-live="polite">
              ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™â€¦
            </div>
            <div id="phrase-error" class="phrase-status is-hidden" role="status" aria-live="polite"></div>
            <div id="phrase-empty" class="phrase-status is-hidden" role="status" aria-live="polite">
              æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ã‚ºãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
            </div>
            <div id="study-content" class="scenario-list" aria-live="polite"></div>
          </section>
        </section>

        <section
          id="mode-panel-game"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-game"
          data-mode-panel="game"
          hidden
          aria-hidden="true"
        >
          <section class="card game-section">
            <div class="game-intro">
              <h2>ãƒ•ãƒ¬ãƒ¼ã‚ºãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ¢ãƒ¼ãƒ‰</h2>
              <p>
                æ—¥æœ¬èªã‚«ãƒ¼ãƒ‰ã¨ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒšã‚¢ã‚’è¦‹ã¤ã‘ã‚‹ã€ãƒ†ãƒ³ãƒã®è‰¯ã„ãƒãƒƒãƒãƒ³ã‚°ã‚²ãƒ¼ãƒ ã§ã™ã€‚è€³ã¨ç›®ã‚’åŒæ™‚ã«ä½¿ã„ãªãŒã‚‰ã€çŸ­æ™‚é–“ã§ä½•åº¦ã‚‚éŠã‚“ã§ã¿ã¾ã—ã‚‡ã†ã€‚
              </p>
            </div>
            <div class="game-meta">
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Stage</span>
                <span class="meta-value">
                  <span id="game-stage">0</span><small>æ®µ</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Score</span>
                <span class="meta-value">
                  <span id="game-score">0</span><small>pt</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">é€£ç¶šæ­£è§£</span>
                <span class="meta-value">
                  <span id="game-streak">0</span><small id="game-best">BEST 0</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">æ­£è§£æ•°</span>
                <span class="meta-value">
                  <span id="game-correct">0</span><small>çµ„</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">ãƒŸã‚¹</span>
                <span class="meta-value">
                  <span id="game-mistakes">0</span><small>å›</small>
                </span>
              </div>
              <div class="meta-box meta-box-timer" aria-live="polite">
                <span class="meta-label">æ®‹ã‚Šæ™‚é–“</span>
                <span class="meta-value">
                  <span id="game-time">60</span><small>ç§’</small>
                </span>
                <div class="countdown-bar" role="presentation" aria-hidden="true">
                  <div id="game-timer-fill" class="countdown-bar-fill"></div>
                </div>
              </div>
            </div>
            <div class="game-controls">
              <button id="game-start-button" class="game-button" type="button">ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å§‹ã‚ã‚‹</button>
              <button id="game-reset-button" class="game-button secondary" type="button">ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <p id="game-status" class="game-status" aria-live="polite">ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å§‹ã‚ã¦åˆ¶é™æ™‚é–“60ç§’ä»¥å†…ã«ã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒƒãƒã•ã›ã¾ã—ã‚‡ã†ï¼</p>
            <p id="game-speech-instruction" class="visually-hidden">
              ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰ã¯ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ç™ºéŸ³ãŒå†ç”Ÿã•ã‚Œã¾ã™ã€‚éŸ³å£°ã®ãƒ’ãƒ³ãƒˆã‚’èããªãŒã‚‰å¯¾å¿œã™ã‚‹æ—¥æœ¬èªã‚«ãƒ¼ãƒ‰ã‚’æ¢ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
            </p>
            <div
              id="game-grid"
              class="game-card-grid"
              aria-label="æ—¥æœ¬èªã¨ã‚ªãƒ©ãƒ³ãƒ€èªã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã‚°ãƒªãƒƒãƒ‰"
              aria-describedby="game-speech-instruction"
              aria-live="polite"
            ></div>
          </section>
        </section>
      </div>
    </div>
  </main>

  <footer>
    &copy; 2024 NederLingo. All rights reserved.
  </footer>

  <script type="application/json" id="embedded-phrases">
    {
      "phrases": [
        {
          "id": "greet-morning",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["ã‚ã„ã•ã¤", "ä¸å¯§"],
          "ja": "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€‚",
          "nl": "Goedemorgen.",
          "hint": "ãƒ•ãƒ¼ãƒ‡ãƒ¢ãƒ«ãƒ˜ãƒ³ /É£udÉ™ËˆmÉ”r.É£É™(n)/",
          "note": "ä¸å¯§ãªæœã®æŒ¨æ‹¶",
          "featured": true
        },
        {
          "id": "greet-day",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["ã‚ã„ã•ã¤"],
          "ja": "ã“ã‚“ã«ã¡ã¯ã€‚",
          "nl": "Goedemiddag.",
          "hint": "ãƒ•ãƒ¼ãƒ‡ãƒŸãƒ€ãƒ• /É£udÉ™ËˆmÉªdÉ‘x/",
          "note": "æ—¥ä¸­ã®æŒ¨æ‹¶"
        },
        {
          "id": "greet-evening",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["ã‚ã„ã•ã¤", "å¤•æ–¹"],
          "ja": "ã“ã‚“ã°ã‚“ã¯ã€‚",
          "nl": "Goedenavond.",
          "hint": "ãƒ•ãƒ¼ãƒ‡ãƒŠãƒ¼ãƒ•ã‚©ãƒ³ãƒˆ /É£udÉ™ËˆnaËvÉ”nt/",
          "note": "å¤•æ–¹ä»¥é™ã®æŒ¨æ‹¶"
        },
        {
          "id": "greet-meet",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["è‡ªå·±ç´¹ä»‹", "åˆå¯¾é¢"],
          "ja": "ã¯ã˜ã‚ã¾ã—ã¦ã€‚",
          "nl": "Aangenaam.",
          "hint": "ã‚¢ãƒ¼ãƒãƒŠãƒ¼ãƒ  /ËˆaËÅ‹É£É™naËm/",
          "note": "åˆå¯¾é¢ã®æŒ¨æ‹¶"
        },
        {
          "id": "greet-bye",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["ã‚ã„ã•ã¤", "åˆ¥ã‚Œ"],
          "ja": "ã•ã‚ˆã†ãªã‚‰ã€‚",
          "nl": "Tot ziens.",
          "hint": "ãƒˆãƒƒãƒ„ã‚£ãƒ³ã‚¹ /tÉ”t Ëˆzins/",
          "note": "ä¸å¯§ãªåˆ¥ã‚Œã®æŒ¨æ‹¶"
        },
        {
          "id": "greet-later",
          "category": "æŒ¨æ‹¶",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["åˆ¥ã‚Œ", "ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«"],
          "ja": "ã¾ãŸå¾Œã§ã­ã€‚",
          "nl": "Tot later.",
          "hint": "ãƒˆãƒˆ ãƒ©ãƒ¼ãƒ†ãƒ« /tÉ”t ËˆlaËtÉ™r/",
          "note": "ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãªåˆ¥ã‚Œ"
        },
        {
          "id": "intro-from",
          "category": "è‡ªå·±ç´¹ä»‹",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["è‡ªå·±ç´¹ä»‹", "å‡ºèº«"],
          "ja": "æ—¥æœ¬ã‹ã‚‰æ¥ã¾ã—ãŸã€‚",
          "nl": "Ik kom uit Japan.",
          "hint": "ã‚¤ã‚¯ ã‚³ãƒ  ã‚¢ã‚¦ãƒˆ ãƒ¤ãƒ‘ãƒ³ /Éªk kÉ”m Å“yÌ¯t jÉ‘ËˆpÉ‘n/",
          "note": "å‡ºèº«åœ°ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "intro-length",
          "category": "è‡ªå·±ç´¹ä»‹",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "å®¿æ³Š"],
          "level": ["A2"],
          "tags": ["æ»åœ¨è¨ˆç”»", "é•·æœŸæ»åœ¨"],
          "ja": "æ•°é€±é–“æ»åœ¨ã™ã‚‹äºˆå®šã§ã™ã€‚",
          "nl": "Ik blijf een paar weken.",
          "hint": "ã‚¤ã‚¯ ãƒ–ãƒ©ã‚¤ãƒ• ã‚¨ãƒ¼ãƒ³ ãƒ‘ãƒ¼ãƒ« ãƒ´ã‚§ãƒ¼ã‚±ãƒ³ /Éªk blÉ›iÌ¯f eËn paËr ËˆÊ‹eËkÉ™(n)/",
          "note": "æ»åœ¨æœŸé–“ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "smalltalk-weather",
          "category": "ä¸–é–“è©±",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "è¦³å…‰"],
          "level": ["A1"],
          "tags": ["å¤©æ°—", "ä¼šè©±"],
          "ja": "ä»Šæ—¥ã¯è‰¯ã„å¤©æ°—ã§ã™ã­ã€‚",
          "nl": "Het is mooi weer vandaag.",
          "hint": "ãƒ˜ãƒƒãƒˆ ã‚¤ã‚¹ ãƒ¢ã‚¤ ã‚¦ã‚§ãƒ¼ã‚¢ ãƒ•ã‚¡ãƒ³ãƒ€ãƒ¼ãƒ• /É¦É›t Éªs mÉ”iÌ¯ Ê‹eËr fÉ‘nËˆdaËx/",
          "note": "å¤©æ°—ã®è©±é¡Œ"
        },
        {
          "id": "smalltalk-plan",
          "category": "ä¸–é–“è©±",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "è¦³å…‰"],
          "level": ["A2"],
          "tags": ["è¨ˆç”»", "ä¼šè©±"],
          "ja": "æ˜æ—¥ã¯ã©ã“ã‚’è¨ªã‚Œã‚‹äºˆå®šã§ã™ã‹ï¼Ÿ",
          "nl": "Waar gaat u morgen naartoe?",
          "hint": "ãƒ¯ãƒ¼ãƒ« ãƒãƒ¼ãƒˆã‚¥ãƒ¼ ãƒ¢ãƒ«ãƒ˜ãƒ³ ãƒŠãƒ¼ãƒ«ãƒˆãƒ¼ /Ê‹aËr É£aËt y ËˆmÉ”rÉ£É™(n) naËrËˆtoË/",
          "note": "æ—…è¡Œè¨ˆç”»ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "polite-thanks",
          "category": "åŸºæœ¬è¡¨ç¾",
          "scenario": ["æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["æ„Ÿè¬", "ä¸å¯§"],
          "ja": "ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚",
          "nl": "Dank u wel.",
          "hint": "ãƒ€ãƒ³ã‚¯ ã‚¦ ãƒ´ã‚§ãƒ« /dÉ‘Å‹k y Ê‹É›l/",
          "note": "ä¸å¯§ãªæ„Ÿè¬",
          "featured": true
        },
        {
          "id": "polite-sorry",
          "category": "åŸºæœ¬è¡¨ç¾",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "äº¤é€š"],
          "level": ["A1"],
          "tags": ["è¬ç½ª", "ä¸å¯§"],
          "ja": "ã™ã¿ã¾ã›ã‚“ã€‚",
          "nl": "Pardon.",
          "hint": "ãƒ‘ãƒ«ãƒ‰ãƒ³ /ËˆpÉ‘r.dÉ”n/",
          "note": "è»½ã„è¬ç½ª",
          "featured": true
        },
        {
          "id": "request-repeat",
          "category": "åŸºæœ¬è¡¨ç¾",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "äº¤é€š"],
          "level": ["A1"],
          "tags": ["èãè¿”ã™", "ä¸å¯§"],
          "ja": "ã‚‚ã†ä¸€åº¦ã‚†ã£ãã‚Šè¨€ã£ã¦ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunt u het nog eens langzaam zeggen?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ãƒ˜ãƒƒãƒˆ ãƒãƒƒãƒ› ã‚¨ãƒ¼ã‚¹ ãƒ©ãƒ³ã‚°ã‚¶ãƒ¼ãƒ  ã‚¼ãƒƒãƒ˜ãƒ³ /kÊnt y É¦É™t nÉ”x eËs ËˆlÉ‘Å‹.zaËm ËˆzÉ›É£É™(n)/",
          "note": "èãè¿”ã™"
        },
        {
          "id": "airport-checkin",
          "category": "ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³",
          "scenario": ["ç©ºæ¸¯"],
          "level": ["A1"],
          "tags": ["æ­ä¹—", "æ‰‹ç¶šã"],
          "ja": "ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚",
          "nl": "Ik wil graag inchecken.",
          "hint": "ã‚¤ã‚¯ ãƒ´ã‚£ãƒ« ãƒ•ãƒ©ãƒ¼ãƒ• ã‚¤ãƒ³ãƒã‚§ãƒƒã‚±ãƒ³ /Éªk Ê‹Éªl É£raËx ËˆÉªnËŒtÊƒÉ›kÉ™(n)/",
          "note": "ç©ºæ¸¯ã§ã®æ‰‹ç¶šã",
          "featured": true
        },
        {
          "id": "airport-baggage",
          "category": "æ‰‹è·ç‰©",
          "scenario": ["ç©ºæ¸¯"],
          "level": ["A2"],
          "tags": ["è·ç‰©", "ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼"],
          "ja": "é ã‘å…¥ã‚Œè·ç‰©ã¯ã©ã“ã§é ã‘ã¾ã™ã‹ï¼Ÿ",
          "nl": "Waar kan ik mijn ruimbagage afgeven?",
          "hint": "ãƒ¯ãƒ¼ãƒ« ã‚«ãƒ³ ã‚¤ã‚¯ ãƒ¡ã‚¤ãƒ³ ãƒ­ã‚¤ãƒ ãƒãƒãƒ¼ãƒ•ã‚§ ã‚¢ãƒ•ã‚²ãƒ¼ãƒ•ã‚§ãƒ³ /Ê‹aËr kÉ‘n Éªk mÉ›iÌ¯n ËˆrÅ“yÌ¯m.baËËŒÉ£aËÉ¦É™ ËˆÉ‘fËŒÉ£eËvÉ™(n)/",
          "note": "æ‰‹è·ç‰©ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "airport-security",
          "category": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£",
          "scenario": ["ç©ºæ¸¯"],
          "level": ["A2"],
          "tags": ["è·ç‰©", "ãƒ«ãƒ¼ãƒ«"],
          "ja": "æ¶²ä½“ã¯æ©Ÿå†…æŒã¡è¾¼ã¿ã§ãã¾ã™ã‹ï¼Ÿ",
          "nl": "Mag ik vloeistoffen in mijn handbagage meenemen?",
          "hint": "ãƒãƒƒ ãƒ•ãƒ­ã‚¤ã‚¹ãƒˆãƒƒãƒ•ã‚§ãƒ³ ã‚¤ãƒ³ ãƒ¡ã‚¤ãƒ³ ãƒãƒ³ãƒ‰ãƒãƒãƒ¼ãƒ•ã‚§ ãƒ¡ãƒ¼ãƒãƒ¼ãƒ¡ãƒ³ /mÉ‘x fËˆlÊiÌ¯.stÉ”.fÉ™(n) Éªn mÉ›iÌ¯n ËˆÉ¦É‘nd.baËËŒÉ£aËÉ¦É™ ËˆmeËËŒneËmÉ™(n)/",
          "note": "æŒã¡è¾¼ã¿åˆ¶é™ã‚’ç¢ºèª"
        },
        {
          "id": "airport-immigration",
          "category": "å…¥å›½å¯©æŸ»",
          "scenario": ["ç©ºæ¸¯"],
          "level": ["A2"],
          "tags": ["å…¥å›½å¯©æŸ»", "ç›®çš„"],
          "ja": "è¦³å…‰ã§æ¥ã¾ã—ãŸã€‚",
          "nl": "Ik ben hier voor toerisme.",
          "hint": "ã‚¤ã‚¯ ãƒ™ãƒ³ ãƒ’ãƒ¼ãƒ« ãƒ•ã‚©ãƒ¼ãƒ« ãƒˆã‚¥ãƒ¼ãƒªã‚¹ãƒ  /Éªk bÉ›n É¦iËr foËr tuËËˆrÉª.smÉ™/",
          "note": "å…¥å›½ç›®çš„ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "airport-transfer",
          "category": "ä¹—ã‚Šç¶™ã",
          "scenario": ["ç©ºæ¸¯", "äº¤é€š"],
          "level": ["A2"],
          "tags": ["ä¹—ã‚Šç¶™ã", "æ™‚é–“"],
          "ja": "æ¬¡ã®ã‚²ãƒ¼ãƒˆã¾ã§ã¯ã©ã‚Œãã‚‰ã„æ™‚é–“ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Hoeveel tijd is er tot de volgende gate?",
          "hint": "ãƒ•ãƒ¼ãƒ•ã‚§ãƒ¼ãƒ« ã‚¿ã‚¤ãƒˆ ã‚¤ã‚¹ ã‚¨ãƒ« ãƒˆãƒƒãƒˆ ãƒ‡ ãƒ•ã‚©ãƒ«ãƒ˜ãƒ³ãƒ€ ã‚²ãƒ¼ãƒˆ /ËˆÉ¦uË.veËl tÉ›iÌ¯t Éªs É›r tÉ”t dÉ™ ËˆvÉ”l.É£É™ndÉ™ É£eËt/",
          "note": "ä¹—ã‚Šç¶™ãæ™‚é–“ã‚’ç¢ºèª"
        },
        {
          "id": "travel-station",
          "category": "é‰„é“",
          "scenario": ["äº¤é€š"],
          "level": ["A1"],
          "tags": ["é“æ¡ˆå†…", "é‰„é“"],
          "ja": "é§…ã¯ã©ã“ã§ã™ã‹ï¼Ÿ",
          "nl": "Waar is het station?",
          "hint": "ãƒ¯ãƒ¼ãƒ« ã‚¤ã‚¹ ãƒ˜ãƒƒãƒˆ ã‚¹ã‚¿ã‚·ã‚ªãƒ³ /Ê‹aËr Éªs É¦É™t stÉ‘ËˆÊƒÉ”n/",
          "note": "é§…ã®å ´æ‰€ã‚’å°‹ã­ã‚‹",
          "featured": true
        },
        {
          "id": "travel-train",
          "category": "é‰„é“",
          "scenario": ["äº¤é€š"],
          "level": ["A2"],
          "tags": ["åˆ—è»Š", "è¡Œãå…ˆ"],
          "ja": "ã“ã®åˆ—è»Šã¯ã‚¢ãƒ ã‚¹ãƒ†ãƒ«ãƒ€ãƒ è¡Œãã§ã™ã‹ï¼Ÿ",
          "nl": "Gaat deze trein naar Amsterdam?",
          "hint": "ãƒãƒ¼ãƒˆ ãƒ‡ãƒ¼ã‚¼ ãƒˆãƒ©ã‚¤ãƒ³ ãƒŠãƒ¼ãƒ« ã‚¢ãƒ ã‚¹ãƒ†ãƒ«ãƒ€ãƒ  /É£aËt ËˆdeËzÉ™ trÉ›iÌ¯n naËr ËŒÉ‘mstÉ™rËˆdÉ‘m/",
          "note": "åˆ—è»Šã®è¡Œãå…ˆã‚’ç¢ºèª"
        },
        {
          "id": "travel-ticket",
          "category": "é‰„é“",
          "scenario": ["äº¤é€š"],
          "level": ["A1"],
          "tags": ["åˆ‡ç¬¦", "è³¼å…¥"],
          "ja": "åˆ‡ç¬¦ã‚’2æšãã ã•ã„ã€‚",
          "nl": "Mag ik twee kaartjes alstublieft?",
          "hint": "ãƒãƒƒ ãƒ•ã‚£ãƒƒã‚¯ ãƒˆã‚¥ã‚¦ã‚§ãƒ¼ ã‚«ãƒ¼ãƒ«ãƒã‚§ã‚¹ ã‚¢ãƒ«ã‚¹ãƒˆãƒ¥ãƒ–ãƒªãƒ¼ãƒ•ãƒˆ /mÉ‘x Éªk tveË ËˆkaËr.cÉ™s ËŒÉ‘lstÊËˆblift/",
          "note": "åˆ‡ç¬¦ã‚’è³¼å…¥"
        },
        {
          "id": "transport-daypass",
          "category": "é‰„é“",
          "scenario": ["äº¤é€š"],
          "level": ["A2"],
          "tags": ["åˆ‡ç¬¦", "ãŠå¾—"],
          "ja": "1æ—¥ä¹—ã‚Šæ”¾é¡Œåˆ¸ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Heeft u een dagkaart?",
          "hint": "ãƒ˜ãƒ¼ãƒ•ãƒˆã‚¥ãƒ¼ ã‚¦ãƒ³ ãƒ€ãƒ•ã‚«ãƒ¼ãƒ«ãƒˆ /É¦eËft y Ên ËˆdÉ‘x.kaËrt/",
          "note": "1æ—¥åˆ¸ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "transport-bus",
          "category": "ãƒã‚¹",
          "scenario": ["äº¤é€š"],
          "level": ["A1"],
          "tags": ["ãƒã‚¹", "æ™‚åˆ»"],
          "ja": "ç©ºæ¸¯è¡Œãã®ãƒã‚¹ã¯ä½•ç•ªä¹—ã‚Šå ´ã§ã™ã‹ï¼Ÿ",
          "nl": "Vanaf welke halte vertrekt de bus naar het vliegveld?",
          "hint": "ãƒ•ã‚¡ãƒŠãƒ• ãƒ•ã‚§ãƒ«ã‚± ãƒãƒ«ãƒ† ãƒ•ã‚§ãƒ«ãƒˆãƒ¬ã‚¯ãƒˆ ãƒ‡ ãƒã‚¹ ãƒŠãƒ¼ãƒ« ãƒ˜ãƒƒãƒˆ ãƒ•ãƒªãƒ¼ãƒ•ãƒ•ã‚§ãƒ«ãƒˆ /fÉ‘ËˆnÉ‘f ËˆÊ‹É›l.kÉ™ ËˆÉ¦É‘l.tÉ™ vÉ™rËˆtrÉ›kt dÉ™ bÊs naËr É¦É™t ËˆvliËx.fÉ›lt/",
          "note": "ãƒã‚¹ä¹—ã‚Šå ´ã‚’ç¢ºèª"
        },
        {
          "id": "transport-taxi",
          "category": "ã‚¿ã‚¯ã‚·ãƒ¼",
          "scenario": ["äº¤é€š"],
          "level": ["A1", "A2"],
          "tags": ["ã‚¿ã‚¯ã‚·ãƒ¼", "æ–™é‡‘"],
          "ja": "ä¸­å¤®é§…ã¾ã§ã„ãã‚‰ã‹ã‹ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Hoeveel kost het naar het centraal station?",
          "hint": "ãƒ•ãƒ¼ãƒ•ã‚§ãƒ¼ãƒ« ã‚³ã‚¹ãƒˆã‚¥ ãƒ˜ãƒƒãƒˆ ãƒŠãƒ¼ãƒ« ãƒ˜ãƒƒãƒˆ ã‚»ãƒ³ãƒˆãƒ©ãƒ¼ãƒ« ã‚¹ã‚¿ã‚·ã‚ªãƒ³ /ËˆÉ¦uË.veËl kÉ”st É¦É™t naËr É¦É™t sÉ›nËˆtraËl stÉ‘ËˆÊƒÉ”n/",
          "note": "ã‚¿ã‚¯ã‚·ãƒ¼æ–™é‡‘ã‚’ç¢ºèª"
        },
        {
          "id": "transport-bike",
          "category": "ãƒ¬ãƒ³ã‚¿ãƒ«",
          "scenario": ["äº¤é€š", "è¦³å…‰"],
          "level": ["A2"],
          "tags": ["ãƒ¬ãƒ³ã‚¿ã‚µã‚¤ã‚¯ãƒ«", "äºˆç´„"],
          "ja": "è‡ªè»¢è»Šã‚’1é€±é–“ãƒ¬ãƒ³ã‚¿ãƒ«ã§ãã¾ã™ã‹ï¼Ÿ",
          "nl": "Kan ik een fiets voor een week huren?",
          "hint": "ã‚«ãƒ³ ã‚¤ã‚¯ ã‚¨ãƒ¼ãƒ³ ãƒ•ã‚£ãƒ¼ãƒ„ ãƒ•ã‚©ãƒ¼ãƒ« ã‚¨ãƒ¼ãƒ³ ãƒ´ã‚§ãƒ¼ã‚¯ ãƒ’ãƒ¥ãƒ¼ãƒ¬ãƒ³ /kÉ‘n Éªk eËn fits foËr eËn Ê‹eËk ËˆhyË.rÉ™(n)/",
          "note": "è‡ªè»¢è»Šãƒ¬ãƒ³ã‚¿ãƒ«ã‚’ä¾é ¼"
        },
        {
          "id": "lodging-checkin",
          "category": "ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³",
          "scenario": ["å®¿æ³Š"],
          "level": ["A1"],
          "tags": ["ãƒ›ãƒ†ãƒ«", "åˆ°ç€"],
          "ja": "äºˆç´„ã—ã¦ã„ã‚‹ç”°ä¸­ã§ã™ã€‚",
          "nl": "Ik heb gereserveerd op de naam Tanaka.",
          "hint": "ã‚¤ã‚¯ ãƒ˜ãƒƒãƒ— ãƒ˜ãƒ¬ã‚¼ãƒ«ãƒ•ã‚§ãƒ¼ãƒ«ãƒˆ ã‚ªãƒ— ãƒ‡ ãƒŠãƒ¼ãƒ  ã‚¿ãƒŠã‚« /Éªk É¦É›b É£É™ËŒreË.zÉ™rËˆveËrt É”p dÉ™ naËm tÉ‘ËˆnaËka/",
          "note": "äºˆç´„ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "lodging-latecheckout",
          "category": "æ»åœ¨ä¸­",
          "scenario": ["å®¿æ³Š"],
          "level": ["A2"],
          "tags": ["ãƒ›ãƒ†ãƒ«", "æ™‚é–“"],
          "ja": "ãƒ¬ã‚¤ãƒˆãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã¯å¯èƒ½ã§ã™ã‹ï¼Ÿ",
          "nl": "Is een late check-out mogelijk?",
          "hint": "ã‚¤ã‚¹ ã‚¨ãƒ¼ãƒ³ ãƒ©ãƒ¼ãƒ† ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ ãƒ¢ãƒ¼ãƒ•ã‚§ãƒªã‚¯ /Éªs eËn ËˆlaË.tÉ™ tÊƒÉ›kËˆÉ‘ÊŠt ËˆmoËxÉ™.lÉ™k/",
          "note": "ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆæ™‚é–“ã‚’ç¢ºèª"
        },
        {
          "id": "lodging-breakfast",
          "category": "æ»åœ¨ä¸­",
          "scenario": ["å®¿æ³Š", "é£Ÿäº‹"],
          "level": ["A1"],
          "tags": ["æœé£Ÿ", "å–¶æ¥­æ™‚é–“"],
          "ja": "æœé£Ÿã¯ä½•æ™‚ã‹ã‚‰ã§ã™ã‹ï¼Ÿ",
          "nl": "Hoe laat is het ontbijt?",
          "hint": "ãƒ•ãƒ¼ ãƒ©ãƒ¼ãƒˆ ã‚¤ã‚¹ ãƒ˜ãƒƒãƒˆ ã‚ªãƒ³ãƒˆãƒã‚¤ã‚¹ãƒˆ /ËˆÉ¦uË laËt Éªs É¦É™t É”ntËˆbÉ‘iÌ¯t/",
          "note": "æœé£Ÿã®æ™‚é–“ã‚’ç¢ºèª"
        },
        {
          "id": "lodging-laundry",
          "category": "æ»åœ¨ä¸­",
          "scenario": ["å®¿æ³Š", "æ—¥å¸¸ä¼šè©±"],
          "level": ["A2"],
          "tags": ["ãƒ©ãƒ³ãƒ‰ãƒªãƒ¼", "ã‚µãƒ¼ãƒ“ã‚¹"],
          "ja": "ãƒ©ãƒ³ãƒ‰ãƒªãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Heeft u een wasservice?",
          "hint": "ãƒ˜ãƒ¼ãƒ•ãƒˆã‚¥ãƒ¼ ã‚¦ãƒ³ ãƒ´ã‚¡ãƒƒã‚»ãƒ¼ãƒ«ãƒ´ã‚£ã‚¹ /É¦eËft y Ên ËˆÊ‹É‘s.sÉ›r.Ê‹É™s/",
          "note": "æ´—æ¿¯ã‚µãƒ¼ãƒ“ã‚¹ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "lodging-wifi",
          "category": "æ»åœ¨ä¸­",
          "scenario": ["å®¿æ³Š", "æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["Wi-Fi", "æ¥ç¶š"],
          "ja": "Wi-Fiã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚",
          "nl": "Kunt u het Wi-Fi wachtwoord geven?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ãƒ˜ãƒƒãƒˆ ãƒ¯ã‚¤ãƒ•ã‚¡ã‚¤ ãƒ¯ãƒ•ãƒˆãƒ´ã‚©ãƒ¼ãƒ«ãƒ‰ ãƒ˜ãƒ¼ãƒ•ã‚§ãƒ³ /kÊnt y É¦É™t ËˆÊ‹iË.faÉªÌ¯ ËˆÊ‹É‘xt.Ê‹oËrt ËˆÉ£eËvÉ™(n)/",
          "note": "Wi-Fiãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "lodging-maintenance",
          "category": "æ»åœ¨ä¸­",
          "scenario": ["å®¿æ³Š"],
          "level": ["A2", "B1"],
          "tags": ["è¨­å‚™", "ãƒˆãƒ©ãƒ–ãƒ«"],
          "ja": "ã‚·ãƒ£ãƒ¯ãƒ¼ã®ãŠæ¹¯ãŒå‡ºã¾ã›ã‚“ã€‚",
          "nl": "Er komt geen warm water uit de douche.",
          "hint": "ã‚¨ãƒ« ã‚³ãƒ ãƒˆ ãƒ˜ãƒ¼ãƒ³ ãƒ¯ãƒ«ãƒ  ãƒ¯ãƒ¼ãƒ†ãƒ« ã‚¢ã‚¦ãƒˆ ãƒ‡ ãƒ‰ã‚¦ã‚·ã‚§ /É›r kÉ”mt É£eËn Ê‹É‘rm ËˆÊ‹aËtÉ™r Å“yÌ¯t dÉ™ ËˆduÊƒÉ™/",
          "note": "è¨­å‚™ã®ä¸å…·åˆã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "dining-reservation",
          "category": "äºˆç´„",
          "scenario": ["é£Ÿäº‹"],
          "level": ["A2"],
          "tags": ["ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³", "äºˆç´„"],
          "ja": "2åã§19æ™‚ã«äºˆç´„ã§ãã¾ã™ã‹ï¼Ÿ",
          "nl": "Kan ik voor twee personen om zeven uur reserveren?",
          "hint": "ã‚«ãƒ³ ã‚¤ã‚¯ ãƒ•ã‚©ãƒ¼ãƒ« ãƒˆã‚¥ã‚¦ã‚§ãƒ¼ ãƒšãƒ«ã‚½ãƒ¼ãƒãƒ³ ã‚ªãƒ  ã‚¼ãƒ¼ãƒ•ã‚§ãƒ³ ã‚¦ãƒ¼ãƒ« ãƒ¬ã‚¼ãƒ«ãƒ•ã‚§ãƒ¼ãƒ¬ãƒ³ /kÉ‘n Éªk foËr tveË pÉ›rËˆsoËnÉ™(n) É”m ËˆzeË.vÉ™(n) uËr rÉ›zÉ™rËˆveËrÉ™(n)/",
          "note": "ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³äºˆç´„ã‚’ã™ã‚‹"
        },
        {
          "id": "dining-seat",
          "category": "å…¥åº—",
          "scenario": ["é£Ÿäº‹"],
          "level": ["A1"],
          "tags": ["å¸­", "å…¥åº—"],
          "ja": "ãƒ†ãƒ©ã‚¹å¸­ã¯ç©ºã„ã¦ã„ã¾ã™ã‹ï¼Ÿ",
          "nl": "Is er een plek op het terras vrij?",
          "hint": "ã‚¤ã‚¹ ã‚¨ãƒ« ã‚¨ãƒ¼ãƒ³ ãƒ—ãƒ¬ãƒƒã‚¯ ã‚ªãƒ— ãƒ˜ãƒƒãƒˆ ãƒ†ãƒ©ã‚¹ ãƒ•ãƒ©ã‚¤ /Éªs É›r eËn plÉ›k É”p É¦É™t tÉ™ËˆrÉ‘s vrÉ›iÌ¯/",
          "note": "å¸­ã®ç©ºãã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "dining-allergy",
          "category": "æ³¨æ–‡",
          "scenario": ["é£Ÿäº‹", "ç·Šæ€¥"],
          "level": ["A2"],
          "tags": ["ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼", "å¥åº·"],
          "ja": "ãƒŠãƒƒãƒ„ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚",
          "nl": "Ik heb een notenallergie.",
          "hint": "ã‚¤ã‚¯ ãƒ˜ãƒƒãƒ— ã‚¨ãƒ¼ãƒ³ ãƒãƒ¼ãƒ†ãƒ³ã‚¢ãƒ¬ãƒ«ãƒ’ãƒ¼ /Éªk É¦É›b eËn ËˆnoË.tÉ™(n).aËŒlÉ›rËˆÉ£i/",
          "note": "ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "dining-vegetarian",
          "category": "æ³¨æ–‡",
          "scenario": ["é£Ÿäº‹"],
          "level": ["A2"],
          "tags": ["ãƒ™ã‚¸ã‚¿ãƒªã‚¢ãƒ³", "é£Ÿäº‹åˆ¶é™"],
          "ja": "ãƒ™ã‚¸ã‚¿ãƒªã‚¢ãƒ³å‘ã‘ã®æ–™ç†ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Heeft u vegetarische gerechten?",
          "hint": "ãƒ˜ãƒ¼ãƒ•ãƒˆã‚¥ãƒ¼ ãƒ•ã‚§ãƒ˜ã‚¿ãƒªãƒƒã‚» ãƒ˜ãƒ¬ãƒ•ãƒ†ãƒ³ /É¦eËft y veË.xeËËˆtaË.rÉª.sÉ™ É£É™ËˆrÉ›x.tÉ™(n)/",
          "note": "é£Ÿäº‹åˆ¶é™ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "dining-recommend",
          "category": "æ³¨æ–‡",
          "scenario": ["é£Ÿäº‹", "è¦³å…‰"],
          "level": ["A1"],
          "tags": ["ãŠã™ã™ã‚", "åº—å“¡ä¼šè©±"],
          "ja": "ãŠã™ã™ã‚ã®æ–™ç†ã¯ä½•ã§ã™ã‹ï¼Ÿ",
          "nl": "Wat raadt u aan?",
          "hint": "ãƒ¯ãƒƒãƒˆ ãƒ©ãƒ¼ãƒˆã‚¥ãƒ¼ ã‚¢ãƒ¼ãƒ³ /Ê‹É‘t raËt y aËn/",
          "note": "ãŠã™ã™ã‚ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "dining-bill",
          "category": "ä¼šè¨ˆ",
          "scenario": ["é£Ÿäº‹"],
          "level": ["A1"],
          "tags": ["ä¼šè¨ˆ", "ä¸å¯§"],
          "ja": "ãŠä¼šè¨ˆã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚",
          "nl": "Mag ik de rekening, alstublieft?",
          "hint": "ãƒãƒƒ ã‚¤ã‚¯ ãƒ‡ ãƒ¬ãƒ¼ã‚±ãƒ‹ãƒ³ã‚° ã‚¢ãƒ«ã‚¹ãƒˆãƒ¥ãƒ–ãƒªãƒ¼ãƒ•ãƒˆ /mÉ‘x Éªk dÉ™ ËˆreË.kÉ™.nÉªÅ‹ ËŒÉ‘lstÊËˆblift/",
          "note": "ä¼šè¨ˆã‚’ä¾é ¼"
        },
        {
          "id": "dining-split",
          "category": "ä¼šè¨ˆ",
          "scenario": ["é£Ÿäº‹", "æ—¥å¸¸ä¼šè©±"],
          "level": ["A2"],
          "tags": ["ä¼šè¨ˆ", "å‰²ã‚Šå‹˜"],
          "ja": "æ”¯æ‰•ã„ã‚’åˆ¥ã€…ã«ã—ã¦ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunnen we apart betalen?",
          "hint": "ã‚¯ãƒŒãƒ³ ãƒ´ã‚§ ã‚¢ãƒ‘ãƒ«ãƒˆ ãƒ™ã‚¿ãƒ¼ãƒ¬ãƒ³ /ËˆkÊ.nÉ™(n) Ê‹É™ É‘ËˆpÉ‘rt bÉ™ËˆtaË.lÉ™(n)/",
          "note": "å‰²ã‚Šå‹˜ã‚’ãŠé¡˜ã„ã™ã‚‹"
        },
        {
          "id": "dining-water",
          "category": "æ³¨æ–‡",
          "scenario": ["é£Ÿäº‹"],
          "level": ["A1"],
          "tags": ["é£²ã¿ç‰©"],
          "ja": "æ°´ã‚’ä¸€ç·’ã«ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ",
          "nl": "Mag ik er wat water bij?",
          "hint": "ãƒãƒƒ ã‚¤ã‚¯ ã‚¨ãƒ« ãƒ¯ãƒƒãƒˆ ãƒ¯ãƒ¼ãƒ†ãƒ« ãƒ™ã‚¤ /mÉ‘x Éªk É›r Ê‹É‘t ËˆÊ‹aË.tÉ™r bÉ›iÌ¯/",
          "note": "æ°´ã‚’é ¼ã‚€"
        },
        {
          "id": "sightseeing-hours",
          "category": "è¦³å…‰æ¡ˆå†…",
          "scenario": ["è¦³å…‰"],
          "level": ["A1"],
          "tags": ["å–¶æ¥­æ™‚é–“", "è¦³å…‰æ¡ˆå†…"],
          "ja": "ç¾è¡“é¤¨ã¯ä½•æ™‚ã¾ã§é–‹ã„ã¦ã„ã¾ã™ã‹ï¼Ÿ",
          "nl": "Tot hoe laat is het museum open?",
          "hint": "ãƒˆãƒƒãƒˆ ãƒ•ãƒ¼ ãƒ©ãƒ¼ãƒˆ ã‚¤ã‚¹ ãƒ˜ãƒƒãƒˆ ãƒŸãƒ¥ã‚¼ã‚¦ãƒ  ã‚ªãƒ¼ãƒšãƒ³ /tÉ”t ËˆÉ¦uË laËt Éªs É¦É™t myËËˆzeË.Êm ËˆoË.pÉ™(n)/",
          "note": "å–¶æ¥­æ™‚é–“ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "sightseeing-ticket",
          "category": "è¦³å…‰æ¡ˆå†…",
          "scenario": ["è¦³å…‰"],
          "level": ["A1"],
          "tags": ["ãƒã‚±ãƒƒãƒˆ", "è¦³å…‰æ¡ˆå†…"],
          "ja": "ã‚¬ã‚¤ãƒ‰ãƒ„ã‚¢ãƒ¼ã®ãƒã‚±ãƒƒãƒˆã¯ã©ã“ã§è²·ãˆã¾ã™ã‹ï¼Ÿ",
          "nl": "Waar kan ik tickets voor de rondleiding kopen?",
          "hint": "ãƒ¯ãƒ¼ãƒ« ã‚«ãƒ³ ã‚¤ã‚¯ ãƒã‚±ãƒƒãƒ„ ãƒ•ã‚©ãƒ¼ãƒ« ãƒ‡ ãƒ­ãƒ³ãƒˆãƒ¬ã‚¤ãƒ‡ã‚£ãƒ³ã‚° ã‚³ãƒ¼ãƒšãƒ³ /Ê‹aËr kÉ‘n Éªk ËˆtÉª.kÉ™ts foËr dÉ™ ËˆrÉ”ntËŒlÉ›iÌ¯.dÉªÅ‹ ËˆkoË.pÉ™(n)/",
          "note": "ãƒã‚±ãƒƒãƒˆè³¼å…¥å ´æ‰€ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "sightseeing-guide",
          "category": "è¦³å…‰æ¡ˆå†…",
          "scenario": ["è¦³å…‰"],
          "level": ["A2"],
          "tags": ["ã‚¬ã‚¤ãƒ‰", "äºˆç´„"],
          "ja": "æ—¥æœ¬èªã‚¬ã‚¤ãƒ‰ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Is er een rondleiding in het Japans?",
          "hint": "ã‚¤ã‚¹ ã‚¨ãƒ« ã‚¨ãƒ¼ãƒ³ ãƒ­ãƒ³ãƒˆãƒ¬ã‚¤ãƒ‡ã‚£ãƒ³ã‚° ã‚¤ãƒ³ ãƒ˜ãƒƒãƒˆ ãƒ¤ãƒ‘ãƒ³ã‚¹ /Éªs É›r eËn ËˆrÉ”ntËŒlÉ›iÌ¯.dÉªÅ‹ Éªn É¦É™t jaËËˆpÉ‘ns/",
          "note": "æ—¥æœ¬èªã‚¬ã‚¤ãƒ‰ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "sightseeing-direction",
          "category": "é“æ¡ˆå†…",
          "scenario": ["è¦³å…‰", "äº¤é€š"],
          "level": ["A1"],
          "tags": ["é“æ¡ˆå†…"],
          "ja": "ã“ã®åœ°å›³ã§ç¾åœ¨åœ°ã‚’æ•™ãˆã¦ã‚‚ã‚‰ãˆã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunt u op deze kaart laten zien waar we zijn?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ã‚ªãƒ— ãƒ‡ãƒ¼ã‚¼ ã‚«ãƒ¼ãƒ«ãƒˆ ãƒ©ãƒ¼ãƒ†ãƒ³ ã‚¼ãƒ¼ãƒ³ ãƒ¯ãƒ¼ãƒ« ãƒ´ã‚§ ã‚¶ã‚¤ãƒ³ /kÊnt y É”p ËˆdeË.zÉ™ kaËrt ËˆlaË.tÉ™(n) zeËn Ê‹aËr Ê‹É™ zÉ›iÌ¯n/",
          "note": "åœ°å›³ã§é“æ¡ˆå†…ã‚’ãŠé¡˜ã„"
        },
        {
          "id": "sightseeing-photo",
          "category": "äº¤æµ",
          "scenario": ["è¦³å…‰", "æ—¥å¸¸ä¼šè©±"],
          "level": ["A1"],
          "tags": ["å†™çœŸ", "ä¸å¯§"],
          "ja": "å†™çœŸã‚’æ’®ã£ã¦ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunt u een foto van ons nemen?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ã‚¨ãƒ¼ãƒ³ ãƒ•ã‚©ãƒˆ ãƒ•ã‚¡ãƒ³ ã‚ªãƒ³ã‚¹ ãƒãƒ¼ãƒ¡ãƒ³ /kÊnt y eËn ËˆfoË.toË fÉ‘n É”ns ËˆneËmÉ™(n)/",
          "note": "å†™çœŸæ’®å½±ã‚’ãŠé¡˜ã„"
        },
        {
          "id": "shopping-price",
          "category": "è³¼å…¥",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°"],
          "level": ["A1"],
          "tags": ["ä¾¡æ ¼", "è²·ã„ç‰©"],
          "ja": "ã“ã‚Œã¯ã„ãã‚‰ã§ã™ã‹ï¼Ÿ",
          "nl": "Hoeveel kost dit?",
          "hint": "ãƒ•ãƒ¼ãƒ•ã‚§ãƒ¼ãƒ« ã‚³ã‚¹ãƒˆã‚¥ ãƒ‡ã‚£ãƒƒãƒˆ /ËˆÉ¦uË.veËl kÉ”st dÉªt/",
          "note": "å€¤æ®µã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "shopping-size",
          "category": "è³¼å…¥",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°"],
          "level": ["A1"],
          "tags": ["ã‚µã‚¤ã‚º", "è¡£é¡"],
          "ja": "åˆ¥ã®ã‚µã‚¤ã‚ºã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Heeft u een andere maat?",
          "hint": "ãƒ˜ãƒ¼ãƒ•ãƒˆã‚¥ãƒ¼ ã‚¦ãƒ³ ã‚¢ãƒ³ãƒ‡ãƒ¬ ãƒãƒ¼ãƒˆ /É¦eËft y Ên ËˆÉ‘n.dÉ™.rÉ™ maËt/",
          "note": "ã‚µã‚¤ã‚ºé•ã„ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "shopping-tryon",
          "category": "è³¼å…¥",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°"],
          "level": ["A1", "A2"],
          "tags": ["è©¦ç€", "è¡£é¡"],
          "ja": "è©¦ç€ã—ã¦ã‚‚ã„ã„ã§ã™ã‹ï¼Ÿ",
          "nl": "Mag ik het passen?",
          "hint": "ãƒãƒƒ ã‚¤ã‚¯ ãƒ˜ãƒƒãƒˆ ãƒ‘ãƒƒã‚»ãƒ³ /mÉ‘x Éªk É¦É™t ËˆpÉ‘.sÉ™(n)/",
          "note": "è©¦ç€ã®è¨±å¯ã‚’æ±‚ã‚ã‚‹"
        },
        {
          "id": "shopping-taxfree",
          "category": "æ”¯æ‰•ã„",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°", "ç©ºæ¸¯"],
          "level": ["A2"],
          "tags": ["å…ç¨", "æ›¸é¡"],
          "ja": "å…ç¨æ‰‹ç¶šãã¯ã§ãã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunt u taxfree regelen?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ã‚¿ãƒƒã‚¯ã‚¹ãƒ•ãƒªãƒ¼ ãƒ¬ãƒ¼ãƒ˜ãƒ¬ãƒ³ /kÊnt y ËˆtÉ‘ks.friË ËˆreË.É£É™.lÉ™(n)/",
          "note": "å…ç¨æ‰‹ç¶šãã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "shopping-card",
          "category": "æ”¯æ‰•ã„",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°"],
          "level": ["A1"],
          "tags": ["æ”¯æ‰•ã„", "ã‚«ãƒ¼ãƒ‰"],
          "ja": "ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆã¾ã™ã‹ï¼Ÿ",
          "nl": "Kan ik met creditcard betalen?",
          "hint": "ã‚«ãƒ³ ã‚¤ã‚¯ ãƒ¡ãƒƒãƒˆ ã‚¯ãƒ¬ãƒ‡ã‚£ãƒƒãƒˆã‚«ãƒ¼ãƒ‰ ãƒ™ã‚¿ãƒ¼ãƒ¬ãƒ³ /kÉ‘n Éªk mÉ›t ËˆkrÉ›.dÉªtËŒkaËrt bÉ™ËˆtaË.lÉ™(n)/",
          "note": "ã‚«ãƒ¼ãƒ‰åˆ©ç”¨ã‚’ç¢ºèª"
        },
        {
          "id": "shopping-delivery",
          "category": "æ”¯æ‰•ã„",
          "scenario": ["ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°", "å®¿æ³Š"],
          "level": ["A2"],
          "tags": ["é…é€", "ãƒ›ãƒ†ãƒ«"],
          "ja": "ãƒ›ãƒ†ãƒ«ã¾ã§é…é€ã—ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹ï¼Ÿ",
          "nl": "Kunt u het naar mijn hotel bezorgen?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ãƒ˜ãƒƒãƒˆ ãƒŠãƒ¼ãƒ« ãƒ¡ã‚¤ãƒ³ ãƒ›ãƒ†ãƒ« ãƒ™ã‚¾ãƒ«ãƒ˜ãƒ³ /kÊnt y É¦É™t naËr mÉ›iÌ¯n hoËËˆtÉ›l bÉ™ËˆzÉ”r.É£É™(n)/",
          "note": "ãƒ›ãƒ†ãƒ«é…é€ã‚’ä¾é ¼"
        },
        {
          "id": "emergency-help",
          "category": "æ•‘åŠ©",
          "scenario": ["ç·Šæ€¥"],
          "level": ["A1"],
          "tags": ["åŠ©ã‘", "ç·Šæ€¥"],
          "ja": "åŠ©ã‘ãŒå¿…è¦ã§ã™ã€‚",
          "nl": "Ik heb hulp nodig.",
          "hint": "ã‚¤ã‚¯ ãƒ˜ãƒƒãƒ— ãƒ•ãƒ«ãƒ— ãƒãƒ¼ãƒ‡ã‚£ãƒ• /Éªk É¦É›b É¦Êlp ËˆnoËdÉªx/",
          "note": "ç·Šæ€¥æ™‚ã®åŠ©ã‘ã‚’æ±‚ã‚ã‚‹",
          "featured": true
        },
        {
          "id": "emergency-hospital",
          "category": "åŒ»ç™‚",
          "scenario": ["ç·Šæ€¥", "å¥åº·"],
          "level": ["A2"],
          "tags": ["åŒ»è€…", "æ€ªæˆ‘"],
          "ja": "ç—…é™¢ã¸é€£ã‚Œã¦è¡Œã£ã¦ãã ã•ã„ã€‚",
          "nl": "Kunt u me naar een ziekenhuis brengen?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ãƒ  ãƒŠãƒ¼ãƒ« ã‚¨ãƒ¼ãƒ³ ã‚ºã‚¤ã‚±ãƒ³ãƒã‚¦ã‚¹ ãƒ–ãƒ¬ãƒ³ãƒ˜ãƒ³ /kÊnt y mÉ™ naËr eËn ËˆzÉ›iÌ¯.kÉ™(n).É¦Å“ys ËˆbrÉ›Å‹É™(n)/",
          "note": "ç—…é™¢ã¸æ¡ˆå†…ã‚’ä¾é ¼"
        },
        {
          "id": "emergency-pharmacy",
          "category": "åŒ»ç™‚",
          "scenario": ["ç·Šæ€¥", "å¥åº·"],
          "level": ["A1"],
          "tags": ["è–¬å±€", "å¥åº·"],
          "ja": "è¿‘ãã«è–¬å±€ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
          "nl": "Is er een apotheek in de buurt?",
          "hint": "ã‚¤ã‚¹ ã‚¨ãƒ« ã‚¨ãƒ¼ãƒ³ ã‚¢ãƒãƒ†ãƒ¼ã‚¯ ã‚¤ãƒ³ ãƒ‡ ãƒ–ãƒ¥ãƒ¼ãƒ«ãƒˆ /Éªs É›r eËn ËŒÉ‘.poËËˆteËk Éªn dÉ™ byËrt/",
          "note": "è–¬å±€ã®å ´æ‰€ã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "emergency-police",
          "category": "ãƒˆãƒ©ãƒ–ãƒ«",
          "scenario": ["ç·Šæ€¥"],
          "level": ["A2"],
          "tags": ["è­¦å¯Ÿ", "é€šå ±"],
          "ja": "è­¦å¯Ÿã‚’å‘¼ã‚“ã§ãã ã•ã„ã€‚",
          "nl": "Bel alstublieft de politie.",
          "hint": "ãƒ™ãƒ« ã‚¢ãƒ«ã‚¹ãƒˆãƒ¥ãƒ–ãƒªãƒ¼ãƒ•ãƒˆ ãƒ‡ ãƒãƒªãƒ„ã‚£ãƒ¼ /bÉ›l ËŒÉ‘lstÊËˆblift dÉ™ poËËˆliË.tsÉ™/",
          "note": "è­¦å¯Ÿã‚’å‘¼ã¶"
        },
        {
          "id": "emergency-lostpassport",
          "category": "ãƒˆãƒ©ãƒ–ãƒ«",
          "scenario": ["ç·Šæ€¥", "ç©ºæ¸¯"],
          "level": ["B1"],
          "tags": ["ç´›å¤±", "ãƒ‘ã‚¹ãƒãƒ¼ãƒˆ"],
          "ja": "ãƒ‘ã‚¹ãƒãƒ¼ãƒˆã‚’å¤±ãã—ã¾ã—ãŸã€‚",
          "nl": "Ik ben mijn paspoort kwijt.",
          "hint": "ã‚¤ã‚¯ ãƒ™ãƒ³ ãƒ¡ã‚¤ãƒ³ ãƒ‘ã‚¹ãƒãƒ¼ãƒ«ãƒˆ ã‚¯ãƒ¯ã‚¤ãƒˆ /Éªk bÉ›n mÉ›iÌ¯n ËˆpÉ‘s.poËrt kÊ‹É›iÌ¯t/",
          "note": "ãƒ‘ã‚¹ãƒãƒ¼ãƒˆç´›å¤±ã‚’ä¼ãˆã‚‹"
        },
        {
          "id": "emergency-contact",
          "category": "é€£çµ¡",
          "scenario": ["ç·Šæ€¥", "æ—¥å¸¸ä¼šè©±"],
          "level": ["A2"],
          "tags": ["é€£çµ¡", "ç·Šæ€¥"],
          "ja": "å¤§ä½¿é¤¨ã®é€£çµ¡å…ˆã‚’æ•™ãˆã¦ãã ã•ã„ã€‚",
          "nl": "Kunt u mij het nummer van de ambassade geven?",
          "hint": "ã‚¯ãƒ³ãƒˆã‚¥ãƒ¼ ãƒ¡ã‚¤ ãƒ˜ãƒƒãƒˆ ãƒŒãƒ³ãƒãƒ¼ ãƒ•ã‚¡ãƒ³ ãƒ‡ ã‚¢ãƒ³ãƒãƒƒã‚µãƒ¼ãƒ‡ ãƒ˜ãƒ¼ãƒ•ã‚§ãƒ³ /kÊnt y mÉ›iÌ¯ É¦É™t ËˆnÊ.mÉ™r fÉ‘n dÉ™ É‘m.bÉ‘ËˆsaË.dÉ™ ËˆÉ£eË.vÉ™(n)/",
          "note": "å¤§ä½¿é¤¨ã®é€£çµ¡å…ˆã‚’å°‹ã­ã‚‹"
        },
        {
          "id": "communication-sim",
          "category": "é€šä¿¡",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°"],
          "level": ["A2"],
          "tags": ["SIMã‚«ãƒ¼ãƒ‰", "é€šä¿¡"],
          "ja": "ãƒ—ãƒªãƒšã‚¤ãƒ‰SIMã‚«ãƒ¼ãƒ‰ã¯ã©ã“ã§è²·ãˆã¾ã™ã‹ï¼Ÿ",
          "nl": "Waar kan ik een prepaid simkaart kopen?",
          "hint": "ãƒ¯ãƒ¼ãƒ« ã‚«ãƒ³ ã‚¤ã‚¯ ã‚¨ãƒ¼ãƒ³ ãƒ—ãƒªãƒšã‚¤ãƒ‰ ã‚·ãƒ ã‚«ãƒ¼ãƒ«ãƒˆ ã‚³ãƒ¼ãƒšãƒ³ /Ê‹aËr kÉ‘n Éªk eËn ËˆpriË.peËt ËˆsÉªm.kaËrt ËˆkoË.pÉ™(n)/",
          "note": "é€šä¿¡æ‰‹æ®µã‚’ç¢ºä¿"
        },
        {
          "id": "communication-meet",
          "category": "é€šä¿¡",
          "scenario": ["æ—¥å¸¸ä¼šè©±", "è¦³å…‰"],
          "level": ["A1"],
          "tags": ["å¾…ã¡åˆã‚ã›", "æ™‚é–“"],
          "ja": "æ˜æ—¥ã®æœ10æ™‚ã«ãƒ­ãƒ“ãƒ¼ã§ä¼šã„ã¾ã—ã‚‡ã†ã€‚",
          "nl": "Laten we morgenochtend om tien uur in de lobby afspreken.",
          "hint": "ãƒ©ãƒ¼ãƒ†ãƒ³ ãƒ´ã‚§ ãƒ¢ãƒ«ãƒ˜ãƒ³ã‚ªãƒ•ãƒ†ãƒ³ãƒˆ ã‚ªãƒ  ãƒ†ã‚£ãƒ¼ãƒ³ ã‚¦ãƒ¼ãƒ« ã‚¤ãƒ³ ãƒ‡ ãƒ­ãƒ“ãƒ¼ ã‚¢ãƒ•ã‚¹ãƒ—ãƒ¬ãƒ¼ã‚±ãƒ³ /ËˆlaË.tÉ™(n) Ê‹É™ ËˆmÉ”r.É£É™.nÉ”x.tÉ™nt É”m tiËn uËr Éªn dÉ™ ËˆlÉ”.bi ËˆÉ‘f.sprÉ™Ë.kÉ™(n)/",
          "note": "å¾…ã¡åˆã‚ã›ã‚’æ±ºã‚ã‚‹"
        }
      ]
    }
  </script>

  <script>
    // ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã¯å¤–éƒ¨JSONã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã™ã€‚


    const DATA_URL = 'data/phrases.json';
    const LEVEL_ORDER = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];
    const ESSENTIALS_CATEGORY_SLUG = 'essentials';
    const ESSENTIALS_CATEGORY_NAMES = new Set([
      'åŸºæœ¬è¡¨ç¾',
      'åŸºæœ¬ãƒ•ãƒ¬ãƒ¼ã‚º',
      'åŸºç¤è¡¨ç¾',
      'Essentials',
    ]);
    const ESSENTIALS_SCENARIO_VALUE = 'essentials';

    const createSlug = (value) => {
      if (typeof value !== 'string') {
        return '';
      }

      const normalized = value.normalize('NFKC').trim();
      const slug = normalized
        .toLowerCase()
        .replace(/[^a-z0-9]+/gi, '-')
        .replace(/^-+|-+$/g, '');

      return slug || normalized;
    };

    const coalesce = (value, fallback) =>
      value === null || value === undefined ? fallback : value;

    const getElementTextContent = (element) => {
      if (!element) {
        return '';
      }

      if (typeof element.textContent === 'string') {
        return element.textContent;
      }

      if (typeof element.innerText === 'string') {
        return element.innerText;
      }

      return '';
    };

    const getTrimmedElementText = (element) => getElementTextContent(element).trim();

    const getTrimmedString = (value) =>
      typeof value === 'string' ? value.trim() : '';

    const getDatasetValue = (element, key, fallback) => {
      if (!element || !element.dataset) {
        return fallback;
      }

      if (Object.prototype.hasOwnProperty.call(element.dataset, key)) {
        const value = element.dataset[key];
        return value === undefined ? fallback : value;
      }

      return fallback;
    };

    const isEssentialsCategory = (categoryName) =>
      categoryName && ESSENTIALS_CATEGORY_NAMES.has(categoryName);

    const parsePhrasePayload = (payload) => {
      if (!payload || !Array.isArray(payload.phrases)) {
        throw new Error('ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚');
      }

      return payload.phrases;
    };

    const readEmbeddedPhraseData = () => {
      const element = document.getElementById('embedded-phrases');

      if (!element) {
        throw new Error('åŸ‹ã‚è¾¼ã¿ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      }

      const content = getElementTextContent(element);

      if (content.trim().length === 0) {
        throw new Error('åŸ‹ã‚è¾¼ã¿ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚');
      }

      try {
        const payload = JSON.parse(content);
        return parsePhrasePayload(payload);
      } catch (error) {
        console.error('åŸ‹ã‚è¾¼ã¿ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
        throw new Error('åŸ‹ã‚è¾¼ã¿ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
      }
    };

    const loadPhraseData = async () => {
      if (window.location.protocol !== 'file:') {
        try {
          const response = await fetch(DATA_URL, { cache: 'no-store' });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const payload = await response.json();

          return parsePhrasePayload(payload);
        } catch (error) {
          if (error instanceof TypeError || (error && error.name === 'TypeError')) {
            console.warn('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãŸã‚åŸ‹ã‚è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚', error);
          } else {
            throw error;
          }
        }
      }

      return readEmbeddedPhraseData();
    };

    const createPhraseModel = (phrases) => {
      const normalized = phrases.map((phrase, index) => {
        const scenario = Array.isArray(phrase.scenario)
          ? phrase.scenario.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const level = Array.isArray(phrase.level)
          ? phrase.level.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const tags = Array.isArray(phrase.tags)
          ? phrase.tags.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const categoryName =
          typeof phrase.category === 'string' && phrase.category.trim().length > 0
            ? phrase.category.trim()
            : 'ãã®ä»–';
        const categorySlug = isEssentialsCategory(categoryName)
          ? ESSENTIALS_CATEGORY_SLUG
          : createSlug(categoryName);

        return {
          ...phrase,
          category: categoryName,
          categorySlug,
          isEssentials: categorySlug === ESSENTIALS_CATEGORY_SLUG,
          scenario: scenario.length > 0 ? scenario : ['ãã®ä»–'],
          level: level.length > 0 ? level : ['A1'],
          tags,
          note: typeof phrase.note === 'string' ? phrase.note : '',
          order: index,
        };
      });

      const lookup = new Map(normalized.map((phrase) => [phrase.id, phrase]));
      const scenarioOrder = [];
      const categoryOrderMap = new Map();
      const tagSet = new Set();
      const levelSet = new Set();

      normalized.forEach((phrase) => {
        const categoryName = coalesce(phrase.category, 'ãã®ä»–');

        phrase.scenario.forEach((scenarioName) => {
          if (!scenarioOrder.includes(scenarioName)) {
            scenarioOrder.push(scenarioName);
          }

          const storedOrder = categoryOrderMap.get(scenarioName);

          if (storedOrder) {
            if (!storedOrder.includes(categoryName)) {
              storedOrder.push(categoryName);
            }
          } else {
            categoryOrderMap.set(scenarioName, [categoryName]);
          }
        });

        phrase.tags.forEach((tag) => tagSet.add(tag));
        phrase.level.forEach((levelValue) => levelSet.add(levelValue));
      });

      const levelOptions = Array.from(levelSet).sort((a, b) => {
        const indexA = LEVEL_ORDER.indexOf(a);
        const indexB = LEVEL_ORDER.indexOf(b);

        if (indexA === -1 && indexB === -1) {
          return a.localeCompare(b, 'ja');
        }

        if (indexA === -1) {
          return 1;
        }

        if (indexB === -1) {
          return -1;
        }

        return indexA - indexB;
      });

      const tagOptions = Array.from(tagSet).sort((a, b) => a.localeCompare(b, 'ja'));

      const filter = ({ scenario, level, tags }) =>
        normalized.filter((phrase) => {
          const matchesScenario =
            !scenario || scenario === 'all' || phrase.scenario.includes(scenario);
          const matchesLevel = !level || level === 'all' || phrase.level.includes(level);
          const matchesTags =
            !tags || tags.length === 0 || tags.every((tag) => phrase.tags.includes(tag));

          return matchesScenario && matchesLevel && matchesTags;
        });

      const comparators = {
        default: (a, b) => a.order - b.order,
        ja: (a, b) => a.ja.localeCompare(b.ja, 'ja'),
        nl: (a, b) => a.nl.localeCompare(b.nl, 'nl'),
        level: (a, b) => {
          const indexFromPhrase = (phrase) => {
            const indexes = phrase.level
              .map((levelValue) => {
                const index = LEVEL_ORDER.indexOf(levelValue);
                return index === -1 ? Number.POSITIVE_INFINITY : index;
              })
              .sort((x, y) => x - y);

            return indexes.length > 0 ? indexes[0] : Number.POSITIVE_INFINITY;
          };

          const indexA = indexFromPhrase(a);
          const indexB = indexFromPhrase(b);

          if (indexA === indexB) {
            return a.ja.localeCompare(b.ja, 'ja');
          }

          return indexA - indexB;
        },
      };

      const sort = (phrases, sortKey) => {
        const comparator =
          typeof comparators[sortKey] === 'function'
            ? comparators[sortKey]
            : comparators.default;
        return [...phrases].sort(comparator);
      };

      const group = (phrases, scenarioFilter) => {
        const activeScenarioNames =
          scenarioFilter && scenarioFilter !== 'all'
            ? new Set([scenarioFilter])
            : new Set(scenarioOrder);

        const scenarioMap = new Map();

        phrases.forEach((phrase) => {
          const categoryName = coalesce(phrase.category, 'ãã®ä»–');

          phrase.scenario.forEach((scenarioName) => {
            if (!activeScenarioNames.has(scenarioName)) {
              return;
            }

            let scenarioEntry = scenarioMap.get(scenarioName);

            if (!scenarioEntry) {
              scenarioEntry = {
                name: scenarioName,
                categories: new Map(),
                order: scenarioOrder.indexOf(scenarioName),
              };
              scenarioMap.set(scenarioName, scenarioEntry);
            }

            let categoryEntry = scenarioEntry.categories.get(categoryName);

            if (!categoryEntry) {
              categoryEntry = { name: categoryName, phrases: [] };
              scenarioEntry.categories.set(categoryName, categoryEntry);
            }

            categoryEntry.phrases.push(phrase);
          });
        });

        const groupedScenarios = Array.from(scenarioMap.values()).sort((a, b) => {
          const orderA = a.order === -1 ? Number.MAX_SAFE_INTEGER : a.order;
          const orderB = b.order === -1 ? Number.MAX_SAFE_INTEGER : b.order;

          if (orderA === orderB) {
            return a.name.localeCompare(b.name, 'ja');
          }

          return orderA - orderB;
        });

        return groupedScenarios.map((scenarioEntry) => {
          const storedOrder = categoryOrderMap.get(scenarioEntry.name);
          const baseOrder = Array.isArray(storedOrder) ? storedOrder : [];
          const categories = Array.from(scenarioEntry.categories.values()).sort((a, b) => {
            const orderA = baseOrder.indexOf(a.name);
            const orderB = baseOrder.indexOf(b.name);

            if (orderA === -1 && orderB === -1) {
              return a.name.localeCompare(b.name, 'ja');
            }

            if (orderA === -1) {
              return 1;
            }

            if (orderB === -1) {
              return -1;
            }

            return orderA - orderB;
          });

          return {
            name: scenarioEntry.name,
            categories,
          };
        });
      };

      const filterByLevel = (level) => filter({ scenario: null, level, tags: [] });
      const filterByTags = (tags) => filter({ scenario: null, level: null, tags });

      return {
        phrases: normalized,
        lookup,
        scenarioOrder,
        levelOptions,
        tagOptions,
        filter,
        sort,
        group,
        filterByLevel,
        filterByTags,
      };
    };

    let phraseModel = null;

    const getPhraseById = (id) => {
      if (!phraseModel || !phraseModel.lookup) {
        return null;
      }

      const phrase = phraseModel.lookup.get(id);
      return typeof phrase === 'undefined' ? null : phrase;
    };

    const getAllPhrases = () => (phraseModel ? phraseModel.phrases : []);


    const renderStudyMode = (model) => {
      const scenarioSelect = document.getElementById('filter-scenario');
      const levelSelect = document.getElementById('filter-level');
      const sortSelect = document.getElementById('filter-sort');
      const tagContainer = document.getElementById('tag-filter-options');
      const tagClearButton = document.getElementById('tag-clear-button');
      const filterForm = document.getElementById('phrase-filter-form');
      const loadingIndicator = document.getElementById('phrase-loading');
      const errorIndicator = document.getElementById('phrase-error');
      const emptyIndicator = document.getElementById('phrase-empty');
      const summaryIndicator = document.getElementById('phrase-count');
      const contentContainer = document.getElementById('study-content');

      if (
        !scenarioSelect ||
        !levelSelect ||
        !sortSelect ||
        !tagContainer ||
        !filterForm ||
        !contentContainer
      ) {
        return;
      }

      if (errorIndicator) {
        errorIndicator.classList.add('is-hidden');
        errorIndicator.textContent = '';
      }

      const getSelectedTags = () =>
        Array.from(tagContainer.querySelectorAll('input[type="checkbox"]:checked')).map(
          (input) => input.value
        );

      const updateSummary = (count) => {
        if (summaryIndicator) {
          summaryIndicator.textContent = `${count}ä»¶ã®ãƒ•ãƒ¬ãƒ¼ã‚º`;
        }
      };

      scenarioSelect.innerHTML = '';
      const scenarioDefaultOption = document.createElement('option');
      scenarioDefaultOption.value = 'all';
      scenarioDefaultOption.textContent = 'ã™ã¹ã¦ã®ã‚·ãƒŠãƒªã‚ª';
      scenarioSelect.appendChild(scenarioDefaultOption);

      model.scenarioOrder.forEach((scenarioName) => {
        const option = document.createElement('option');
        option.value = scenarioName;
        option.textContent = scenarioName;
        scenarioSelect.appendChild(option);
      });

      const hasEssentialsCategory = model.phrases.some(
        (phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG
      );

      if (hasEssentialsCategory) {
        const essentialsOption = document.createElement('option');
        essentialsOption.value = ESSENTIALS_SCENARIO_VALUE;
        essentialsOption.textContent = 'åŸºæœ¬è¡¨ç¾ï¼ˆã¾ã¨ã‚ï¼‰';
        scenarioSelect.appendChild(essentialsOption);
      }

      levelSelect.innerHTML = '';
      const levelDefaultOption = document.createElement('option');
      levelDefaultOption.value = 'all';
      levelDefaultOption.textContent = 'ã™ã¹ã¦ã®ãƒ¬ãƒ™ãƒ«';
      levelSelect.appendChild(levelDefaultOption);

      model.levelOptions.forEach((level) => {
        const option = document.createElement('option');
        option.value = level;
        option.textContent = level;
        levelSelect.appendChild(option);
      });

      sortSelect.innerHTML = '';
      [
        { value: 'default', label: 'ç™»éŒ²é †' },
        { value: 'ja', label: 'æ—¥æœ¬èªã®äº”åéŸ³é †' },
        { value: 'nl', label: 'ã‚ªãƒ©ãƒ³ãƒ€èªã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †' },
        { value: 'level', label: 'ãƒ¬ãƒ™ãƒ«é †' },
      ].forEach(({ value, label }) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        sortSelect.appendChild(option);
      });

      tagContainer.innerHTML = '';
      model.tagOptions.forEach((tag, index) => {
        const label = document.createElement('label');
        label.className = 'tag-chip';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.name = 'tags';
        input.value = tag;
        input.id = `tag-filter-${index}`;
        const text = document.createElement('span');
        text.textContent = tag;
        label.appendChild(input);
        label.appendChild(text);
        tagContainer.appendChild(label);
      });

      const createBadge = (textContent, type) => {
        const badge = document.createElement('span');
        badge.className = `phrase-badge phrase-badge-${type}`;
        badge.textContent = textContent;
        return badge;
      };

      const createPhraseRow = (phrase) => {
        const row = document.createElement('tr');
        row.dataset.phraseId = phrase.id;

        const jaCell = document.createElement('td');
        jaCell.dataset.label = 'æ—¥æœ¬èª';
        const jaStrong = document.createElement('strong');
        jaStrong.textContent = phrase.ja;
        jaCell.appendChild(jaStrong);

        if (phrase.note) {
          const note = document.createElement('span');
          note.className = 'phrase-note';
          note.textContent = phrase.note;
          jaCell.appendChild(note);
        }

        const meta = document.createElement('div');
        meta.className = 'phrase-meta';

        phrase.level.forEach((levelValue) => {
          meta.appendChild(createBadge(`Lv ${levelValue}`, 'level'));
        });

        phrase.tags.forEach((tag) => {
          meta.appendChild(createBadge(tag, 'tag'));
        });

        if (meta.childElementCount > 0) {
          jaCell.appendChild(meta);
        }

        const nlCell = document.createElement('td');
        nlCell.dataset.label = 'ã‚ªãƒ©ãƒ³ãƒ€èª';
        const nlSpan = document.createElement('span');
        nlSpan.className = 'phrase-dutch';
        nlSpan.textContent = phrase.nl;
        nlCell.appendChild(nlSpan);

        const actionGroup = document.createElement('div');
        actionGroup.className = 'phrase-actions';
        actionGroup.setAttribute('role', 'group');
        actionGroup.setAttribute('aria-label', 'éŸ³å£°æ“ä½œ');

        const speakButton = document.createElement('button');
        speakButton.type = 'button';
        speakButton.className = 'icon-button speak-control';
        speakButton.dataset.phraseId = phrase.id;
        const speakLabel = `ã€Œ${phrase.ja}ã€ã‚’ã‚ªãƒ©ãƒ³ãƒ€èªã§å†ç”Ÿ`;
        speakButton.dataset.defaultLabel = speakLabel;
        speakButton.dataset.activeLabel = `ã€Œ${phrase.ja}ã€ã‚’å†ç”Ÿä¸­`;
        speakButton.setAttribute('aria-label', speakLabel);
        speakButton.innerHTML = '<span aria-hidden="true">ğŸ”Š</span>';
        actionGroup.appendChild(speakButton);

        const recognizeButton = document.createElement('button');
        recognizeButton.type = 'button';
        recognizeButton.className = 'icon-button recognize-control';
        recognizeButton.dataset.phraseId = phrase.id;
        const recognizeLabel = `ãƒã‚¤ã‚¯ã§ã€Œ${phrase.nl}ã€ï¼ˆ${phrase.ja}ï¼‰ã‚’ç™ºå£°ã—ã¦ã¿ã‚ˆã†`;
        recognizeButton.dataset.defaultLabel = recognizeLabel;
        recognizeButton.dataset.activeLabel = `ã€Œ${phrase.nl}ã€ã‚’éŒ²éŸ³ä¸­`;
        recognizeButton.setAttribute('aria-label', recognizeLabel);
        recognizeButton.innerHTML = '<span aria-hidden="true">ğŸ¤</span>';
        actionGroup.appendChild(recognizeButton);

        nlCell.appendChild(actionGroup);

        const hintCell = document.createElement('td');
        hintCell.dataset.label = 'ã‚«ã‚¿ã‚«ãƒŠãƒ»ç™ºéŸ³ãƒ’ãƒ³ãƒˆ';
        const hintSpan = document.createElement('span');
        hintSpan.textContent = coalesce(phrase.hint, 'â€•');
        hintCell.appendChild(hintSpan);

        row.appendChild(jaCell);
        row.appendChild(nlCell);
        row.appendChild(hintCell);

        return row;
      };

      const createCategorySection = (category) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'scenario-category';

        const heading = document.createElement('h4');
        heading.textContent = category.name;
        wrapper.appendChild(heading);

        const table = document.createElement('table');
        table.className = 'phrase-table';
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['æ—¥æœ¬èª', 'ã‚ªãƒ©ãƒ³ãƒ€èª', 'ã‚«ã‚¿ã‚«ãƒŠãƒ»ç™ºéŸ³ãƒ’ãƒ³ãƒˆ'].forEach((label) => {
          const th = document.createElement('th');
          th.scope = 'col';
          th.textContent = label;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        category.phrases.forEach((phrase) => {
          tbody.appendChild(createPhraseRow(phrase));
        });
        table.appendChild(tbody);

        wrapper.appendChild(table);
        return wrapper;
      };

      const createEssentialsSection = (phrases) => {
        if (!phrases || phrases.length === 0) {
          return null;
        }

        const section = document.createElement('section');
        section.className = 'scenario-card';
        section.dataset.scenario = ESSENTIALS_SCENARIO_VALUE;

        const header = document.createElement('div');
        header.className = 'scenario-card-header';
        const title = document.createElement('h3');
        title.textContent = 'åŸºæœ¬è¡¨ç¾ï¼ˆEssentialsï¼‰';
        header.appendChild(title);
        const count = document.createElement('span');
        count.className = 'scenario-count';
        count.textContent = `${phrases.length}ä»¶`;
        header.appendChild(count);
        section.appendChild(header);

        const note = document.createElement('p');
        note.className = 'scenario-note';
        note.textContent =
          'ä¸å¯§ãªæ„Ÿè¬ã‚„è¬ç½ªãªã©ã€æ»åœ¨ä¸­ã™ãã«ä½¿ãˆã‚‹åŸºæœ¬è¡¨ç¾ã‚’ã¾ã¨ã‚ãŸã‚·ãƒ§ãƒ¼ãƒˆãƒªã‚¹ãƒˆã§ã™ã€‚';
        section.appendChild(note);

        const categoryMap = new Map();
        phrases.forEach((phrase) => {
          const categoryName = coalesce(phrase.category, 'åŸºæœ¬è¡¨ç¾');
          if (!categoryMap.has(categoryName)) {
            categoryMap.set(categoryName, []);
          }
          categoryMap.get(categoryName).push(phrase);
        });

        categoryMap.forEach((phraseList, categoryName) => {
          section.appendChild(
            createCategorySection({ name: categoryName, phrases: phraseList })
          );
        });

        return section;
      };

      const render = () => {
        const scenarioValue = scenarioSelect.value;
        const levelValue = levelSelect.value;
        const sortValue = sortSelect.value;
        const selectedTags = getSelectedTags();

        const isEssentialsScenario =
          hasEssentialsCategory && scenarioValue === ESSENTIALS_SCENARIO_VALUE;

        const filtered = model.filter({
          scenario: isEssentialsScenario ? null : scenarioValue,
          level: levelValue,
          tags: selectedTags,
        });
        const filteredForScenario = isEssentialsScenario
          ? filtered.filter((phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG)
          : filtered;
        const sorted = model.sort(filteredForScenario, sortValue);
        const essentialsSorted = isEssentialsScenario
          ? sorted
          : sorted.filter((phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG);
        const grouped = isEssentialsScenario ? [] : model.group(sorted, scenarioValue);

        if (loadingIndicator) {
          loadingIndicator.classList.add('is-hidden');
        }

        contentContainer.innerHTML = '';

        if (sorted.length === 0) {
          updateSummary(0);
          if (emptyIndicator) {
            emptyIndicator.classList.remove('is-hidden');
          }
          return;
        }

        if (emptyIndicator) {
          emptyIndicator.classList.add('is-hidden');
        }

        updateSummary(sorted.length);

        const shouldRenderEssentialsSection =
          hasEssentialsCategory &&
          essentialsSorted.length > 0 &&
          (isEssentialsScenario || scenarioValue === 'all');

        if (shouldRenderEssentialsSection) {
          const essentialsSection = createEssentialsSection(essentialsSorted);
          if (essentialsSection) {
            contentContainer.appendChild(essentialsSection);
          }
        }

        if (!isEssentialsScenario) {
          grouped.forEach((scenarioEntry) => {
            const scenarioSection = document.createElement('section');
            scenarioSection.className = 'scenario-card';

            const header = document.createElement('div');
            header.className = 'scenario-card-header';
            const title = document.createElement('h3');
            title.textContent = scenarioEntry.name;
            header.appendChild(title);
            const count = document.createElement('span');
            count.className = 'scenario-count';
            const phraseCount = scenarioEntry.categories.reduce(
              (acc, category) => acc + category.phrases.length,
              0
            );
            count.textContent = `${phraseCount}ä»¶`;
            header.appendChild(count);
            scenarioSection.appendChild(header);

            scenarioEntry.categories.forEach((category) => {
              scenarioSection.appendChild(createCategorySection(category));
            });

            contentContainer.appendChild(scenarioSection);
          });
        }

        if (typeof syncRecognitionControls === 'function') {
          syncRecognitionControls();
        }
      };

      scenarioSelect.addEventListener('change', render);
      levelSelect.addEventListener('change', render);
      sortSelect.addEventListener('change', render);
      tagContainer.addEventListener('change', (event) => {
        if (event.target && event.target.matches('input[type="checkbox"]')) {
          render();
        }
      });

      if (tagClearButton) {
        tagClearButton.addEventListener('click', () => {
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        });
      }

      filterForm.addEventListener('reset', () => {
        window.setTimeout(() => {
          scenarioSelect.value = 'all';
          levelSelect.value = 'all';
          sortSelect.value = 'default';
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        }, 0);
      });

      render();
    };

    const attachPhraseData = (model) => {
      phraseModel = model;
      if (!window.NederLingo) {
        window.NederLingo = {};
      }
      window.NederLingo.phraseModel = {
        getAll: () => model.phrases,
        filterByLevel: model.filterByLevel,
        filterByTags: model.filterByTags,
      };
    };


    const showPhraseDataError = (error) => {
      const errorIndicator = document.getElementById('phrase-error');
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.add('is-hidden');
      }

      if (errorIndicator) {
        const escapeHtml = (value) =>
          String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

        const rawMessage =
          typeof error === 'string'
            ? error
            : error && typeof error.message === 'string'
              ? error.message
              : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ã§ã™ã€‚';
        const errorName =
          typeof error === 'object' && error !== null && 'name' in error && typeof error.name === 'string'
            ? error.name
            : undefined;

        const normalizedMessage = rawMessage.toLowerCase();
        const isTypeError = error instanceof TypeError || errorName === 'TypeError' || normalizedMessage.includes('typeerror');
        const httpMatch = rawMessage.match(/http\s+(\d{3})/i);
        const httpStatus = httpMatch ? httpMatch[1] : null;
        const isFileProtocol = window.location.protocol === 'file:';
        const stackTrace =
          typeof error === 'object' && error !== null && 'stack' in error && typeof error.stack === 'string'
            ? error.stack
            : undefined;

        let primaryMessage = 'ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
        const suggestions = [];

        if (httpStatus === '404') {
          primaryMessage = 'ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ (data/phrases.json) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ•ã‚¡ã‚¤ãƒ«åã¨é…ç½®ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else if (httpStatus) {
          primaryMessage = `ã‚µãƒ¼ãƒãƒ¼ãŒ HTTP ${httpStatus} ã‚’è¿”ã—ã¾ã—ãŸã€‚ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°ã‚„ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
        } else if (isTypeError) {
          primaryMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æ¥ç¶šã§ããªã„ãŸã‚ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚„ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼ã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        }

        if (isFileProtocol) {
          suggestions.push('ãƒ–ãƒ©ã‚¦ã‚¶ã§ç›´æ¥ index.html ã‚’é–‹ãã¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ããªã„ãŸã‚ã€ãƒ­ãƒ¼ã‚«ãƒ« HTTP ã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚');
        }

        suggestions.push('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆã§ <code>npx serve</code> ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã€VS Code ã® Live Server æ‹¡å¼µæ©Ÿèƒ½ã§é…ä¿¡ã™ã‚‹ã¨è§£æ±ºã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚');

        const actionLink = `
          <div class="phrase-error-actions" style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <a class="mode-button" href="https://github.com/vercel/serve#readme" target="_blank" rel="noopener">ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †ã‚’è¦‹ã‚‹</a>
            <a class="mode-button" href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server ã‚’é–‹ã</a>
          </div>
        `;

        const suggestionMarkup =
          suggestions.length > 0
            ? `<ul style="margin:12px 0 0;padding-left:1.4em;">${suggestions
                .map((item) => `<li style="margin-bottom:6px;">${item}</li>`)
                .join('')}</ul>`
            : '';

        const detailsMarkup = rawMessage
          ? `<details style="margin-top:16px;">` +
            '<summary style="cursor:pointer;">æŠ€è¡“çš„ãªè©³ç´°ã‚’è¡¨ç¤º</summary>' +
            `<pre style="margin-top:8px;white-space:pre-wrap;word-break:break-all;">${escapeHtml(rawMessage)}</pre>` +
            (errorName && errorName !== 'Error'
              ? `<p style="margin-top:8px;font-size:0.9em;color:var(--muted);">ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥: ${escapeHtml(errorName)}</p>`
              : '') +
            (stackTrace && stackTrace !== rawMessage
              ? `<pre style="margin-top:8px;white-space:pre-wrap;word-break:break-all;font-size:0.85em;">${escapeHtml(stackTrace)}</pre>`
              : '') +
            '</details>'
          : '';

        errorIndicator.innerHTML =
          `<p style="margin:0;">${primaryMessage}</p>` + suggestionMarkup + actionLink + detailsMarkup;
        errorIndicator.classList.remove('is-hidden');
      }
    };

    const bootstrapPhraseData = async () => {
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.remove('is-hidden');
      }

      try {
        const phrases = await loadPhraseData();
        const model = createPhraseModel(phrases);
        attachPhraseData(model);
        renderStudyMode(model);
        return model;
      } catch (error) {
        console.error(error);
        showPhraseDataError(error);
        return null;
      }
    };

    const phraseDataPromise = bootstrapPhraseData();

    const shuffleArray = (input) => {
      const array = [...input];

      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }

      return array;
    };

    const modeContainer = document.querySelector('.main-container');
    const modeButtons = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode]'))
      : [];
    const modePanels = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode-panel]'))
      : [];

    if (modeContainer && modeButtons.length > 0 && modePanels.length > 0) {
      const setActiveMode = (mode) => {
        modeContainer.dataset.activeMode = mode;

        modeButtons.forEach((button) => {
          const targetMode = button.getAttribute('data-mode');
          const isActive = targetMode === mode;

          button.setAttribute('aria-selected', String(isActive));
          button.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        modePanels.forEach((panel) => {
          const panelMode = panel.getAttribute('data-mode-panel');
          const isActive = panelMode === mode;

          panel.toggleAttribute('hidden', !isActive);
          panel.setAttribute('aria-hidden', String(!isActive));
        });
      };

      const availableModes = modeButtons
        .map((button) => button.getAttribute('data-mode'))
        .filter((value) => typeof value === 'string' && value.length > 0);

      let initialMode = modeContainer.dataset.activeMode;

      if (!initialMode || !availableModes.includes(initialMode)) {
        initialMode = availableModes[0];
      }

      setActiveMode(initialMode);

      modeButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const mode = button.getAttribute('data-mode');

          if (!mode) {
            return;
          }

          setActiveMode(mode);
        });

        button.addEventListener('keydown', (event) => {
          const currentIndex = modeButtons.indexOf(button);
          let targetIndex = null;

          if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
            targetIndex = (currentIndex + 1) % modeButtons.length;
          } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
            targetIndex =
              (currentIndex - 1 + modeButtons.length) % modeButtons.length;
          } else if (event.key === 'Home') {
            targetIndex = 0;
          } else if (event.key === 'End') {
            targetIndex = modeButtons.length - 1;
          }

          if (targetIndex !== null) {
            event.preventDefault();

            const targetButton = modeButtons[targetIndex];

            if (!targetButton) {
              return;
            }

            const mode = targetButton.getAttribute('data-mode');

            if (mode) {
              setActiveMode(mode);
              targetButton.focus();
            }
          }
        });
      });
    }

    const rateSlider = document.getElementById('speech-rate');
    const rateValue = document.getElementById('speech-rate-value');
    const speechFeedback = document.getElementById('speech-feedback');
    const recognitionStatus = document.getElementById('recognition-status');
    const recognitionTarget = document.getElementById('recognition-target');
    const recognitionText = document.getElementById('recognition-text');
    const recognitionScore = document.getElementById('recognition-score');
    const recognitionLive = document.getElementById('recognition-live');
    const recognitionNotice = document.getElementById('speech-recognition-notice');

    let speakDutchPhrase = null;

    const defaultStatusMessage =
      getTrimmedElementText(recognitionStatus) || 'éŒ²éŸ³å¾…æ©Ÿä¸­ã§ã™ã€‚';

    let recognitionAudioContext = null;

    const ensureRecognitionAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!recognitionAudioContext) {
        recognitionAudioContext = new AudioContextClass();
      }

      if (recognitionAudioContext.state === 'suspended') {
        recognitionAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return recognitionAudioContext;
    };

    const playRecognitionTone = (isPerfectMatch) => {
      const context = ensureRecognitionAudioContext();

      if (!context) {
        return;
      }

      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      const now = context.currentTime;

      oscillator.type = isPerfectMatch ? 'triangle' : 'sine';

      if (isPerfectMatch) {
        oscillator.frequency.setValueAtTime(880, now);
        oscillator.frequency.exponentialRampToValueAtTime(1320, now + 0.22);
      } else {
        oscillator.frequency.setValueAtTime(320, now);
        oscillator.frequency.exponentialRampToValueAtTime(220, now + 0.22);
      }

      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.25, now + 0.04);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);

      oscillator.connect(gainNode);
      gainNode.connect(context.destination);

      oscillator.start(now);
      oscillator.stop(now + 0.34);
    };

    const showRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = false;
      }
    };

    const hideRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = true;
      }
    };

    if (recognitionStatus) {
      recognitionStatus.dataset.defaultMessage = defaultStatusMessage;
      recognitionStatus.dataset.state = recognitionStatus.dataset.state || 'idle';
    }

    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;

    const syncRecognitionControls = () => {
      document.querySelectorAll('.recognize-control').forEach((button) => {
        const baseLabel =
          button.dataset.defaultLabel || 'ã‚ªãƒ©ãƒ³ãƒ€èªãƒ•ãƒ¬ãƒ¼ã‚ºã®ç™ºå£°ã‚’ãƒ†ã‚¹ãƒˆ';

        if (!SpeechRecognition) {
          button.setAttribute(
            'aria-label',
            `${baseLabel} (éŸ³å£°èªè­˜ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“)`
          );
          button.disabled = true;
        } else {
          button.setAttribute('aria-label', baseLabel);
          button.disabled = false;
        }
      });
    };

    if (rateSlider && rateValue) {
      const updateRateLabel = () => {
        rateValue.textContent = `${parseFloat(rateSlider.value).toFixed(1)}x`;
      };

      rateSlider.addEventListener('input', updateRateLabel);
      updateRateLabel();
    }

    if ('speechSynthesis' in window) {
      const synthesis = window.speechSynthesis;
      let availableVoices = [];
      let activeButton = null;

      const restoreStatusAfterSpeech = () => {
        if (
          recognitionStatus &&
          recognitionStatus.dataset.state === 'speaking'
        ) {
          const previous =
            recognitionStatus.dataset.previousStatus || defaultStatusMessage;
          recognitionStatus.textContent = previous;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
        }
      };

      const markStatusForSpeech = () => {
        if (!recognitionStatus) {
          return;
        }

        recognitionStatus.dataset.previousStatus =
          getTrimmedElementText(recognitionStatus) || defaultStatusMessage;
        recognitionStatus.dataset.state = 'speaking';
        recognitionStatus.textContent = 'å†ç”Ÿä¸­ã§ã™â€¦';
      };

      const refreshVoices = () => {
        availableVoices = synthesis
          .getVoices()
          .filter((voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl'));

        if (availableVoices.length === 0) {
          availableVoices = synthesis.getVoices();
        }
      };

      const resetActiveButton = () => {
        restoreStatusAfterSpeech();

        if (activeButton) {
          activeButton.disabled = false;
          activeButton.classList.remove('is-active');
          const defaultLabel = getDatasetValue(
            activeButton,
            'defaultLabel',
            'ã‚ªãƒ©ãƒ³ãƒ€èªãƒ•ãƒ¬ãƒ¼ã‚ºã‚’å†ç”Ÿ'
          );
          activeButton.setAttribute('aria-label', defaultLabel);
          activeButton = null;
        }
      };

      speakDutchPhrase = ({ phraseId, triggerButton = null } = {}) => {
        if (!phraseId) {
          return false;
        }

        const phrase = getPhraseById(phraseId);
        const dutchText =
          phrase && typeof phrase.nl === 'string' ? phrase.nl.trim() : '';

        if (!phrase || !dutchText) {
          return false;
        }

        if (availableVoices.length === 0) {
          refreshVoices();
        }

        if (synthesis.speaking || synthesis.pending) {
          synthesis.cancel();
        }

        resetActiveButton();

        const utterance = new SpeechSynthesisUtterance(dutchText);
        utterance.lang = 'nl-NL';

        if (rateSlider) {
          const parsedRate = parseFloat(rateSlider.value);
          if (!Number.isNaN(parsedRate)) {
            utterance.rate = parsedRate;
          }
        }

        const selectedVoice = availableVoices.find(
          (voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl')
        );

        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }

        if (speechFeedback) {
          speechFeedback.classList.remove('is-hidden');
        }

        if (recognitionTarget) {
          recognitionTarget.textContent = dutchText;
        }

        markStatusForSpeech();

        if (triggerButton) {
          if (!triggerButton.dataset.defaultLabel) {
            const currentLabel = triggerButton.getAttribute('aria-label');
            if (currentLabel) {
              triggerButton.dataset.defaultLabel = currentLabel;
            }
          }

          activeButton = triggerButton;
          triggerButton.disabled = true;
          triggerButton.classList.add('is-active');
          const activeLabel = getDatasetValue(triggerButton, 'activeLabel', 'å†ç”Ÿä¸­â€¦');
          triggerButton.setAttribute('aria-label', activeLabel);
        }

        const clearAfterSpeech = () => {
          if (triggerButton && activeButton === triggerButton) {
            resetActiveButton();
          } else {
            restoreStatusAfterSpeech();
          }
        };

        utterance.onend = clearAfterSpeech;
        utterance.onerror = clearAfterSpeech;

        synthesis.speak(utterance);

        return true;
      };

      const handleSpeakClick = (event) => {
        const button = event.target.closest('.speak-control');

        if (!button || typeof speakDutchPhrase !== 'function') {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        speakDutchPhrase({
          phraseId: button.dataset.phraseId,
          triggerButton: button,
        });
      };

      refreshVoices();
      synthesis.addEventListener('voiceschanged', refreshVoices);
      document.addEventListener('click', handleSpeakClick);
    }

    const sanitizePhrase = (text) =>
      text
        .toLowerCase()
        .replace(/[^a-zÃ -Å¾\s']/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim();

    const computeSimilarity = (a, b) => {
      const source = sanitizePhrase(a);
      const target = sanitizePhrase(b);

      if (!source && !target) {
        return 1;
      }

      if (!source || !target) {
        return 0;
      }

      const rows = source.length + 1;
      const cols = target.length + 1;
      const dp = Array.from({ length: rows }, () => new Array(cols).fill(0));

      for (let i = 0; i < rows; i += 1) {
        dp[i][0] = i;
      }

      for (let j = 0; j < cols; j += 1) {
        dp[0][j] = j;
      }

      for (let i = 1; i < rows; i += 1) {
        for (let j = 1; j < cols; j += 1) {
          const cost = source[i - 1] === target[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }

      const distance = dp[rows - 1][cols - 1];
      const longest = Math.max(source.length, target.length);

      return longest === 0 ? 1 : 1 - distance / longest;
    };

      if (
        recognitionNotice &&
        speechFeedback &&
        recognitionStatus &&
        recognitionTarget &&
        recognitionText &&
        recognitionScore
      ) {
        syncRecognitionControls();

        if (!SpeechRecognition) {
          if (speechFeedback) {
            speechFeedback.classList.add('is-hidden');
          }
          recognitionNotice.textContent =
            'ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°èªè­˜ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚Chromeãªã©ã®å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã§ãŠè©¦ã—ãã ã•ã„ã€‚';
          recognitionNotice.classList.remove('is-hidden');
          recognitionStatus.textContent = 'éŸ³å£°èªè­˜ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚';
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
        } else {
          speechFeedback.classList.remove('is-hidden');
          recognitionNotice.textContent = 'åˆå›åˆ©ç”¨æ™‚ã¯ãƒã‚¤ã‚¯ã‚¢ã‚¤ã‚³ãƒ³ã‚’æŠ¼ã™éš›ã«ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒã‚¤ã‚¯è¨±å¯ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚';
          recognitionNotice.classList.remove('is-hidden');
          recognitionStatus.textContent = defaultStatusMessage;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;

          const recognition = new SpeechRecognition();
          recognition.lang = 'nl-NL';
          recognition.continuous = false;
          recognition.interimResults = false;
          recognition.maxAlternatives = 1;

          let activeRecognitionButton = null;
          let targetPhrase = '';

          const releaseRecognitionButton = () => {
            if (activeRecognitionButton) {
              activeRecognitionButton.disabled = false;
              activeRecognitionButton.classList.remove('is-recording');
              const defaultLabel = getDatasetValue(
                activeRecognitionButton,
                'defaultLabel',
                'ã‚ªãƒ©ãƒ³ãƒ€èªãƒ•ãƒ¬ãƒ¼ã‚ºã®ç™ºå£°ã‚’ãƒ†ã‚¹ãƒˆ'
              );
              activeRecognitionButton.setAttribute('aria-label', defaultLabel);
              activeRecognitionButton = null;
            }
          };

          recognition.addEventListener('start', () => {
            showRecognitionLive();

            if (recognitionText) {
              recognitionText.textContent = 'è´ãå–ã‚Šä¸­â€¦';
            }

            if (recognitionScore) {
              recognitionScore.textContent = '-';
            }

            if (recognitionStatus) {
              const previousStatus =
                getTrimmedElementText(recognitionStatus) || defaultStatusMessage;
              recognitionStatus.dataset.previousStatus = previousStatus;
              recognitionStatus.dataset.state = 'recognition';
              recognitionStatus.textContent = 'éŒ²éŸ³ä¸­ã§ã™ã€‚è©±ã—çµ‚ãˆãŸã‚‰è‡ªå‹•çš„ã«åˆ¤å®šã—ã¾ã™ã€‚';
            }
          });

          recognition.addEventListener('result', (event) => {
            let transcript = '';
            const results = event.results;

            if (
              results &&
              results[0] &&
              results[0][0] &&
              typeof results[0][0].transcript === 'string'
            ) {
              transcript = results[0][0].transcript.trim();
            }

            recognitionText.textContent = transcript || '-';
            recognitionTarget.textContent = targetPhrase || '-';

            const similarity = computeSimilarity(transcript, targetPhrase);
            const percentage = Math.round(similarity * 100);
            recognitionScore.textContent = Number.isNaN(percentage) ? '-' : `${percentage}%`;

            if (transcript && targetPhrase) {
              const isPerfectMatch = !Number.isNaN(percentage) && percentage === 100;
              playRecognitionTone(isPerfectMatch);
            }
          });

          recognition.addEventListener('error', (event) => {
            recognitionStatus.textContent = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${event.error}`;
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();
            releaseRecognitionButton();
          });

          recognition.addEventListener('nomatch', () => {
            recognitionStatus.textContent = 'éŸ³å£°ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();
          });

          recognition.addEventListener('end', () => {
            releaseRecognitionButton();

            if (recognitionStatus) {
              if (recognitionStatus.dataset.state === 'recognition') {
                recognitionStatus.textContent =
                  recognitionStatus.dataset.previousStatus || defaultStatusMessage;
              }
              recognitionStatus.dataset.state = 'idle';
              delete recognitionStatus.dataset.previousStatus;
            }
          });

          const handleRecognitionClick = (event) => {
            const button = event.target.closest('.recognize-control');

            if (!button) {
              return;
            }

            event.preventDefault();
            event.stopPropagation();

            const phraseId = button.dataset.phraseId;
            const phrase = phraseId ? getPhraseById(phraseId) : null;
            const dutchText =
              phrase && typeof phrase.nl === 'string' ? phrase.nl.trim() : '';

            if (!phrase || !dutchText) {
              return;
            }

            if (activeRecognitionButton) {
              try {
                recognition.abort();
              } catch (error) {
                /* noop */
              }
              releaseRecognitionButton();
            }

            targetPhrase = dutchText;
            recognitionTarget.textContent = dutchText;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();

            activeRecognitionButton = button;
            button.disabled = true;
            button.classList.add('is-recording');
            const activeLabel = getDatasetValue(button, 'activeLabel', 'éŒ²éŸ³ä¸­â€¦');
            button.setAttribute('aria-label', activeLabel);

            try {
              recognition.start();
            } catch (error) {
              recognitionStatus.textContent =
                'éŸ³å£°èªè­˜ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
              recognitionStatus.dataset.state = 'idle';
              delete recognitionStatus.dataset.previousStatus;
              releaseRecognitionButton();
              targetPhrase = '';
              recognitionTarget.textContent = '-';
              recognitionText.textContent = '-';
              recognitionScore.textContent = '-';
              hideRecognitionLive();
            }
          };

          document.addEventListener('click', handleRecognitionClick);

          window.addEventListener('beforeunload', () => {
            try {
              recognition.stop();
            } catch (error) {
              /* noop */
            }
          });
        }
      }
    }

    const gameGrid = document.getElementById('game-grid');
    const gameStatus = document.getElementById('game-status');
    const stageDisplay = document.getElementById('game-stage');
    const scoreDisplay = document.getElementById('game-score');
    const streakDisplay = document.getElementById('game-streak');
    const bestDisplay = document.getElementById('game-best');
    const startButton = document.getElementById('game-start-button');
    const resetButton = document.getElementById('game-reset-button');
    const timeDisplay = document.getElementById('game-time');
    const countdownFill = document.getElementById('game-timer-fill');
    const correctDisplay = document.getElementById('game-correct');
    const mistakesDisplay = document.getElementById('game-mistakes');

    const TIME_LIMIT_SECONDS = 60;
    const TIME_LIMIT_MS = TIME_LIMIT_SECONDS * 1000;
    let timerAnimationFrame = null;

    const gameState = {
      stage: 0,
      score: 0,
      streak: 0,
      best: 0,
      matchesRemaining: 0,
      selection: [],
      busy: false,
      phraseQueue: [],
      columns: null,
      timeRemainingMs: TIME_LIMIT_MS,
      correctMatches: 0,
      mistakes: 0,
      timerStartedAt: null,
      roundActive: false,
    };

    const pulseElement = (element) => {
      if (!element) {
        return;
      }

      element.classList.remove('score-pulse');
      void element.offsetWidth;
      element.classList.add('score-pulse');
    };

    const MAX_VISIBLE_PAIRS = 5;

    const stagePairCount = (stage = 1) => {
      const totalPhrases = getAllPhrases().length;

      if (totalPhrases <= 0) {
        return 0;
      }

      return Math.min(stage * MAX_VISIBLE_PAIRS, totalPhrases);
    };

    const setStatus = (message) => {
      if (gameStatus) {
        gameStatus.textContent = message;
      }
    };

    const formatStatusWithSpeechCue = (didSpeak, message) =>
      didSpeak ? `ğŸ”Š ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰ã®ç™ºéŸ³ã‚’å†ç”Ÿã—ãŸã‚ˆã€‚${message}` : message;

    const updateScoreboard = () => {
      if (stageDisplay) {
        stageDisplay.textContent = gameState.stage;
      }

      if (scoreDisplay) {
        scoreDisplay.textContent = gameState.score;
      }

      if (streakDisplay) {
        streakDisplay.textContent = gameState.streak;
      }

      if (bestDisplay) {
        bestDisplay.textContent = `BEST ${gameState.best}`;
      }

      if (correctDisplay) {
        correctDisplay.textContent = gameState.correctMatches;
      }

      if (mistakesDisplay) {
        mistakesDisplay.textContent = gameState.mistakes;
      }

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
        timeDisplay.textContent = seconds.toString();
      }
    };

    const setTimeRemaining = (remainingMs) => {
      const clamped = Math.max(0, Math.min(TIME_LIMIT_MS, remainingMs));
      gameState.timeRemainingMs = clamped;

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(clamped / 1000));
        timeDisplay.textContent = seconds.toString();
      }

      if (countdownFill) {
        const percentage = TIME_LIMIT_MS === 0 ? 0 : (clamped / TIME_LIMIT_MS) * 100;
        countdownFill.style.width = `${percentage}%`;
        countdownFill.classList.toggle('is-warning', percentage <= 50 && percentage > 20);
        countdownFill.classList.toggle('is-danger', percentage <= 20);
      }
    };

    const stopTimer = ({ resetToFull = false } = {}) => {
      if (timerAnimationFrame !== null) {
        cancelAnimationFrame(timerAnimationFrame);
        timerAnimationFrame = null;
      }

      gameState.roundActive = false;
      gameState.timerStartedAt = null;

      if (resetToFull) {
        setTimeRemaining(TIME_LIMIT_MS);
      }
    };

    const handleTimeUp = () => {
      if (gameState.matchesRemaining <= 0) {
        return;
      }

      setTimeRemaining(0);
      gameState.busy = true;
      gameState.roundActive = false;
      gameState.selection = [];
      gameState.streak = 0;

      if (gameGrid) {
        gameGrid.querySelectorAll('.game-card').forEach((card) => {
          card.classList.add('is-disabled');
          card.classList.remove('is-selected');
        });
      }

      const remainingPairs = gameState.matchesRemaining;
      const remainingPenalty = remainingPairs * 5;

      if (remainingPenalty > 0) {
        gameState.score = Math.max(0, gameState.score - remainingPenalty);
      }

      updateScoreboard();

      if (remainingPenalty > 0) {
        pulseElement(scoreDisplay);
      }

      pulseElement(streakDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦';
      }

      const summary = `â° ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—ï¼${gameState.correctMatches}çµ„æ­£è§£ã€ãƒŸã‚¹${gameState.mistakes}å›ã€‚`;

      if (remainingPenalty > 0) {
        setStatus(
          `${summary}æ®‹ã‚Š${remainingPairs}çµ„ã§${remainingPenalty}ç‚¹ã®æ¸›ç‚¹â€¦æ¬¡ã®æŒ‘æˆ¦ã§æŒ½å›ã—ã‚ˆã†ï¼`
        );
      } else {
        setStatus(`${summary}ã‚ã¨å°‘ã—ã ã£ãŸã­ï¼`);
      }

      gameState.matchesRemaining = 0;
    };

    const tickTimer = (timestamp) => {
      if (!gameState.roundActive) {
        return;
      }

      if (gameState.timerStartedAt === null) {
        gameState.timerStartedAt = timestamp;
      }

      const elapsed = timestamp - gameState.timerStartedAt;
      const remaining = TIME_LIMIT_MS - elapsed;

      if (remaining <= 0) {
        stopTimer();
        handleTimeUp();
        return;
      }

      setTimeRemaining(remaining);
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const startTimer = () => {
      stopTimer();
      gameState.roundActive = true;
      gameState.timerStartedAt = null;
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const createGameCard = (phrase, lang) => {
      const card = document.createElement('div');
      card.className = 'game-card';
      card.dataset.pairId = phrase.id;
      card.dataset.lang = lang;

      const mainButton = document.createElement('button');
      mainButton.type = 'button';
      mainButton.className = 'game-card-main';

      const labelText = lang === 'ja' ? 'æ—¥æœ¬èªã‚«ãƒ¼ãƒ‰' : 'ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰';
      const displayText = lang === 'ja' ? phrase.ja : phrase.nl;
      const actionHint =
        lang === 'nl'
          ? 'ã€‚ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã‚ªãƒ©ãƒ³ãƒ€èªã®ç™ºéŸ³ãŒå†ç”Ÿã•ã‚Œã¾ã™ã€‚'
          : 'ã€‚ã‚¿ãƒƒãƒ—ã—ã¦å¯¾å¿œã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’è¦‹ã¤ã‘ã¾ã—ã‚‡ã†ã€‚';
      mainButton.setAttribute('aria-label', `${labelText}: ${displayText}${actionHint}`);

      if (lang === 'nl') {
        mainButton.title = 'ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã‚ªãƒ©ãƒ³ãƒ€èªã®ç™ºéŸ³ãŒå†ç”Ÿã•ã‚Œã¾ã™';
        mainButton.setAttribute('aria-describedby', 'game-speech-instruction');
      } else {
        mainButton.title = 'ã‚¿ãƒƒãƒ—ã—ã¦å¯¾å¿œã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’æ¢ã—ã¾ã—ã‚‡ã†';
      }

      const textSpan = document.createElement('span');
      textSpan.className = 'game-card-text';
      textSpan.textContent = displayText;

      mainButton.append(textSpan);

      card.append(mainButton);

      return card;
    };

    const speakCardIfDutch = ({ lang, pairId, alreadySelected = false } = {}) => {
      if (alreadySelected || lang !== 'nl' || !pairId) {
        return false;
      }

      if (typeof speakDutchPhrase !== 'function') {
        return false;
      }

      return speakDutchPhrase({ phraseId: pairId });
    };

    const createCardColumn = (lang) => {
      const column = document.createElement('div');
      column.className = 'game-card-column';
      column.dataset.lang = lang;
      column.setAttribute(
        'aria-label',
        lang === 'nl' ? 'ã‚ªãƒ©ãƒ³ãƒ€èªã®ã‚«ãƒ¼ãƒ‰' : 'æ—¥æœ¬èªã®ã‚«ãƒ¼ãƒ‰'
      );
      column.setAttribute('role', 'group');
      return column;
    };

    const rebuildGameColumns = () => {
      if (!gameGrid) {
        return null;
      }

      gameGrid.innerHTML = '';

      const dutchColumn = createCardColumn('nl');
      const japaneseColumn = createCardColumn('ja');

      const fragment = document.createDocumentFragment();
      fragment.append(dutchColumn, japaneseColumn);

      gameGrid.appendChild(fragment);

      return { dutchColumn, japaneseColumn };
    };

    const insertCardRandomly = (column, card) => {
      if (!column || !card) {
        return;
      }

      const insertionIndex = Math.floor(Math.random() * (column.childElementCount + 1));

      if (insertionIndex >= column.childElementCount) {
        column.appendChild(card);
        return;
      }

      column.insertBefore(card, column.children[insertionIndex]);
    };

    const dealPhrasePair = (phrase) => {
      if (!phrase || !gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      const dutchCard = createGameCard(phrase, 'nl');
      const japaneseCard = createGameCard(phrase, 'ja');

      insertCardRandomly(dutchColumn, dutchCard);
      insertCardRandomly(japaneseColumn, japaneseCard);
    };

    const replenishBoard = () => {
      if (!gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      while (
        gameState.phraseQueue.length > 0 &&
        dutchColumn.childElementCount < MAX_VISIBLE_PAIRS &&
        japaneseColumn.childElementCount < MAX_VISIBLE_PAIRS
      ) {
        const nextPhrase = gameState.phraseQueue.shift();

        if (!nextPhrase) {
          break;
        }

        dealPhrasePair(nextPhrase);
      }
    };

    const resetGame = (announce = true) => {
      stopTimer({ resetToFull: true });
      gameState.stage = 0;
      gameState.score = 0;
      gameState.streak = 0;
      gameState.best = 0;
      gameState.matchesRemaining = 0;
      gameState.selection = [];
      gameState.busy = false;
      gameState.phraseQueue = [];
      gameState.columns = null;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;
      gameState.timeRemainingMs = TIME_LIMIT_MS;
      updateScoreboard();

      if (gameGrid) {
        rebuildGameColumns();
        gameGrid.removeAttribute('aria-busy');
      }

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å§‹ã‚ã‚‹';
      }

      if (announce) {
        setStatus(
          `ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å§‹ã‚ã¦åˆ¶é™æ™‚é–“${TIME_LIMIT_SECONDS}ç§’ä»¥å†…ã«ã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒƒãƒã•ã›ã¾ã—ã‚‡ã†ï¼ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ç™ºéŸ³ãŒæµã‚Œã¾ã™ã€‚`
        );
      }
    };

    const stageClearFeedback = () => {
      stopTimer();
      const remainingSeconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
      const timeBonus = Math.max(20, remainingSeconds * 2);
      gameState.score += timeBonus;
      updateScoreboard();
      pulseElement(scoreDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸';
      }

      setStatus(
        `âœ¨ ã‚¹ãƒ†ãƒ¼ã‚¸${gameState.stage}ã‚¯ãƒªã‚¢ï¼${gameState.correctMatches}çµ„æ­£è§£ã€ãƒŸã‚¹${gameState.mistakes}å›ã€‚æ®‹ã‚Š${remainingSeconds}ç§’ã§ãƒœãƒ¼ãƒŠã‚¹${timeBonus}ç‚¹ã‚’ç²å¾—ã—ãŸã‚ˆã€‚`
      );
    };

    let feedbackAudioContext = null;

    const ensureFeedbackAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!feedbackAudioContext) {
        try {
          feedbackAudioContext = new AudioContextClass();
        } catch (error) {
          feedbackAudioContext = null;
          return null;
        }
      }

      if (feedbackAudioContext.state === 'suspended') {
        feedbackAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return feedbackAudioContext;
    };

    const playMatchFeedbackTone = (isMatch) => {
      const context = ensureFeedbackAudioContext();

      if (!context) {
        return;
      }

      try {
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        const now = context.currentTime;

        oscillator.type = 'sine';

        if (isMatch) {
          oscillator.frequency.setValueAtTime(660, now);
          oscillator.frequency.exponentialRampToValueAtTime(990, now + 0.18);
        } else {
          oscillator.frequency.setValueAtTime(240, now);
          oscillator.frequency.exponentialRampToValueAtTime(180, now + 0.18);
        }

        gainNode.gain.setValueAtTime(0.0001, now);
        gainNode.gain.exponentialRampToValueAtTime(0.18, now + 0.04);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

        oscillator.connect(gainNode);
        gainNode.connect(context.destination);

        oscillator.start(now);
        oscillator.stop(now + 0.3);
      } catch (error) {
        /* noop */
      }
    };

    const evaluateSelection = ({ didSpeak = false } = {}) => {
      if (gameState.selection.length < 2) {
        return;
      }

      gameState.busy = true;

      const [first, second] = gameState.selection;
      const isMatch = first.pairId === second.pairId && first.lang !== second.lang;

      const setStatusWithCue = (message) => {
        setStatus(formatStatusWithSpeechCue(didSpeak, message));
      };

      if (isMatch) {
        playMatchFeedbackTone(true);
        const phrase = getPhraseById(first.pairId);
        const matchedCards = [first.card, second.card];

        matchedCards.forEach((card) => {
          card.classList.remove('is-selected');
          card.classList.add('is-matched', 'is-disabled');
        });

        gameState.matchesRemaining -= 1;
        gameState.streak += 1;
        gameState.correctMatches += 1;

        if (gameState.streak > gameState.best) {
          gameState.best = gameState.streak;
        }

        const gained = 10 + gameState.streak * 2;
        gameState.score += gained;
        updateScoreboard();
        pulseElement(scoreDisplay);
        pulseElement(streakDisplay);
        pulseElement(correctDisplay);

        if (phrase) {
          setStatusWithCue(
            `ğŸ‰ æ­£è§£ï¼${gameState.correctMatches}çµ„ç›®ã®ã€Œ${phrase.ja}ã€ã¨ã€Œ${phrase.nl}ã€ã§${gained}ç‚¹ã‚²ãƒƒãƒˆï¼`
          );
        } else {
          setStatusWithCue(
            `ğŸ‰ æ­£è§£ï¼${gameState.correctMatches}çµ„ç›®ã§${gained}ç‚¹ã‚²ãƒƒãƒˆï¼`
          );
        }

        gameState.selection = [];
        matchedCards.forEach((card) => {
          if (card && typeof card.remove === 'function') {
            card.remove();
          }
        });

        replenishBoard();

        gameState.busy = false;

        if (gameState.matchesRemaining === 0) {
          stageClearFeedback();
        }

        return;
      }

      playMatchFeedbackTone(false);
      gameState.mistakes += 1;
      const penalty = Math.max(5, 3 + gameState.stage * 2);

      if (penalty > 0) {
        gameState.score = Math.max(0, gameState.score - penalty);
      }

      gameState.streak = 0;
      updateScoreboard();
      pulseElement(streakDisplay);
      pulseElement(mistakesDisplay);

      if (penalty > 0) {
        pulseElement(scoreDisplay);
      }

      setStatusWithCue(
        penalty > 0
          ? `ğŸ˜… ãƒŸã‚¹${gameState.mistakes}å›ç›®ã€‚${penalty}ç‚¹æ¸›ç‚¹ã ã‘ã©ã€ã¾ã å·»ãè¿”ã›ã‚‹ã‚ˆï¼`
          : `ğŸ˜… ãƒŸã‚¹${gameState.mistakes}å›ç›®ã€‚æ¬¡ã¯å½“ã¦ã¦ã¿ã‚ˆã†ï¼`
      );

      const [firstCard, secondCard] = [first.card, second.card];

      setTimeout(() => {
        firstCard.classList.remove('is-selected');
        secondCard.classList.remove('is-selected');
        gameState.selection = [];
        gameState.busy = false;
      }, 700);
    };

    const handleCardSelection = (card) => {
      if (!card || gameState.busy || !gameState.roundActive) {
        return;
      }

      if (card.classList.contains('is-matched') || card.classList.contains('is-disabled')) {
        return;
      }

      const pairId = card.getAttribute('data-pair-id');
      const lang = card.getAttribute('data-lang');

      if (!pairId || !lang) {
        return;
      }

      const isAlreadySelected = card.classList.contains('is-selected');

      if (gameState.selection.length === 0) {
        const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
        gameState.selection.push({ card, pairId, lang });
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'ã‚‚ã†1æšé¸ã‚“ã§ãƒšã‚¢ã‚’ä½œã‚ã†ï¼'));
        return;
      }

      const [firstSelection] = gameState.selection;

      if (firstSelection.card === card) {
        card.classList.remove('is-selected');
        gameState.selection = [];
        setStatus(formatStatusWithSpeechCue(false, 'ã‚«ãƒ¼ãƒ‰ã‚’é¸ã³ç›´ã—ãŸã‚ˆã€‚'));
        return;
      }

      if (firstSelection.lang === lang) {
        const didSpeak = speakCardIfDutch({ lang, pairId });
        firstSelection.card.classList.remove('is-selected');
        gameState.selection = [{ card, pairId, lang }];
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'ã‚‚ã†1æšé¸ã‚“ã§ãƒšã‚¢ã‚’ä½œã‚ã†ï¼'));
        return;
      }

      const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
      gameState.selection.push({ card, pairId, lang });
      card.classList.add('is-selected');
      evaluateSelection({ didSpeak });
    };

    const startStage = () => {
      if (!gameGrid) {
        return;
      }

      stopTimer({ resetToFull: true });

      const nextStage = gameState.stage + 1;
      const pairCount = stagePairCount(nextStage);

      if (pairCount <= 0) {
        setStatus('ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­ã§ã™ã€‚å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
        return;
      }

      const availablePhrases = getAllPhrases();

      if (availablePhrases.length === 0) {
        setStatus('ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­ã§ã™ã€‚å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
        return;
      }

      const selectedPairs = shuffleArray(availablePhrases).slice(0, pairCount);

      gameGrid.setAttribute('aria-busy', 'true');

      const columns = rebuildGameColumns();

      if (!columns) {
        gameGrid.removeAttribute('aria-busy');
        return;
      }

      gameState.columns = columns;
      gameState.phraseQueue = [...selectedPairs];

      replenishBoard();

      gameGrid.removeAttribute('aria-busy');

      gameState.stage = nextStage;
      gameState.matchesRemaining = selectedPairs.length;
      gameState.selection = [];
      gameState.busy = false;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;

      if (startButton) {
        startButton.disabled = true;
        startButton.textContent = 'ãƒ—ãƒ¬ã‚¤ä¸­â€¦';
      }

      updateScoreboard();
      startTimer();
      setStatus(
        `ã‚¹ãƒ†ãƒ¼ã‚¸${gameState.stage}ã‚¹ã‚¿ãƒ¼ãƒˆï¼åˆ¶é™æ™‚é–“${TIME_LIMIT_SECONDS}ç§’ä»¥å†…ã«åŒã˜æ„å‘³ã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã­ã€‚ã‚ªãƒ©ãƒ³ãƒ€èªã‚«ãƒ¼ãƒ‰ã¯ã‚¿ãƒƒãƒ—ã§ç™ºéŸ³ãŒæµã‚Œã‚‹ã‚ˆã€‚`
      );
    };

    if (gameGrid) {
      gameGrid.addEventListener('click', (event) => {
        const mainButton = event.target.closest('.game-card-main');

        if (mainButton) {
          event.preventDefault();
          const card = mainButton.closest('.game-card');
          handleCardSelection(card);
        }
      });
    }

    if (startButton) {
      startButton.addEventListener('click', () => {
        if (startButton.disabled) {
          return;
        }

        startStage();
      });
    }

    if (resetButton) {
      resetButton.addEventListener('click', () => {
        resetGame();
        if (startButton) {
          startButton.focus();
        }
      });
    }

    resetGame();
  </script>

</body>
</html>
