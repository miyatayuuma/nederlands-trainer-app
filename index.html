<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NederLingo | 日本語⇔オランダ語フレーズ学習</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f7f7fb;
      --fg: #1f2933;
      --accent: #ff7a59;
      --accent-dark: #c24e31;
      --card-bg: #ffffff;
      --muted: #5f6c7b;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f172a;
        --fg: #e2e8f0;
        --card-bg: #16203a;
        --muted: #8ea4c4;
      }

      .speech-feedback {
        background: rgba(148, 163, 184, 0.12);
        border-color: rgba(148, 163, 184, 0.2);
      }
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Helvetica Neue", sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px 20px 16px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 4vw, 2.4rem);
      letter-spacing: 0.04em;
    }

    header p {
      margin: 12px auto 0;
      max-width: 720px;
      font-size: 1rem;
      color: var(--muted);
      line-height: 1.6;
    }

    main {
      flex: 1;
      width: min(960px, 92vw);
      margin: 0 auto 48px;
    }

    .main-container {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-switcher {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .mode-button {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(31, 41, 51, 0.12);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease-in-out, border 0.2s ease-in-out, color 0.2s ease-in-out;
    }

    .mode-button:hover,
    .mode-button:focus-visible {
      background: rgba(31, 41, 51, 0.08);
      border-color: rgba(31, 41, 51, 0.24);
      outline: none;
    }

    .mode-button[aria-selected="true"] {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
    }

    .mode-panel-group {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .mode-panel {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      border: 1px solid rgba(15, 23, 42, 0.05);
    }

    .setup-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .setup-list li {
      padding: 14px 16px;
      border-radius: 16px;
      background: rgba(255, 122, 89, 0.08);
      border: 1px dashed rgba(255, 122, 89, 0.4);
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .phrase-dutch {
      display: inline-block;
      font-weight: 600;
    }

    .phrase-note {
      display: block;
      margin-top: 4px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .phrase-actions {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid rgba(31, 41, 51, 0.16);
      background: rgba(31, 41, 51, 0.04);
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
    }

    .icon-button:hover,
    .icon-button:focus-visible {
      background: rgba(31, 41, 51, 0.1);
      border-color: rgba(31, 41, 51, 0.32);
      outline: none;
      transform: translateY(-1px);
    }

    .icon-button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
    }

    .icon-button.is-active,
    .icon-button.is-recording {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .speech-toolbar {
      position: sticky;
      top: 12px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 16px;
      border-radius: 16px;
      background: var(--card-bg);
      border: 1px solid rgba(15, 23, 42, 0.08);
      box-shadow: 0 16px 36px rgba(15, 23, 42, 0.12);
    }

    .speech-toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: stretch;
    }

    .speech-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 0.9rem;
      color: var(--muted);
      flex: 1 1 200px;
    }

    .speech-controls label {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-controls input[type="range"] {
      accent-color: var(--accent);
      min-width: 140px;
    }

    .speech-feedback {
      flex: 1 1 280px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.95rem;
      background: rgba(15, 23, 42, 0.05);
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(15, 23, 42, 0.08);
    }

    .speech-feedback-target {
      margin: 0;
      font-size: clamp(1.15rem, 2.8vw, 1.4rem);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .speech-feedback-live {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .speech-feedback-live[hidden] {
      display: none;
    }

    .speech-feedback-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.95rem;
    }

    .speech-feedback-text {
      font-weight: 600;
      color: var(--fg);
    }

    .speech-feedback-score {
      font-weight: 600;
      color: var(--fg);
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .speech-notice {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .intro-card p {
      margin-bottom: 16px;
      line-height: 1.7;
      color: var(--muted);
    }

    .phrase-browser {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .phrase-section-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .phrase-section-header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.7;
      font-size: 0.95rem;
    }

    .phrase-filter-form {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .filter-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .filter-field span {
      font-weight: 600;
      color: var(--fg);
    }

    .filter-field select {
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.02);
      font-size: 0.95rem;
      color: inherit;
    }

    .filter-field select:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-filter {
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 16px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(15, 23, 42, 0.02);
    }

    .tag-filter legend {
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .tag-filter-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .tag-chip {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .tag-chip input {
      position: absolute;
      opacity: 0;
      width: 1px;
      height: 1px;
      margin: 0;
      border: 0;
      padding: 0;
      clip: rect(0, 0, 0, 0);
    }

    .tag-chip span {
      display: inline-flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.05);
      font-size: 0.85rem;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      cursor: pointer;
    }

    .tag-chip input:checked + span {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .tag-chip input:focus-visible + span {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .tag-clear-button,
    .filter-reset-button {
      align-self: flex-start;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .tag-clear-button:hover,
    .tag-clear-button:focus-visible,
    .filter-reset-button:hover,
    .filter-reset-button:focus-visible {
      background: rgba(15, 23, 42, 0.08);
      border-color: rgba(15, 23, 42, 0.32);
      outline: none;
    }

    .filter-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .phrase-count {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .phrase-status {
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.05);
      border: 1px solid rgba(15, 23, 42, 0.1);
      font-size: 0.9rem;
      color: var(--muted);
    }

    .scenario-list {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .scenario-card {
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 18px;
      padding: 20px 20px 24px;
      background: var(--card-bg);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
    }

    .scenario-card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .scenario-card-header h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .scenario-count {
      font-size: 0.85rem;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.08);
    }

    .scenario-note {
      margin: 0 0 16px;
      color: var(--muted);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .scenario-category + .scenario-category {
      margin-top: 20px;
    }

    .scenario-category h4 {
      margin: 0 0 12px;
      font-size: 1.05rem;
    }

    .phrase-meta {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .phrase-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: rgba(15, 23, 42, 0.1);
      color: var(--muted);
    }

    .phrase-badge-level {
      background: rgba(255, 122, 89, 0.18);
      color: var(--accent-dark);
    }

    .phrase-badge-tag {
      background: rgba(15, 23, 42, 0.08);
    }

    .is-hidden {
      display: none !important;
    }

    .game-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .game-intro p {
      margin: 0;
      line-height: 1.6;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .game-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      align-items: center;
    }

    .game-meta .meta-box {
      border-radius: 14px;
      background: rgba(31, 41, 51, 0.06);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .meta-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .meta-value {
      font-size: 1.35rem;
      font-weight: 700;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .meta-value small {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--muted);
    }

    .meta-box-timer {
      gap: 8px;
    }

    .countdown-bar {
      position: relative;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(31, 41, 51, 0.12);
      overflow: hidden;
    }

    .countdown-bar-fill {
      width: 100%;
      height: 100%;
      background: var(--accent);
      transform-origin: left center;
      transition: width 120ms linear, background 180ms ease-in-out;
    }

    .countdown-bar-fill.is-warning {
      background: #f59e0b;
    }

    .countdown-bar-fill.is-danger {
      background: #ef4444;
    }

    .game-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .game-button {
      padding: 10px 18px;
      border-radius: 12px;
      border: none;
      font-size: 0.95rem;
      cursor: pointer;
      background: var(--accent);
      color: #ffffff;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    .game-button:hover,
    .game-button:focus-visible {
      background: var(--accent-dark);
      transform: translateY(-1px);
      outline: none;
    }

    .game-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .game-button.secondary {
      background: rgba(31, 41, 51, 0.08);
      color: var(--fg);
    }

    .game-status {
      min-height: 1.4em;
      font-size: 0.95rem;
      color: var(--fg);
    }

    .game-card-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 20px;
      align-items: start;
    }

    .game-card-column {
      display: grid;
      grid-template-rows: repeat(5, minmax(0, auto));
      gap: 12px;
    }

    .game-card {
      position: relative;
      border-radius: 16px;
      padding: 6px;
      background: var(--card-bg);
      border: 2px solid transparent;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      transition: transform 0.18s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .game-card[data-lang="ja"] {
      background: linear-gradient(135deg, rgba(255, 225, 215, 0.45), rgba(255, 255, 255, 0.8));
    }

    .game-card[data-lang="nl"] {
      background: linear-gradient(135deg, rgba(210, 230, 255, 0.4), rgba(255, 255, 255, 0.85));
    }

    .game-card-main {
      width: 100%;
      min-height: 68px;
      border: none;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.35;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .game-card-text {
      display: block;
      line-height: 1.4;
    }

    .game-card[data-lang="nl"] .game-card-main {
      font-size: 1rem;
    }

    .game-card-main:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .game-card.is-selected {
      border-color: var(--accent);
      transform: translateY(-4px);
    }

    .game-card.is-matched {
      border-color: var(--accent);
      animation: cardMatch 520ms ease;
      box-shadow: 0 16px 32px rgba(255, 122, 89, 0.32);
    }

    .game-card.is-disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    .score-pulse {
      animation: scorePulse 420ms ease;
    }

    @keyframes scorePulse {
      0% {
        transform: scale(1);
      }

      40% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
      }
    }

    @keyframes cardMatch {
      0% {
        transform: scale(0.96);
      }

      60% {
        transform: scale(1.08);
      }

      100% {
        transform: scale(1);
      }
    }

    .phrase-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.02);
    }

    .phrase-table th,
    .phrase-table td {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      text-align: left;
      vertical-align: top;
    }

    .phrase-table thead th {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .phrase-table tbody tr:last-child td {
      border-bottom: none;
    }

    .phrase-table td strong {
      display: block;
      font-size: 1rem;
    }

    @media (max-width: 640px) {
      .game-meta {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

      .game-card-grid {
        gap: 16px;
      }

      .game-card-column {
        gap: 10px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 60px;
        padding: 10px 8px;
        font-size: 0.95rem;
      }

      .phrase-table thead {
        display: none;
      }

      .phrase-table,
      .phrase-table tbody,
      .phrase-table tr,
      .phrase-table td {
        display: block;
        width: 100%;
      }

      .phrase-table tr {
        padding: 12px 0;
        border-bottom: 1px solid rgba(96, 110, 133, 0.18);
      }

      .phrase-table tbody tr:last-child {
        border-bottom: none;
      }

      .phrase-table td {
        border: none;
        padding: 6px 0;
      }

      .phrase-table td::before {
        content: attr(data-label);
        display: block;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .phrase-actions {
        margin-top: 10px;
      }

      .icon-button {
        width: 34px;
        height: 34px;
      }
    }

    @media (max-width: 480px) {
      .game-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .game-card-grid {
        gap: 14px;
      }

      .game-card-column {
        gap: 8px;
      }

      .game-card {
        padding: 4px;
      }

      .game-card-main {
        min-height: 56px;
        font-size: 0.95rem;
      }
    }

    [hidden] {
      display: none !important;
    }

    footer {
      text-align: center;
      padding: 24px 16px 32px;
      font-size: 0.85rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>NederLingo</h1>
    <p>
      日本語とオランダ語のフレーズ練習を、目的に合わせて切り替えられるマルチモード学習体験にアップデートしました。
    </p>
    <p>
      落ち着いて発音や意味を確認できる「フレーズ学習モード」と、今後公開予定の対戦要素を備えた「フレーズチャレンジモード」を切り替えて、自分に合ったリズムで学びましょう。
    </p>
  </header>

  <main>
    <div class="main-container" data-active-mode="study">
      <div class="mode-switcher" role="tablist" aria-label="学習モードの選択">
        <button
          id="mode-tab-study"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-study"
          aria-selected="true"
          data-mode="study"
        >
          フレーズ学習モード
        </button>
        <button
          id="mode-tab-game"
          class="mode-button"
          type="button"
          role="tab"
          aria-controls="mode-panel-game"
          aria-selected="false"
          tabindex="-1"
          data-mode="game"
        >
          フレーズチャレンジモード
        </button>
      </div>

      <div class="mode-panel-group">
        <section
          id="mode-panel-study"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-study"
          aria-hidden="false"
          data-mode-panel="study"
        >
          <section class="card intro-card">
            <h2>旅のシナリオに合わせて学ぶ</h2>
            <p>
              長期滞在の旅行者が直面するシチュエーションを想定し、日常会話から空港・交通、宿泊、食事、観光、ショッピング、緊急対応まで58フレーズを整理しました。音声の再生と発話トレーニングを活用して、滞在中に必要な表現を実践的に身につけましょう。
            </p>
            <ul class="setup-list">
              <li>日常・移動・宿泊・食事・観光・緊急の7シナリオをカバー</li>
              <li>シナリオ・レベル・タグによる柔軟なフィルターと並び替え</li>
              <li>全フレーズで音声再生とマイクによる発話チェックが可能</li>
            </ul>
          </section>

          <section class="speech-toolbar" aria-label="音声サポート">
            <div class="speech-toolbar-row">
              <div class="speech-controls">
                <label for="speech-rate">再生速度 <span id="speech-rate-value">1.0x</span></label>
                <input
                  type="range"
                  id="speech-rate"
                  name="speech-rate"
                  min="0.6"
                  max="1.4"
                  step="0.1"
                  value="1"
                >
              </div>
              <div id="speech-feedback" class="speech-feedback" aria-live="polite">
                <p id="recognition-target" class="speech-feedback-target">-</p>
                <p id="recognition-live" class="speech-feedback-live" hidden>
                  <span class="speech-feedback-icon" aria-hidden="true">🎙</span>
                  <span id="recognition-text" class="speech-feedback-text">-</span>
                  <span id="recognition-score" class="speech-feedback-score">-</span>
                </p>
                <span id="recognition-status" class="visually-hidden">録音待機中です。</span>
              </div>
            </div>
            <p id="speech-recognition-notice" class="speech-notice is-hidden" aria-live="polite"></p>
          </section>
          <section class="card phrase-browser">
            <div class="phrase-section-header">
              <h2>シナリオ別フレーズ</h2>
              <p>
                空港、交通、宿泊、食事、観光、ショッピング、緊急時などマルチウィーク滞在で出会う場面をカバーしています。シナリオやレベル、興味のあるタグで絞り込み、必要なフレーズから重点的に練習しましょう。
              </p>
            </div>
            <form id="phrase-filter-form" class="phrase-filter-form" autocomplete="off">
              <div class="filter-grid">
                <label class="filter-field">
                  <span>シナリオ</span>
                  <select id="filter-scenario" name="scenario"></select>
                </label>
                <label class="filter-field">
                  <span>レベル</span>
                  <select id="filter-level" name="level"></select>
                </label>
                <label class="filter-field">
                  <span>並び順</span>
                  <select id="filter-sort" name="sort"></select>
                </label>
              </div>
              <fieldset class="tag-filter">
                <legend>タグで絞り込む</legend>
                <div id="tag-filter-options" class="tag-filter-options"></div>
                <button type="button" id="tag-clear-button" class="tag-clear-button">タグをクリア</button>
              </fieldset>
              <div class="filter-footer">
                <span id="phrase-count" class="phrase-count" aria-live="polite">- 件のフレーズ</span>
                <button type="reset" class="filter-reset-button">条件をリセット</button>
              </div>
            </form>
            <div id="phrase-loading" class="phrase-status" role="status" aria-live="polite">
              フレーズデータを読み込んでいます…
            </div>
            <div id="phrase-error" class="phrase-status is-hidden" role="status" aria-live="polite"></div>
            <div id="phrase-empty" class="phrase-status is-hidden" role="status" aria-live="polite">
              条件に一致するフレーズが見つかりませんでした。
            </div>
            <div id="study-content" class="scenario-list" aria-live="polite"></div>
          </section>
        </section>

        <section
          id="mode-panel-game"
          class="mode-panel"
          role="tabpanel"
          aria-labelledby="mode-tab-game"
          data-mode-panel="game"
          hidden
          aria-hidden="true"
        >
          <section class="card game-section">
            <div class="game-intro">
              <h2>フレーズチャレンジモード</h2>
              <p>
                日本語カードとオランダ語カードをタップしてペアを見つける、テンポの良いマッチングゲームです。耳と目を同時に使いながら、短時間で何度も遊んでみましょう。
              </p>
            </div>
            <div class="game-meta">
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Stage</span>
                <span class="meta-value">
                  <span id="game-stage">0</span><small>段</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">Score</span>
                <span class="meta-value">
                  <span id="game-score">0</span><small>pt</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">連続正解</span>
                <span class="meta-value">
                  <span id="game-streak">0</span><small id="game-best">BEST 0</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">正解数</span>
                <span class="meta-value">
                  <span id="game-correct">0</span><small>組</small>
                </span>
              </div>
              <div class="meta-box" aria-live="polite">
                <span class="meta-label">ミス</span>
                <span class="meta-value">
                  <span id="game-mistakes">0</span><small>回</small>
                </span>
              </div>
              <div class="meta-box meta-box-timer" aria-live="polite">
                <span class="meta-label">残り時間</span>
                <span class="meta-value">
                  <span id="game-time">60</span><small>秒</small>
                </span>
                <div class="countdown-bar" role="presentation" aria-hidden="true">
                  <div id="game-timer-fill" class="countdown-bar-fill"></div>
                </div>
              </div>
            </div>
            <div class="game-controls">
              <button id="game-start-button" class="game-button" type="button">ステージを始める</button>
              <button id="game-reset-button" class="game-button secondary" type="button">スコアをリセット</button>
            </div>
            <p id="game-status" class="game-status" aria-live="polite">ステージを始めて制限時間60秒以内にカードをマッチさせましょう！</p>
            <p id="game-speech-instruction" class="visually-hidden">
              オランダ語カードはタップすると発音が再生されます。音声のヒントを聞きながら対応する日本語カードを探してみましょう。
            </p>
            <div
              id="game-grid"
              class="game-card-grid"
              aria-label="日本語とオランダ語のカードをマッチさせるグリッド"
              aria-describedby="game-speech-instruction"
              aria-live="polite"
            ></div>
          </section>
        </section>
      </div>
    </div>
  </main>

  <footer>
    &copy; 2024 NederLingo. All rights reserved.
  </footer>

  <script type="application/json" id="embedded-phrases">
    {
      "phrases": [
        {
          "id": "greet-morning",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["あいさつ", "丁寧"],
          "ja": "おはようございます。",
          "nl": "Goedemorgen.",
          "hint": "フーデモルヘン /ɣudəˈmɔr.ɣə(n)/",
          "note": "丁寧な朝の挨拶",
          "featured": true
        },
        {
          "id": "greet-day",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["あいさつ"],
          "ja": "こんにちは。",
          "nl": "Goedemiddag.",
          "hint": "フーデミダフ /ɣudəˈmɪdɑx/",
          "note": "日中の挨拶"
        },
        {
          "id": "greet-evening",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["あいさつ", "夕方"],
          "ja": "こんばんは。",
          "nl": "Goedenavond.",
          "hint": "フーデナーフォント /ɣudəˈnaːvɔnt/",
          "note": "夕方以降の挨拶"
        },
        {
          "id": "greet-meet",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["自己紹介", "初対面"],
          "ja": "はじめまして。",
          "nl": "Aangenaam.",
          "hint": "アーネナーム /ˈaːŋɣənaːm/",
          "note": "初対面の挨拶"
        },
        {
          "id": "greet-bye",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["あいさつ", "別れ"],
          "ja": "さようなら。",
          "nl": "Tot ziens.",
          "hint": "トッツィンス /tɔt ˈzins/",
          "note": "丁寧な別れの挨拶"
        },
        {
          "id": "greet-later",
          "category": "挨拶",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["別れ", "カジュアル"],
          "ja": "また後でね。",
          "nl": "Tot later.",
          "hint": "トト ラーテル /tɔt ˈlaːtər/",
          "note": "カジュアルな別れ"
        },
        {
          "id": "intro-from",
          "category": "自己紹介",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["自己紹介", "出身"],
          "ja": "日本から来ました。",
          "nl": "Ik kom uit Japan.",
          "hint": "イク コム アウト ヤパン /ɪk kɔm œy̯t jɑˈpɑn/",
          "note": "出身地を伝える"
        },
        {
          "id": "intro-length",
          "category": "自己紹介",
          "scenario": ["日常会話", "宿泊"],
          "level": ["A2"],
          "tags": ["滞在計画", "長期滞在"],
          "ja": "数週間滞在する予定です。",
          "nl": "Ik blijf een paar weken.",
          "hint": "イク ブライフ エーン パール ヴェーケン /ɪk blɛi̯f eːn paːr ˈʋeːkə(n)/",
          "note": "滞在期間を伝える"
        },
        {
          "id": "smalltalk-weather",
          "category": "世間話",
          "scenario": ["日常会話", "観光"],
          "level": ["A1"],
          "tags": ["天気", "会話"],
          "ja": "今日は良い天気ですね。",
          "nl": "Het is mooi weer vandaag.",
          "hint": "ヘット イス モイ ウェーア ファンダーフ /ɦɛt ɪs mɔi̯ ʋeːr fɑnˈdaːx/",
          "note": "天気の話題"
        },
        {
          "id": "smalltalk-plan",
          "category": "世間話",
          "scenario": ["日常会話", "観光"],
          "level": ["A2"],
          "tags": ["計画", "会話"],
          "ja": "明日はどこを訪れる予定ですか？",
          "nl": "Waar gaat u morgen naartoe?",
          "hint": "ワール ハートゥー モルヘン ナールトー /ʋaːr ɣaːt y ˈmɔrɣə(n) naːrˈtoː/",
          "note": "旅行計画を尋ねる"
        },
        {
          "id": "polite-thanks",
          "category": "基本表現",
          "scenario": ["日常会話"],
          "level": ["A1"],
          "tags": ["感謝", "丁寧"],
          "ja": "ありがとうございます。",
          "nl": "Dank u wel.",
          "hint": "ダンク ウ ヴェル /dɑŋk y ʋɛl/",
          "note": "丁寧な感謝",
          "featured": true
        },
        {
          "id": "polite-sorry",
          "category": "基本表現",
          "scenario": ["日常会話", "交通"],
          "level": ["A1"],
          "tags": ["謝罪", "丁寧"],
          "ja": "すみません。",
          "nl": "Pardon.",
          "hint": "パルドン /ˈpɑr.dɔn/",
          "note": "軽い謝罪",
          "featured": true
        },
        {
          "id": "request-repeat",
          "category": "基本表現",
          "scenario": ["日常会話", "交通"],
          "level": ["A1"],
          "tags": ["聞き返す", "丁寧"],
          "ja": "もう一度ゆっくり言っていただけますか？",
          "nl": "Kunt u het nog eens langzaam zeggen?",
          "hint": "クントゥー ヘット ノッホ エース ラングザーム ゼッヘン /kʏnt y ɦət nɔx eːs ˈlɑŋ.zaːm ˈzɛɣə(n)/",
          "note": "聞き返す"
        },
        {
          "id": "airport-checkin",
          "category": "チェックイン",
          "scenario": ["空港"],
          "level": ["A1"],
          "tags": ["搭乗", "手続き"],
          "ja": "チェックインをお願いします。",
          "nl": "Ik wil graag inchecken.",
          "hint": "イク ヴィル フラーフ インチェッケン /ɪk ʋɪl ɣraːx ˈɪnˌtʃɛkə(n)/",
          "note": "空港での手続き",
          "featured": true
        },
        {
          "id": "airport-baggage",
          "category": "手荷物",
          "scenario": ["空港"],
          "level": ["A2"],
          "tags": ["荷物", "カウンター"],
          "ja": "預け入れ荷物はどこで預けますか？",
          "nl": "Waar kan ik mijn ruimbagage afgeven?",
          "hint": "ワール カン イク メイン ロイムバハーフェ アフゲーフェン /ʋaːr kɑn ɪk mɛi̯n ˈrœy̯m.baːˌɣaːɦə ˈɑfˌɣeːvə(n)/",
          "note": "手荷物カウンターを尋ねる"
        },
        {
          "id": "airport-security",
          "category": "セキュリティ",
          "scenario": ["空港"],
          "level": ["A2"],
          "tags": ["荷物", "ルール"],
          "ja": "液体は機内持ち込みできますか？",
          "nl": "Mag ik vloeistoffen in mijn handbagage meenemen?",
          "hint": "マッ フロイストッフェン イン メイン ハンドバハーフェ メーネーメン /mɑx fˈlʏi̯.stɔ.fə(n) ɪn mɛi̯n ˈɦɑnd.baːˌɣaːɦə ˈmeːˌneːmə(n)/",
          "note": "持ち込み制限を確認"
        },
        {
          "id": "airport-immigration",
          "category": "入国審査",
          "scenario": ["空港"],
          "level": ["A2"],
          "tags": ["入国審査", "目的"],
          "ja": "観光で来ました。",
          "nl": "Ik ben hier voor toerisme.",
          "hint": "イク ベン ヒール フォール トゥーリスム /ɪk bɛn ɦiːr foːr tuːˈrɪ.smə/",
          "note": "入国目的を伝える"
        },
        {
          "id": "airport-transfer",
          "category": "乗り継ぎ",
          "scenario": ["空港", "交通"],
          "level": ["A2"],
          "tags": ["乗り継ぎ", "時間"],
          "ja": "次のゲートまではどれくらい時間がありますか？",
          "nl": "Hoeveel tijd is er tot de volgende gate?",
          "hint": "フーフェール タイト イス エル トット デ フォルヘンダ ゲート /ˈɦuː.veːl tɛi̯t ɪs ɛr tɔt də ˈvɔl.ɣəndə ɣeːt/",
          "note": "乗り継ぎ時間を確認"
        },
        {
          "id": "travel-station",
          "category": "鉄道",
          "scenario": ["交通"],
          "level": ["A1"],
          "tags": ["道案内", "鉄道"],
          "ja": "駅はどこですか？",
          "nl": "Waar is het station?",
          "hint": "ワール イス ヘット スタシオン /ʋaːr ɪs ɦət stɑˈʃɔn/",
          "note": "駅の場所を尋ねる",
          "featured": true
        },
        {
          "id": "travel-train",
          "category": "鉄道",
          "scenario": ["交通"],
          "level": ["A2"],
          "tags": ["列車", "行き先"],
          "ja": "この列車はアムステルダム行きですか？",
          "nl": "Gaat deze trein naar Amsterdam?",
          "hint": "ハート デーゼ トライン ナール アムステルダム /ɣaːt ˈdeːzə trɛi̯n naːr ˌɑmstərˈdɑm/",
          "note": "列車の行き先を確認"
        },
        {
          "id": "travel-ticket",
          "category": "鉄道",
          "scenario": ["交通"],
          "level": ["A1"],
          "tags": ["切符", "購入"],
          "ja": "切符を2枚ください。",
          "nl": "Mag ik twee kaartjes alstublieft?",
          "hint": "マッ フィック トゥウェー カールチェス アルストュブリーフト /mɑx ɪk tveː ˈkaːr.cəs ˌɑlstʏˈblift/",
          "note": "切符を購入"
        },
        {
          "id": "transport-daypass",
          "category": "鉄道",
          "scenario": ["交通"],
          "level": ["A2"],
          "tags": ["切符", "お得"],
          "ja": "1日乗り放題券はありますか？",
          "nl": "Heeft u een dagkaart?",
          "hint": "ヘーフトゥー ウン ダフカールト /ɦeːft y ʏn ˈdɑx.kaːrt/",
          "note": "1日券を尋ねる"
        },
        {
          "id": "transport-bus",
          "category": "バス",
          "scenario": ["交通"],
          "level": ["A1"],
          "tags": ["バス", "時刻"],
          "ja": "空港行きのバスは何番乗り場ですか？",
          "nl": "Vanaf welke halte vertrekt de bus naar het vliegveld?",
          "hint": "ファナフ フェルケ ハルテ フェルトレクト デ バス ナール ヘット フリーフフェルト /fɑˈnɑf ˈʋɛl.kə ˈɦɑl.tə vərˈtrɛkt də bʏs naːr ɦət ˈvliːx.fɛlt/",
          "note": "バス乗り場を確認"
        },
        {
          "id": "transport-taxi",
          "category": "タクシー",
          "scenario": ["交通"],
          "level": ["A1", "A2"],
          "tags": ["タクシー", "料金"],
          "ja": "中央駅までいくらかかりますか？",
          "nl": "Hoeveel kost het naar het centraal station?",
          "hint": "フーフェール コストゥ ヘット ナール ヘット セントラール スタシオン /ˈɦuː.veːl kɔst ɦət naːr ɦət sɛnˈtraːl stɑˈʃɔn/",
          "note": "タクシー料金を確認"
        },
        {
          "id": "transport-bike",
          "category": "レンタル",
          "scenario": ["交通", "観光"],
          "level": ["A2"],
          "tags": ["レンタサイクル", "予約"],
          "ja": "自転車を1週間レンタルできますか？",
          "nl": "Kan ik een fiets voor een week huren?",
          "hint": "カン イク エーン フィーツ フォール エーン ヴェーク ヒューレン /kɑn ɪk eːn fits foːr eːn ʋeːk ˈhyː.rə(n)/",
          "note": "自転車レンタルを依頼"
        },
        {
          "id": "lodging-checkin",
          "category": "チェックイン",
          "scenario": ["宿泊"],
          "level": ["A1"],
          "tags": ["ホテル", "到着"],
          "ja": "予約している田中です。",
          "nl": "Ik heb gereserveerd op de naam Tanaka.",
          "hint": "イク ヘップ ヘレゼルフェールト オプ デ ナーム タナカ /ɪk ɦɛb ɣəˌreː.zərˈveːrt ɔp də naːm tɑˈnaːka/",
          "note": "予約を伝える"
        },
        {
          "id": "lodging-latecheckout",
          "category": "滞在中",
          "scenario": ["宿泊"],
          "level": ["A2"],
          "tags": ["ホテル", "時間"],
          "ja": "レイトチェックアウトは可能ですか？",
          "nl": "Is een late check-out mogelijk?",
          "hint": "イス エーン ラーテ チェックアウト モーフェリク /ɪs eːn ˈlaː.tə tʃɛkˈɑʊt ˈmoːxə.lək/",
          "note": "チェックアウト時間を確認"
        },
        {
          "id": "lodging-breakfast",
          "category": "滞在中",
          "scenario": ["宿泊", "食事"],
          "level": ["A1"],
          "tags": ["朝食", "営業時間"],
          "ja": "朝食は何時からですか？",
          "nl": "Hoe laat is het ontbijt?",
          "hint": "フー ラート イス ヘット オントバイスト /ˈɦuː laːt ɪs ɦət ɔntˈbɑi̯t/",
          "note": "朝食の時間を確認"
        },
        {
          "id": "lodging-laundry",
          "category": "滞在中",
          "scenario": ["宿泊", "日常会話"],
          "level": ["A2"],
          "tags": ["ランドリー", "サービス"],
          "ja": "ランドリーサービスはありますか？",
          "nl": "Heeft u een wasservice?",
          "hint": "ヘーフトゥー ウン ヴァッセールヴィス /ɦeːft y ʏn ˈʋɑs.sɛr.ʋəs/",
          "note": "洗濯サービスを尋ねる"
        },
        {
          "id": "lodging-wifi",
          "category": "滞在中",
          "scenario": ["宿泊", "日常会話"],
          "level": ["A1"],
          "tags": ["Wi-Fi", "接続"],
          "ja": "Wi-Fiのパスワードを教えてください。",
          "nl": "Kunt u het Wi-Fi wachtwoord geven?",
          "hint": "クントゥー ヘット ワイファイ ワフトヴォールド ヘーフェン /kʏnt y ɦət ˈʋiː.faɪ̯ ˈʋɑxt.ʋoːrt ˈɣeːvə(n)/",
          "note": "Wi-Fiパスワードを尋ねる"
        },
        {
          "id": "lodging-maintenance",
          "category": "滞在中",
          "scenario": ["宿泊"],
          "level": ["A2", "B1"],
          "tags": ["設備", "トラブル"],
          "ja": "シャワーのお湯が出ません。",
          "nl": "Er komt geen warm water uit de douche.",
          "hint": "エル コムト ヘーン ワルム ワーテル アウト デ ドウシェ /ɛr kɔmt ɣeːn ʋɑrm ˈʋaːtər œy̯t də ˈduʃə/",
          "note": "設備の不具合を伝える"
        },
        {
          "id": "dining-reservation",
          "category": "予約",
          "scenario": ["食事"],
          "level": ["A2"],
          "tags": ["レストラン", "予約"],
          "ja": "2名で19時に予約できますか？",
          "nl": "Kan ik voor twee personen om zeven uur reserveren?",
          "hint": "カン イク フォール トゥウェー ペルソーネン オム ゼーフェン ウール レゼルフェーレン /kɑn ɪk foːr tveː pɛrˈsoːnə(n) ɔm ˈzeː.və(n) uːr rɛzərˈveːrə(n)/",
          "note": "レストラン予約をする"
        },
        {
          "id": "dining-seat",
          "category": "入店",
          "scenario": ["食事"],
          "level": ["A1"],
          "tags": ["席", "入店"],
          "ja": "テラス席は空いていますか？",
          "nl": "Is er een plek op het terras vrij?",
          "hint": "イス エル エーン プレック オプ ヘット テラス フライ /ɪs ɛr eːn plɛk ɔp ɦət təˈrɑs vrɛi̯/",
          "note": "席の空きを尋ねる"
        },
        {
          "id": "dining-allergy",
          "category": "注文",
          "scenario": ["食事", "緊急"],
          "level": ["A2"],
          "tags": ["アレルギー", "健康"],
          "ja": "ナッツアレルギーがあります。",
          "nl": "Ik heb een notenallergie.",
          "hint": "イク ヘップ エーン ノーテンアレルヒー /ɪk ɦɛb eːn ˈnoː.tə(n).aˌlɛrˈɣi/",
          "note": "アレルギーを伝える"
        },
        {
          "id": "dining-vegetarian",
          "category": "注文",
          "scenario": ["食事"],
          "level": ["A2"],
          "tags": ["ベジタリアン", "食事制限"],
          "ja": "ベジタリアン向けの料理はありますか？",
          "nl": "Heeft u vegetarische gerechten?",
          "hint": "ヘーフトゥー フェヘタリッセ ヘレフテン /ɦeːft y veː.xeːˈtaː.rɪ.sə ɣəˈrɛx.tə(n)/",
          "note": "食事制限を伝える"
        },
        {
          "id": "dining-recommend",
          "category": "注文",
          "scenario": ["食事", "観光"],
          "level": ["A1"],
          "tags": ["おすすめ", "店員会話"],
          "ja": "おすすめの料理は何ですか？",
          "nl": "Wat raadt u aan?",
          "hint": "ワット ラートゥー アーン /ʋɑt raːt y aːn/",
          "note": "おすすめを尋ねる"
        },
        {
          "id": "dining-bill",
          "category": "会計",
          "scenario": ["食事"],
          "level": ["A1"],
          "tags": ["会計", "丁寧"],
          "ja": "お会計をお願いします。",
          "nl": "Mag ik de rekening, alstublieft?",
          "hint": "マッ イク デ レーケニング アルストュブリーフト /mɑx ɪk də ˈreː.kə.nɪŋ ˌɑlstʏˈblift/",
          "note": "会計を依頼"
        },
        {
          "id": "dining-split",
          "category": "会計",
          "scenario": ["食事", "日常会話"],
          "level": ["A2"],
          "tags": ["会計", "割り勘"],
          "ja": "支払いを別々にしていただけますか？",
          "nl": "Kunnen we apart betalen?",
          "hint": "クヌン ヴェ アパルト ベターレン /ˈkʏ.nə(n) ʋə ɑˈpɑrt bəˈtaː.lə(n)/",
          "note": "割り勘をお願いする"
        },
        {
          "id": "dining-water",
          "category": "注文",
          "scenario": ["食事"],
          "level": ["A1"],
          "tags": ["飲み物"],
          "ja": "水を一緒にいただけますか？",
          "nl": "Mag ik er wat water bij?",
          "hint": "マッ イク エル ワット ワーテル ベイ /mɑx ɪk ɛr ʋɑt ˈʋaː.tər bɛi̯/",
          "note": "水を頼む"
        },
        {
          "id": "sightseeing-hours",
          "category": "観光案内",
          "scenario": ["観光"],
          "level": ["A1"],
          "tags": ["営業時間", "観光案内"],
          "ja": "美術館は何時まで開いていますか？",
          "nl": "Tot hoe laat is het museum open?",
          "hint": "トット フー ラート イス ヘット ミュゼウム オーペン /tɔt ˈɦuː laːt ɪs ɦət myːˈzeː.ʏm ˈoː.pə(n)/",
          "note": "営業時間を尋ねる"
        },
        {
          "id": "sightseeing-ticket",
          "category": "観光案内",
          "scenario": ["観光"],
          "level": ["A1"],
          "tags": ["チケット", "観光案内"],
          "ja": "ガイドツアーのチケットはどこで買えますか？",
          "nl": "Waar kan ik tickets voor de rondleiding kopen?",
          "hint": "ワール カン イク チケッツ フォール デ ロントレイディング コーペン /ʋaːr kɑn ɪk ˈtɪ.kəts foːr də ˈrɔntˌlɛi̯.dɪŋ ˈkoː.pə(n)/",
          "note": "チケット購入場所を尋ねる"
        },
        {
          "id": "sightseeing-guide",
          "category": "観光案内",
          "scenario": ["観光"],
          "level": ["A2"],
          "tags": ["ガイド", "予約"],
          "ja": "日本語ガイドはありますか？",
          "nl": "Is er een rondleiding in het Japans?",
          "hint": "イス エル エーン ロントレイディング イン ヘット ヤパンス /ɪs ɛr eːn ˈrɔntˌlɛi̯.dɪŋ ɪn ɦət jaːˈpɑns/",
          "note": "日本語ガイドを尋ねる"
        },
        {
          "id": "sightseeing-direction",
          "category": "道案内",
          "scenario": ["観光", "交通"],
          "level": ["A1"],
          "tags": ["道案内"],
          "ja": "この地図で現在地を教えてもらえますか？",
          "nl": "Kunt u op deze kaart laten zien waar we zijn?",
          "hint": "クントゥー オプ デーゼ カールト ラーテン ゼーン ワール ヴェ ザイン /kʏnt y ɔp ˈdeː.zə kaːrt ˈlaː.tə(n) zeːn ʋaːr ʋə zɛi̯n/",
          "note": "地図で道案内をお願い"
        },
        {
          "id": "sightseeing-photo",
          "category": "交流",
          "scenario": ["観光", "日常会話"],
          "level": ["A1"],
          "tags": ["写真", "丁寧"],
          "ja": "写真を撮っていただけますか？",
          "nl": "Kunt u een foto van ons nemen?",
          "hint": "クントゥー エーン フォト ファン オンス ネーメン /kʏnt y eːn ˈfoː.toː fɑn ɔns ˈneːmə(n)/",
          "note": "写真撮影をお願い"
        },
        {
          "id": "shopping-price",
          "category": "購入",
          "scenario": ["ショッピング"],
          "level": ["A1"],
          "tags": ["価格", "買い物"],
          "ja": "これはいくらですか？",
          "nl": "Hoeveel kost dit?",
          "hint": "フーフェール コストゥ ディット /ˈɦuː.veːl kɔst dɪt/",
          "note": "値段を尋ねる"
        },
        {
          "id": "shopping-size",
          "category": "購入",
          "scenario": ["ショッピング"],
          "level": ["A1"],
          "tags": ["サイズ", "衣類"],
          "ja": "別のサイズはありますか？",
          "nl": "Heeft u een andere maat?",
          "hint": "ヘーフトゥー ウン アンデレ マート /ɦeːft y ʏn ˈɑn.də.rə maːt/",
          "note": "サイズ違いを尋ねる"
        },
        {
          "id": "shopping-tryon",
          "category": "購入",
          "scenario": ["ショッピング"],
          "level": ["A1", "A2"],
          "tags": ["試着", "衣類"],
          "ja": "試着してもいいですか？",
          "nl": "Mag ik het passen?",
          "hint": "マッ イク ヘット パッセン /mɑx ɪk ɦət ˈpɑ.sə(n)/",
          "note": "試着の許可を求める"
        },
        {
          "id": "shopping-taxfree",
          "category": "支払い",
          "scenario": ["ショッピング", "空港"],
          "level": ["A2"],
          "tags": ["免税", "書類"],
          "ja": "免税手続きはできますか？",
          "nl": "Kunt u taxfree regelen?",
          "hint": "クントゥー タックスフリー レーヘレン /kʏnt y ˈtɑks.friː ˈreː.ɣə.lə(n)/",
          "note": "免税手続きを尋ねる"
        },
        {
          "id": "shopping-card",
          "category": "支払い",
          "scenario": ["ショッピング"],
          "level": ["A1"],
          "tags": ["支払い", "カード"],
          "ja": "クレジットカードは使えますか？",
          "nl": "Kan ik met creditcard betalen?",
          "hint": "カン イク メット クレディットカード ベターレン /kɑn ɪk mɛt ˈkrɛ.dɪtˌkaːrt bəˈtaː.lə(n)/",
          "note": "カード利用を確認"
        },
        {
          "id": "shopping-delivery",
          "category": "支払い",
          "scenario": ["ショッピング", "宿泊"],
          "level": ["A2"],
          "tags": ["配送", "ホテル"],
          "ja": "ホテルまで配送してもらえますか？",
          "nl": "Kunt u het naar mijn hotel bezorgen?",
          "hint": "クントゥー ヘット ナール メイン ホテル ベゾルヘン /kʏnt y ɦət naːr mɛi̯n hoːˈtɛl bəˈzɔr.ɣə(n)/",
          "note": "ホテル配送を依頼"
        },
        {
          "id": "emergency-help",
          "category": "救助",
          "scenario": ["緊急"],
          "level": ["A1"],
          "tags": ["助け", "緊急"],
          "ja": "助けが必要です。",
          "nl": "Ik heb hulp nodig.",
          "hint": "イク ヘップ フルプ ノーディフ /ɪk ɦɛb ɦʏlp ˈnoːdɪx/",
          "note": "緊急時の助けを求める",
          "featured": true
        },
        {
          "id": "emergency-hospital",
          "category": "医療",
          "scenario": ["緊急", "健康"],
          "level": ["A2"],
          "tags": ["医者", "怪我"],
          "ja": "病院へ連れて行ってください。",
          "nl": "Kunt u me naar een ziekenhuis brengen?",
          "hint": "クントゥー ム ナール エーン ズイケンハウス ブレンヘン /kʏnt y mə naːr eːn ˈzɛi̯.kə(n).ɦœys ˈbrɛŋə(n)/",
          "note": "病院へ案内を依頼"
        },
        {
          "id": "emergency-pharmacy",
          "category": "医療",
          "scenario": ["緊急", "健康"],
          "level": ["A1"],
          "tags": ["薬局", "健康"],
          "ja": "近くに薬局はありますか？",
          "nl": "Is er een apotheek in de buurt?",
          "hint": "イス エル エーン アポテーク イン デ ブュールト /ɪs ɛr eːn ˌɑ.poːˈteːk ɪn də byːrt/",
          "note": "薬局の場所を尋ねる"
        },
        {
          "id": "emergency-police",
          "category": "トラブル",
          "scenario": ["緊急"],
          "level": ["A2"],
          "tags": ["警察", "通報"],
          "ja": "警察を呼んでください。",
          "nl": "Bel alstublieft de politie.",
          "hint": "ベル アルストュブリーフト デ ポリツィー /bɛl ˌɑlstʏˈblift də poːˈliː.tsə/",
          "note": "警察を呼ぶ"
        },
        {
          "id": "emergency-lostpassport",
          "category": "トラブル",
          "scenario": ["緊急", "空港"],
          "level": ["B1"],
          "tags": ["紛失", "パスポート"],
          "ja": "パスポートを失くしました。",
          "nl": "Ik ben mijn paspoort kwijt.",
          "hint": "イク ベン メイン パスポールト クワイト /ɪk bɛn mɛi̯n ˈpɑs.poːrt kʋɛi̯t/",
          "note": "パスポート紛失を伝える"
        },
        {
          "id": "emergency-contact",
          "category": "連絡",
          "scenario": ["緊急", "日常会話"],
          "level": ["A2"],
          "tags": ["連絡", "緊急"],
          "ja": "大使館の連絡先を教えてください。",
          "nl": "Kunt u mij het nummer van de ambassade geven?",
          "hint": "クントゥー メイ ヘット ヌンマー ファン デ アンバッサーデ ヘーフェン /kʏnt y mɛi̯ ɦət ˈnʏ.mər fɑn də ɑm.bɑˈsaː.də ˈɣeː.və(n)/",
          "note": "大使館の連絡先を尋ねる"
        },
        {
          "id": "communication-sim",
          "category": "通信",
          "scenario": ["日常会話", "ショッピング"],
          "level": ["A2"],
          "tags": ["SIMカード", "通信"],
          "ja": "プリペイドSIMカードはどこで買えますか？",
          "nl": "Waar kan ik een prepaid simkaart kopen?",
          "hint": "ワール カン イク エーン プリペイド シムカールト コーペン /ʋaːr kɑn ɪk eːn ˈpriː.peːt ˈsɪm.kaːrt ˈkoː.pə(n)/",
          "note": "通信手段を確保"
        },
        {
          "id": "communication-meet",
          "category": "通信",
          "scenario": ["日常会話", "観光"],
          "level": ["A1"],
          "tags": ["待ち合わせ", "時間"],
          "ja": "明日の朝10時にロビーで会いましょう。",
          "nl": "Laten we morgenochtend om tien uur in de lobby afspreken.",
          "hint": "ラーテン ヴェ モルヘンオフテント オム ティーン ウール イン デ ロビー アフスプレーケン /ˈlaː.tə(n) ʋə ˈmɔr.ɣə.nɔx.tənt ɔm tiːn uːr ɪn də ˈlɔ.bi ˈɑf.sprəː.kə(n)/",
          "note": "待ち合わせを決める"
        }
      ]
    }
  </script>

  <script>
    // フレーズデータは外部JSONから読み込みます。


    const DATA_URL = 'data/phrases.json';
    const LEVEL_ORDER = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];
    const ESSENTIALS_CATEGORY_SLUG = 'essentials';
    const ESSENTIALS_CATEGORY_NAMES = new Set([
      '基本表現',
      '基本フレーズ',
      '基礎表現',
      'Essentials',
    ]);
    const ESSENTIALS_SCENARIO_VALUE = 'essentials';

    const createSlug = (value) => {
      if (typeof value !== 'string') {
        return '';
      }

      const normalized = value.normalize('NFKC').trim();
      const slug = normalized
        .toLowerCase()
        .replace(/[^a-z0-9]+/gi, '-')
        .replace(/^-+|-+$/g, '');

      return slug || normalized;
    };

    const coalesce = (value, fallback) =>
      value === null || value === undefined ? fallback : value;

    const getElementTextContent = (element) => {
      if (!element) {
        return '';
      }

      if (typeof element.textContent === 'string') {
        return element.textContent;
      }

      if (typeof element.innerText === 'string') {
        return element.innerText;
      }

      return '';
    };

    const getTrimmedElementText = (element) => getElementTextContent(element).trim();

    const getTrimmedString = (value) =>
      typeof value === 'string' ? value.trim() : '';

    const getDatasetValue = (element, key, fallback) => {
      if (!element || !element.dataset) {
        return fallback;
      }

      if (Object.prototype.hasOwnProperty.call(element.dataset, key)) {
        const value = element.dataset[key];
        return value === undefined ? fallback : value;
      }

      return fallback;
    };

    const isEssentialsCategory = (categoryName) =>
      categoryName && ESSENTIALS_CATEGORY_NAMES.has(categoryName);

    const parsePhrasePayload = (payload) => {
      if (!payload || !Array.isArray(payload.phrases)) {
        throw new Error('フレーズデータの形式が正しくありません。');
      }

      return payload.phrases;
    };

    const readEmbeddedPhraseData = () => {
      const element = document.getElementById('embedded-phrases');

      if (!element) {
        throw new Error('埋め込みフレーズデータが見つかりません。');
      }

      const content = getElementTextContent(element);

      if (content.trim().length === 0) {
        throw new Error('埋め込みフレーズデータが空です。');
      }

      try {
        const payload = JSON.parse(content);
        return parsePhrasePayload(payload);
      } catch (error) {
        console.error('埋め込みフレーズデータの解析に失敗しました。', error);
        throw new Error('埋め込みフレーズデータの解析に失敗しました。');
      }
    };

    const loadPhraseData = async () => {
      if (window.location.protocol !== 'file:') {
        try {
          const response = await fetch(DATA_URL, { cache: 'no-store' });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const payload = await response.json();

          return parsePhrasePayload(payload);
        } catch (error) {
          if (error instanceof TypeError || (error && error.name === 'TypeError')) {
            console.warn('ネットワークエラーが発生したため埋め込みデータを使用します。', error);
          } else {
            throw error;
          }
        }
      }

      return readEmbeddedPhraseData();
    };

    const createPhraseModel = (phrases) => {
      const normalized = phrases.map((phrase, index) => {
        const scenario = Array.isArray(phrase.scenario)
          ? phrase.scenario.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const level = Array.isArray(phrase.level)
          ? phrase.level.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const tags = Array.isArray(phrase.tags)
          ? phrase.tags.filter((value) => typeof value === 'string' && value.trim().length > 0)
          : [];
        const categoryName =
          typeof phrase.category === 'string' && phrase.category.trim().length > 0
            ? phrase.category.trim()
            : 'その他';
        const categorySlug = isEssentialsCategory(categoryName)
          ? ESSENTIALS_CATEGORY_SLUG
          : createSlug(categoryName);

        return {
          ...phrase,
          category: categoryName,
          categorySlug,
          isEssentials: categorySlug === ESSENTIALS_CATEGORY_SLUG,
          scenario: scenario.length > 0 ? scenario : ['その他'],
          level: level.length > 0 ? level : ['A1'],
          tags,
          note: typeof phrase.note === 'string' ? phrase.note : '',
          order: index,
        };
      });

      const lookup = new Map(normalized.map((phrase) => [phrase.id, phrase]));
      const scenarioOrder = [];
      const categoryOrderMap = new Map();
      const tagSet = new Set();
      const levelSet = new Set();

      normalized.forEach((phrase) => {
        const categoryName = coalesce(phrase.category, 'その他');

        phrase.scenario.forEach((scenarioName) => {
          if (!scenarioOrder.includes(scenarioName)) {
            scenarioOrder.push(scenarioName);
          }

          const storedOrder = categoryOrderMap.get(scenarioName);

          if (storedOrder) {
            if (!storedOrder.includes(categoryName)) {
              storedOrder.push(categoryName);
            }
          } else {
            categoryOrderMap.set(scenarioName, [categoryName]);
          }
        });

        phrase.tags.forEach((tag) => tagSet.add(tag));
        phrase.level.forEach((levelValue) => levelSet.add(levelValue));
      });

      const levelOptions = Array.from(levelSet).sort((a, b) => {
        const indexA = LEVEL_ORDER.indexOf(a);
        const indexB = LEVEL_ORDER.indexOf(b);

        if (indexA === -1 && indexB === -1) {
          return a.localeCompare(b, 'ja');
        }

        if (indexA === -1) {
          return 1;
        }

        if (indexB === -1) {
          return -1;
        }

        return indexA - indexB;
      });

      const tagOptions = Array.from(tagSet).sort((a, b) => a.localeCompare(b, 'ja'));

      const filter = ({ scenario, level, tags }) =>
        normalized.filter((phrase) => {
          const matchesScenario =
            !scenario || scenario === 'all' || phrase.scenario.includes(scenario);
          const matchesLevel = !level || level === 'all' || phrase.level.includes(level);
          const matchesTags =
            !tags || tags.length === 0 || tags.every((tag) => phrase.tags.includes(tag));

          return matchesScenario && matchesLevel && matchesTags;
        });

      const comparators = {
        default: (a, b) => a.order - b.order,
        ja: (a, b) => a.ja.localeCompare(b.ja, 'ja'),
        nl: (a, b) => a.nl.localeCompare(b.nl, 'nl'),
        level: (a, b) => {
          const indexFromPhrase = (phrase) => {
            const indexes = phrase.level
              .map((levelValue) => {
                const index = LEVEL_ORDER.indexOf(levelValue);
                return index === -1 ? Number.POSITIVE_INFINITY : index;
              })
              .sort((x, y) => x - y);

            return indexes.length > 0 ? indexes[0] : Number.POSITIVE_INFINITY;
          };

          const indexA = indexFromPhrase(a);
          const indexB = indexFromPhrase(b);

          if (indexA === indexB) {
            return a.ja.localeCompare(b.ja, 'ja');
          }

          return indexA - indexB;
        },
      };

      const sort = (phrases, sortKey) => {
        const comparator =
          typeof comparators[sortKey] === 'function'
            ? comparators[sortKey]
            : comparators.default;
        return [...phrases].sort(comparator);
      };

      const group = (phrases, scenarioFilter) => {
        const activeScenarioNames =
          scenarioFilter && scenarioFilter !== 'all'
            ? new Set([scenarioFilter])
            : new Set(scenarioOrder);

        const scenarioMap = new Map();

        phrases.forEach((phrase) => {
          const categoryName = coalesce(phrase.category, 'その他');

          phrase.scenario.forEach((scenarioName) => {
            if (!activeScenarioNames.has(scenarioName)) {
              return;
            }

            let scenarioEntry = scenarioMap.get(scenarioName);

            if (!scenarioEntry) {
              scenarioEntry = {
                name: scenarioName,
                categories: new Map(),
                order: scenarioOrder.indexOf(scenarioName),
              };
              scenarioMap.set(scenarioName, scenarioEntry);
            }

            let categoryEntry = scenarioEntry.categories.get(categoryName);

            if (!categoryEntry) {
              categoryEntry = { name: categoryName, phrases: [] };
              scenarioEntry.categories.set(categoryName, categoryEntry);
            }

            categoryEntry.phrases.push(phrase);
          });
        });

        const groupedScenarios = Array.from(scenarioMap.values()).sort((a, b) => {
          const orderA = a.order === -1 ? Number.MAX_SAFE_INTEGER : a.order;
          const orderB = b.order === -1 ? Number.MAX_SAFE_INTEGER : b.order;

          if (orderA === orderB) {
            return a.name.localeCompare(b.name, 'ja');
          }

          return orderA - orderB;
        });

        return groupedScenarios.map((scenarioEntry) => {
          const storedOrder = categoryOrderMap.get(scenarioEntry.name);
          const baseOrder = Array.isArray(storedOrder) ? storedOrder : [];
          const categories = Array.from(scenarioEntry.categories.values()).sort((a, b) => {
            const orderA = baseOrder.indexOf(a.name);
            const orderB = baseOrder.indexOf(b.name);

            if (orderA === -1 && orderB === -1) {
              return a.name.localeCompare(b.name, 'ja');
            }

            if (orderA === -1) {
              return 1;
            }

            if (orderB === -1) {
              return -1;
            }

            return orderA - orderB;
          });

          return {
            name: scenarioEntry.name,
            categories,
          };
        });
      };

      const filterByLevel = (level) => filter({ scenario: null, level, tags: [] });
      const filterByTags = (tags) => filter({ scenario: null, level: null, tags });

      return {
        phrases: normalized,
        lookup,
        scenarioOrder,
        levelOptions,
        tagOptions,
        filter,
        sort,
        group,
        filterByLevel,
        filterByTags,
      };
    };

    let phraseModel = null;

    const getPhraseById = (id) => {
      if (!phraseModel || !phraseModel.lookup) {
        return null;
      }

      const phrase = phraseModel.lookup.get(id);
      return typeof phrase === 'undefined' ? null : phrase;
    };

    const getAllPhrases = () => (phraseModel ? phraseModel.phrases : []);


    const renderStudyMode = (model) => {
      const scenarioSelect = document.getElementById('filter-scenario');
      const levelSelect = document.getElementById('filter-level');
      const sortSelect = document.getElementById('filter-sort');
      const tagContainer = document.getElementById('tag-filter-options');
      const tagClearButton = document.getElementById('tag-clear-button');
      const filterForm = document.getElementById('phrase-filter-form');
      const loadingIndicator = document.getElementById('phrase-loading');
      const errorIndicator = document.getElementById('phrase-error');
      const emptyIndicator = document.getElementById('phrase-empty');
      const summaryIndicator = document.getElementById('phrase-count');
      const contentContainer = document.getElementById('study-content');

      if (
        !scenarioSelect ||
        !levelSelect ||
        !sortSelect ||
        !tagContainer ||
        !filterForm ||
        !contentContainer
      ) {
        return;
      }

      if (errorIndicator) {
        errorIndicator.classList.add('is-hidden');
        errorIndicator.textContent = '';
      }

      const getSelectedTags = () =>
        Array.from(tagContainer.querySelectorAll('input[type="checkbox"]:checked')).map(
          (input) => input.value
        );

      const updateSummary = (count) => {
        if (summaryIndicator) {
          summaryIndicator.textContent = `${count}件のフレーズ`;
        }
      };

      scenarioSelect.innerHTML = '';
      const scenarioDefaultOption = document.createElement('option');
      scenarioDefaultOption.value = 'all';
      scenarioDefaultOption.textContent = 'すべてのシナリオ';
      scenarioSelect.appendChild(scenarioDefaultOption);

      model.scenarioOrder.forEach((scenarioName) => {
        const option = document.createElement('option');
        option.value = scenarioName;
        option.textContent = scenarioName;
        scenarioSelect.appendChild(option);
      });

      const hasEssentialsCategory = model.phrases.some(
        (phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG
      );

      if (hasEssentialsCategory) {
        const essentialsOption = document.createElement('option');
        essentialsOption.value = ESSENTIALS_SCENARIO_VALUE;
        essentialsOption.textContent = '基本表現（まとめ）';
        scenarioSelect.appendChild(essentialsOption);
      }

      levelSelect.innerHTML = '';
      const levelDefaultOption = document.createElement('option');
      levelDefaultOption.value = 'all';
      levelDefaultOption.textContent = 'すべてのレベル';
      levelSelect.appendChild(levelDefaultOption);

      model.levelOptions.forEach((level) => {
        const option = document.createElement('option');
        option.value = level;
        option.textContent = level;
        levelSelect.appendChild(option);
      });

      sortSelect.innerHTML = '';
      [
        { value: 'default', label: '登録順' },
        { value: 'ja', label: '日本語の五十音順' },
        { value: 'nl', label: 'オランダ語のアルファベット順' },
        { value: 'level', label: 'レベル順' },
      ].forEach(({ value, label }) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        sortSelect.appendChild(option);
      });

      tagContainer.innerHTML = '';
      model.tagOptions.forEach((tag, index) => {
        const label = document.createElement('label');
        label.className = 'tag-chip';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.name = 'tags';
        input.value = tag;
        input.id = `tag-filter-${index}`;
        const text = document.createElement('span');
        text.textContent = tag;
        label.appendChild(input);
        label.appendChild(text);
        tagContainer.appendChild(label);
      });

      const createBadge = (textContent, type) => {
        const badge = document.createElement('span');
        badge.className = `phrase-badge phrase-badge-${type}`;
        badge.textContent = textContent;
        return badge;
      };

      const createPhraseRow = (phrase) => {
        const row = document.createElement('tr');
        row.dataset.phraseId = phrase.id;

        const jaCell = document.createElement('td');
        jaCell.dataset.label = '日本語';
        const jaStrong = document.createElement('strong');
        jaStrong.textContent = phrase.ja;
        jaCell.appendChild(jaStrong);

        if (phrase.note) {
          const note = document.createElement('span');
          note.className = 'phrase-note';
          note.textContent = phrase.note;
          jaCell.appendChild(note);
        }

        const meta = document.createElement('div');
        meta.className = 'phrase-meta';

        phrase.level.forEach((levelValue) => {
          meta.appendChild(createBadge(`Lv ${levelValue}`, 'level'));
        });

        phrase.tags.forEach((tag) => {
          meta.appendChild(createBadge(tag, 'tag'));
        });

        if (meta.childElementCount > 0) {
          jaCell.appendChild(meta);
        }

        const nlCell = document.createElement('td');
        nlCell.dataset.label = 'オランダ語';
        const nlSpan = document.createElement('span');
        nlSpan.className = 'phrase-dutch';
        nlSpan.textContent = phrase.nl;
        nlCell.appendChild(nlSpan);

        const actionGroup = document.createElement('div');
        actionGroup.className = 'phrase-actions';
        actionGroup.setAttribute('role', 'group');
        actionGroup.setAttribute('aria-label', '音声操作');

        const speakButton = document.createElement('button');
        speakButton.type = 'button';
        speakButton.className = 'icon-button speak-control';
        speakButton.dataset.phraseId = phrase.id;
        const speakLabel = `「${phrase.ja}」をオランダ語で再生`;
        speakButton.dataset.defaultLabel = speakLabel;
        speakButton.dataset.activeLabel = `「${phrase.ja}」を再生中`;
        speakButton.setAttribute('aria-label', speakLabel);
        speakButton.innerHTML = '<span aria-hidden="true">🔊</span>';
        actionGroup.appendChild(speakButton);

        const recognizeButton = document.createElement('button');
        recognizeButton.type = 'button';
        recognizeButton.className = 'icon-button recognize-control';
        recognizeButton.dataset.phraseId = phrase.id;
        const recognizeLabel = `マイクで「${phrase.nl}」（${phrase.ja}）を発声してみよう`;
        recognizeButton.dataset.defaultLabel = recognizeLabel;
        recognizeButton.dataset.activeLabel = `「${phrase.nl}」を録音中`;
        recognizeButton.setAttribute('aria-label', recognizeLabel);
        recognizeButton.innerHTML = '<span aria-hidden="true">🎤</span>';
        actionGroup.appendChild(recognizeButton);

        nlCell.appendChild(actionGroup);

        const hintCell = document.createElement('td');
        hintCell.dataset.label = 'カタカナ・発音ヒント';
        const hintSpan = document.createElement('span');
        hintSpan.textContent = coalesce(phrase.hint, '―');
        hintCell.appendChild(hintSpan);

        row.appendChild(jaCell);
        row.appendChild(nlCell);
        row.appendChild(hintCell);

        return row;
      };

      const createCategorySection = (category) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'scenario-category';

        const heading = document.createElement('h4');
        heading.textContent = category.name;
        wrapper.appendChild(heading);

        const table = document.createElement('table');
        table.className = 'phrase-table';
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['日本語', 'オランダ語', 'カタカナ・発音ヒント'].forEach((label) => {
          const th = document.createElement('th');
          th.scope = 'col';
          th.textContent = label;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        category.phrases.forEach((phrase) => {
          tbody.appendChild(createPhraseRow(phrase));
        });
        table.appendChild(tbody);

        wrapper.appendChild(table);
        return wrapper;
      };

      const createEssentialsSection = (phrases) => {
        if (!phrases || phrases.length === 0) {
          return null;
        }

        const section = document.createElement('section');
        section.className = 'scenario-card';
        section.dataset.scenario = ESSENTIALS_SCENARIO_VALUE;

        const header = document.createElement('div');
        header.className = 'scenario-card-header';
        const title = document.createElement('h3');
        title.textContent = '基本表現（Essentials）';
        header.appendChild(title);
        const count = document.createElement('span');
        count.className = 'scenario-count';
        count.textContent = `${phrases.length}件`;
        header.appendChild(count);
        section.appendChild(header);

        const note = document.createElement('p');
        note.className = 'scenario-note';
        note.textContent =
          '丁寧な感謝や謝罪など、滞在中すぐに使える基本表現をまとめたショートリストです。';
        section.appendChild(note);

        const categoryMap = new Map();
        phrases.forEach((phrase) => {
          const categoryName = coalesce(phrase.category, '基本表現');
          if (!categoryMap.has(categoryName)) {
            categoryMap.set(categoryName, []);
          }
          categoryMap.get(categoryName).push(phrase);
        });

        categoryMap.forEach((phraseList, categoryName) => {
          section.appendChild(
            createCategorySection({ name: categoryName, phrases: phraseList })
          );
        });

        return section;
      };

      const render = () => {
        const scenarioValue = scenarioSelect.value;
        const levelValue = levelSelect.value;
        const sortValue = sortSelect.value;
        const selectedTags = getSelectedTags();

        const isEssentialsScenario =
          hasEssentialsCategory && scenarioValue === ESSENTIALS_SCENARIO_VALUE;

        const filtered = model.filter({
          scenario: isEssentialsScenario ? null : scenarioValue,
          level: levelValue,
          tags: selectedTags,
        });
        const filteredForScenario = isEssentialsScenario
          ? filtered.filter((phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG)
          : filtered;
        const sorted = model.sort(filteredForScenario, sortValue);
        const essentialsSorted = isEssentialsScenario
          ? sorted
          : sorted.filter((phrase) => phrase.categorySlug === ESSENTIALS_CATEGORY_SLUG);
        const grouped = isEssentialsScenario ? [] : model.group(sorted, scenarioValue);

        if (loadingIndicator) {
          loadingIndicator.classList.add('is-hidden');
        }

        contentContainer.innerHTML = '';

        if (sorted.length === 0) {
          updateSummary(0);
          if (emptyIndicator) {
            emptyIndicator.classList.remove('is-hidden');
          }
          return;
        }

        if (emptyIndicator) {
          emptyIndicator.classList.add('is-hidden');
        }

        updateSummary(sorted.length);

        const shouldRenderEssentialsSection =
          hasEssentialsCategory &&
          essentialsSorted.length > 0 &&
          (isEssentialsScenario || scenarioValue === 'all');

        if (shouldRenderEssentialsSection) {
          const essentialsSection = createEssentialsSection(essentialsSorted);
          if (essentialsSection) {
            contentContainer.appendChild(essentialsSection);
          }
        }

        if (!isEssentialsScenario) {
          grouped.forEach((scenarioEntry) => {
            const scenarioSection = document.createElement('section');
            scenarioSection.className = 'scenario-card';

            const header = document.createElement('div');
            header.className = 'scenario-card-header';
            const title = document.createElement('h3');
            title.textContent = scenarioEntry.name;
            header.appendChild(title);
            const count = document.createElement('span');
            count.className = 'scenario-count';
            const phraseCount = scenarioEntry.categories.reduce(
              (acc, category) => acc + category.phrases.length,
              0
            );
            count.textContent = `${phraseCount}件`;
            header.appendChild(count);
            scenarioSection.appendChild(header);

            scenarioEntry.categories.forEach((category) => {
              scenarioSection.appendChild(createCategorySection(category));
            });

            contentContainer.appendChild(scenarioSection);
          });
        }

        if (typeof syncRecognitionControls === 'function') {
          syncRecognitionControls();
        }
      };

      scenarioSelect.addEventListener('change', render);
      levelSelect.addEventListener('change', render);
      sortSelect.addEventListener('change', render);
      tagContainer.addEventListener('change', (event) => {
        if (event.target && event.target.matches('input[type="checkbox"]')) {
          render();
        }
      });

      if (tagClearButton) {
        tagClearButton.addEventListener('click', () => {
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        });
      }

      filterForm.addEventListener('reset', () => {
        window.setTimeout(() => {
          scenarioSelect.value = 'all';
          levelSelect.value = 'all';
          sortSelect.value = 'default';
          tagContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
          render();
        }, 0);
      });

      render();
    };

    const attachPhraseData = (model) => {
      phraseModel = model;
      if (!window.NederLingo) {
        window.NederLingo = {};
      }
      window.NederLingo.phraseModel = {
        getAll: () => model.phrases,
        filterByLevel: model.filterByLevel,
        filterByTags: model.filterByTags,
      };
    };


    const showPhraseDataError = (error) => {
      const errorIndicator = document.getElementById('phrase-error');
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.add('is-hidden');
      }

      if (errorIndicator) {
        const escapeHtml = (value) =>
          String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

        const rawMessage =
          typeof error === 'string'
            ? error
            : error && typeof error.message === 'string'
              ? error.message
              : '不明なエラーです。';
        const errorName =
          typeof error === 'object' && error !== null && 'name' in error && typeof error.name === 'string'
            ? error.name
            : undefined;

        const normalizedMessage = rawMessage.toLowerCase();
        const isTypeError = error instanceof TypeError || errorName === 'TypeError' || normalizedMessage.includes('typeerror');
        const httpMatch = rawMessage.match(/http\s+(\d{3})/i);
        const httpStatus = httpMatch ? httpMatch[1] : null;
        const isFileProtocol = window.location.protocol === 'file:';
        const stackTrace =
          typeof error === 'object' && error !== null && 'stack' in error && typeof error.stack === 'string'
            ? error.stack
            : undefined;

        let primaryMessage = 'フレーズデータの読み込みに失敗しました。';
        const suggestions = [];

        if (httpStatus === '404') {
          primaryMessage = 'フレーズデータ (data/phrases.json) が見つかりません。ファイル名と配置を確認してください。';
        } else if (httpStatus) {
          primaryMessage = `サーバーが HTTP ${httpStatus} を返しました。サーバーログやアクセス権限を確認してください。`;
        } else if (isTypeError) {
          primaryMessage = 'ネットワークに接続できないためフレーズデータを取得できませんでした。インターネット接続やローカルサーバーの状態を確認してください。';
        }

        if (isFileProtocol) {
          suggestions.push('ブラウザで直接 index.html を開くとデータを取得できないため、ローカル HTTP サーバー経由でアクセスしてください。');
        }

        suggestions.push('プロジェクトのルートで <code>npx serve</code> を実行するか、VS Code の Live Server 拡張機能で配信すると解決する場合があります。');

        const actionLink = `
          <div class="phrase-error-actions" style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <a class="mode-button" href="https://github.com/vercel/serve#readme" target="_blank" rel="noopener">セットアップ手順を見る</a>
            <a class="mode-button" href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server を開く</a>
          </div>
        `;

        const suggestionMarkup =
          suggestions.length > 0
            ? `<ul style="margin:12px 0 0;padding-left:1.4em;">${suggestions
                .map((item) => `<li style="margin-bottom:6px;">${item}</li>`)
                .join('')}</ul>`
            : '';

        const detailsMarkup = rawMessage
          ? `<details style="margin-top:16px;">` +
            '<summary style="cursor:pointer;">技術的な詳細を表示</summary>' +
            `<pre style="margin-top:8px;white-space:pre-wrap;word-break:break-all;">${escapeHtml(rawMessage)}</pre>` +
            (errorName && errorName !== 'Error'
              ? `<p style="margin-top:8px;font-size:0.9em;color:var(--muted);">エラー種別: ${escapeHtml(errorName)}</p>`
              : '') +
            (stackTrace && stackTrace !== rawMessage
              ? `<pre style="margin-top:8px;white-space:pre-wrap;word-break:break-all;font-size:0.85em;">${escapeHtml(stackTrace)}</pre>`
              : '') +
            '</details>'
          : '';

        errorIndicator.innerHTML =
          `<p style="margin:0;">${primaryMessage}</p>` + suggestionMarkup + actionLink + detailsMarkup;
        errorIndicator.classList.remove('is-hidden');
      }
    };

    const bootstrapPhraseData = async () => {
      const loadingIndicator = document.getElementById('phrase-loading');

      if (loadingIndicator) {
        loadingIndicator.classList.remove('is-hidden');
      }

      try {
        const phrases = await loadPhraseData();
        const model = createPhraseModel(phrases);
        attachPhraseData(model);
        renderStudyMode(model);
        return model;
      } catch (error) {
        console.error(error);
        showPhraseDataError(error);
        return null;
      }
    };

    const phraseDataPromise = bootstrapPhraseData();

    const shuffleArray = (input) => {
      const array = [...input];

      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }

      return array;
    };

    const modeContainer = document.querySelector('.main-container');
    const modeButtons = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode]'))
      : [];
    const modePanels = modeContainer
      ? Array.from(modeContainer.querySelectorAll('[data-mode-panel]'))
      : [];

    if (modeContainer && modeButtons.length > 0 && modePanels.length > 0) {
      const setActiveMode = (mode) => {
        modeContainer.dataset.activeMode = mode;

        modeButtons.forEach((button) => {
          const targetMode = button.getAttribute('data-mode');
          const isActive = targetMode === mode;

          button.setAttribute('aria-selected', String(isActive));
          button.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        modePanels.forEach((panel) => {
          const panelMode = panel.getAttribute('data-mode-panel');
          const isActive = panelMode === mode;

          panel.toggleAttribute('hidden', !isActive);
          panel.setAttribute('aria-hidden', String(!isActive));
        });
      };

      const availableModes = modeButtons
        .map((button) => button.getAttribute('data-mode'))
        .filter((value) => typeof value === 'string' && value.length > 0);

      let initialMode = modeContainer.dataset.activeMode;

      if (!initialMode || !availableModes.includes(initialMode)) {
        initialMode = availableModes[0];
      }

      setActiveMode(initialMode);

      modeButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const mode = button.getAttribute('data-mode');

          if (!mode) {
            return;
          }

          setActiveMode(mode);
        });

        button.addEventListener('keydown', (event) => {
          const currentIndex = modeButtons.indexOf(button);
          let targetIndex = null;

          if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
            targetIndex = (currentIndex + 1) % modeButtons.length;
          } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
            targetIndex =
              (currentIndex - 1 + modeButtons.length) % modeButtons.length;
          } else if (event.key === 'Home') {
            targetIndex = 0;
          } else if (event.key === 'End') {
            targetIndex = modeButtons.length - 1;
          }

          if (targetIndex !== null) {
            event.preventDefault();

            const targetButton = modeButtons[targetIndex];

            if (!targetButton) {
              return;
            }

            const mode = targetButton.getAttribute('data-mode');

            if (mode) {
              setActiveMode(mode);
              targetButton.focus();
            }
          }
        });
      });
    }

    const rateSlider = document.getElementById('speech-rate');
    const rateValue = document.getElementById('speech-rate-value');
    const speechFeedback = document.getElementById('speech-feedback');
    const recognitionStatus = document.getElementById('recognition-status');
    const recognitionTarget = document.getElementById('recognition-target');
    const recognitionText = document.getElementById('recognition-text');
    const recognitionScore = document.getElementById('recognition-score');
    const recognitionLive = document.getElementById('recognition-live');
    const recognitionNotice = document.getElementById('speech-recognition-notice');

    let speakDutchPhrase = null;

    const defaultStatusMessage =
      getTrimmedElementText(recognitionStatus) || '録音待機中です。';

    let recognitionAudioContext = null;

    const ensureRecognitionAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!recognitionAudioContext) {
        recognitionAudioContext = new AudioContextClass();
      }

      if (recognitionAudioContext.state === 'suspended') {
        recognitionAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return recognitionAudioContext;
    };

    const playRecognitionTone = (isPerfectMatch) => {
      const context = ensureRecognitionAudioContext();

      if (!context) {
        return;
      }

      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      const now = context.currentTime;

      oscillator.type = isPerfectMatch ? 'triangle' : 'sine';

      if (isPerfectMatch) {
        oscillator.frequency.setValueAtTime(880, now);
        oscillator.frequency.exponentialRampToValueAtTime(1320, now + 0.22);
      } else {
        oscillator.frequency.setValueAtTime(320, now);
        oscillator.frequency.exponentialRampToValueAtTime(220, now + 0.22);
      }

      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.25, now + 0.04);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);

      oscillator.connect(gainNode);
      gainNode.connect(context.destination);

      oscillator.start(now);
      oscillator.stop(now + 0.34);
    };

    const showRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = false;
      }
    };

    const hideRecognitionLive = () => {
      if (recognitionLive) {
        recognitionLive.hidden = true;
      }
    };

    if (recognitionStatus) {
      recognitionStatus.dataset.defaultMessage = defaultStatusMessage;
      recognitionStatus.dataset.state = recognitionStatus.dataset.state || 'idle';
    }

    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;

    const syncRecognitionControls = () => {
      document.querySelectorAll('.recognize-control').forEach((button) => {
        const baseLabel =
          button.dataset.defaultLabel || 'オランダ語フレーズの発声をテスト';

        if (!SpeechRecognition) {
          button.setAttribute(
            'aria-label',
            `${baseLabel} (音声認識は利用できません)`
          );
          button.disabled = true;
        } else {
          button.setAttribute('aria-label', baseLabel);
          button.disabled = false;
        }
      });
    };

    if (rateSlider && rateValue) {
      const updateRateLabel = () => {
        rateValue.textContent = `${parseFloat(rateSlider.value).toFixed(1)}x`;
      };

      rateSlider.addEventListener('input', updateRateLabel);
      updateRateLabel();
    }

    if ('speechSynthesis' in window) {
      const synthesis = window.speechSynthesis;
      let availableVoices = [];
      let activeButton = null;

      const restoreStatusAfterSpeech = () => {
        if (
          recognitionStatus &&
          recognitionStatus.dataset.state === 'speaking'
        ) {
          const previous =
            recognitionStatus.dataset.previousStatus || defaultStatusMessage;
          recognitionStatus.textContent = previous;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
        }
      };

      const markStatusForSpeech = () => {
        if (!recognitionStatus) {
          return;
        }

        recognitionStatus.dataset.previousStatus =
          getTrimmedElementText(recognitionStatus) || defaultStatusMessage;
        recognitionStatus.dataset.state = 'speaking';
        recognitionStatus.textContent = '再生中です…';
      };

      const refreshVoices = () => {
        availableVoices = synthesis
          .getVoices()
          .filter((voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl'));

        if (availableVoices.length === 0) {
          availableVoices = synthesis.getVoices();
        }
      };

      const resetActiveButton = () => {
        restoreStatusAfterSpeech();

        if (activeButton) {
          activeButton.disabled = false;
          activeButton.classList.remove('is-active');
          const defaultLabel = getDatasetValue(
            activeButton,
            'defaultLabel',
            'オランダ語フレーズを再生'
          );
          activeButton.setAttribute('aria-label', defaultLabel);
          activeButton = null;
        }
      };

      speakDutchPhrase = ({ phraseId, triggerButton = null } = {}) => {
        if (!phraseId) {
          return false;
        }

        const phrase = getPhraseById(phraseId);
        const dutchText =
          phrase && typeof phrase.nl === 'string' ? phrase.nl.trim() : '';

        if (!phrase || !dutchText) {
          return false;
        }

        if (availableVoices.length === 0) {
          refreshVoices();
        }

        if (synthesis.speaking || synthesis.pending) {
          synthesis.cancel();
        }

        resetActiveButton();

        const utterance = new SpeechSynthesisUtterance(dutchText);
        utterance.lang = 'nl-NL';

        if (rateSlider) {
          const parsedRate = parseFloat(rateSlider.value);
          if (!Number.isNaN(parsedRate)) {
            utterance.rate = parsedRate;
          }
        }

        const selectedVoice = availableVoices.find(
          (voice) => voice.lang && voice.lang.toLowerCase().startsWith('nl')
        );

        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }

        if (speechFeedback) {
          speechFeedback.classList.remove('is-hidden');
        }

        if (recognitionTarget) {
          recognitionTarget.textContent = dutchText;
        }

        markStatusForSpeech();

        if (triggerButton) {
          if (!triggerButton.dataset.defaultLabel) {
            const currentLabel = triggerButton.getAttribute('aria-label');
            if (currentLabel) {
              triggerButton.dataset.defaultLabel = currentLabel;
            }
          }

          activeButton = triggerButton;
          triggerButton.disabled = true;
          triggerButton.classList.add('is-active');
          const activeLabel = getDatasetValue(triggerButton, 'activeLabel', '再生中…');
          triggerButton.setAttribute('aria-label', activeLabel);
        }

        const clearAfterSpeech = () => {
          if (triggerButton && activeButton === triggerButton) {
            resetActiveButton();
          } else {
            restoreStatusAfterSpeech();
          }
        };

        utterance.onend = clearAfterSpeech;
        utterance.onerror = clearAfterSpeech;

        synthesis.speak(utterance);

        return true;
      };

      const handleSpeakClick = (event) => {
        const button = event.target.closest('.speak-control');

        if (!button || typeof speakDutchPhrase !== 'function') {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        speakDutchPhrase({
          phraseId: button.dataset.phraseId,
          triggerButton: button,
        });
      };

      refreshVoices();
      synthesis.addEventListener('voiceschanged', refreshVoices);
      document.addEventListener('click', handleSpeakClick);
    }

    const sanitizePhrase = (text) =>
      text
        .toLowerCase()
        .replace(/[^a-zà-ž\s']/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim();

    const computeSimilarity = (a, b) => {
      const source = sanitizePhrase(a);
      const target = sanitizePhrase(b);

      if (!source && !target) {
        return 1;
      }

      if (!source || !target) {
        return 0;
      }

      const rows = source.length + 1;
      const cols = target.length + 1;
      const dp = Array.from({ length: rows }, () => new Array(cols).fill(0));

      for (let i = 0; i < rows; i += 1) {
        dp[i][0] = i;
      }

      for (let j = 0; j < cols; j += 1) {
        dp[0][j] = j;
      }

      for (let i = 1; i < rows; i += 1) {
        for (let j = 1; j < cols; j += 1) {
          const cost = source[i - 1] === target[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }

      const distance = dp[rows - 1][cols - 1];
      const longest = Math.max(source.length, target.length);

      return longest === 0 ? 1 : 1 - distance / longest;
    };

      if (
        recognitionNotice &&
        speechFeedback &&
        recognitionStatus &&
        recognitionTarget &&
        recognitionText &&
        recognitionScore
      ) {
        syncRecognitionControls();

        if (!SpeechRecognition) {
          if (speechFeedback) {
            speechFeedback.classList.add('is-hidden');
          }
          recognitionNotice.textContent =
            'お使いのブラウザは音声認識に対応していません。Chromeなどの対応ブラウザでお試しください。';
          recognitionNotice.classList.remove('is-hidden');
          recognitionStatus.textContent = '音声認識は利用できません。';
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;
        } else {
          speechFeedback.classList.remove('is-hidden');
          recognitionNotice.textContent = '初回利用時はマイクアイコンを押す際にブラウザのマイク許可が求められます。';
          recognitionNotice.classList.remove('is-hidden');
          recognitionStatus.textContent = defaultStatusMessage;
          recognitionStatus.dataset.state = 'idle';
          delete recognitionStatus.dataset.previousStatus;

          const recognition = new SpeechRecognition();
          recognition.lang = 'nl-NL';
          recognition.continuous = false;
          recognition.interimResults = false;
          recognition.maxAlternatives = 1;

          let activeRecognitionButton = null;
          let targetPhrase = '';

          const releaseRecognitionButton = () => {
            if (activeRecognitionButton) {
              activeRecognitionButton.disabled = false;
              activeRecognitionButton.classList.remove('is-recording');
              const defaultLabel = getDatasetValue(
                activeRecognitionButton,
                'defaultLabel',
                'オランダ語フレーズの発声をテスト'
              );
              activeRecognitionButton.setAttribute('aria-label', defaultLabel);
              activeRecognitionButton = null;
            }
          };

          recognition.addEventListener('start', () => {
            showRecognitionLive();

            if (recognitionText) {
              recognitionText.textContent = '聴き取り中…';
            }

            if (recognitionScore) {
              recognitionScore.textContent = '-';
            }

            if (recognitionStatus) {
              const previousStatus =
                getTrimmedElementText(recognitionStatus) || defaultStatusMessage;
              recognitionStatus.dataset.previousStatus = previousStatus;
              recognitionStatus.dataset.state = 'recognition';
              recognitionStatus.textContent = '録音中です。話し終えたら自動的に判定します。';
            }
          });

          recognition.addEventListener('result', (event) => {
            let transcript = '';
            const results = event.results;

            if (
              results &&
              results[0] &&
              results[0][0] &&
              typeof results[0][0].transcript === 'string'
            ) {
              transcript = results[0][0].transcript.trim();
            }

            recognitionText.textContent = transcript || '-';
            recognitionTarget.textContent = targetPhrase || '-';

            const similarity = computeSimilarity(transcript, targetPhrase);
            const percentage = Math.round(similarity * 100);
            recognitionScore.textContent = Number.isNaN(percentage) ? '-' : `${percentage}%`;

            if (transcript && targetPhrase) {
              const isPerfectMatch = !Number.isNaN(percentage) && percentage === 100;
              playRecognitionTone(isPerfectMatch);
            }
          });

          recognition.addEventListener('error', (event) => {
            recognitionStatus.textContent = `エラーが発生しました: ${event.error}`;
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();
            releaseRecognitionButton();
          });

          recognition.addEventListener('nomatch', () => {
            recognitionStatus.textContent = '音声を認識できませんでした。もう一度お試しください。';
            recognitionStatus.dataset.state = 'idle';
            delete recognitionStatus.dataset.previousStatus;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();
          });

          recognition.addEventListener('end', () => {
            releaseRecognitionButton();

            if (recognitionStatus) {
              if (recognitionStatus.dataset.state === 'recognition') {
                recognitionStatus.textContent =
                  recognitionStatus.dataset.previousStatus || defaultStatusMessage;
              }
              recognitionStatus.dataset.state = 'idle';
              delete recognitionStatus.dataset.previousStatus;
            }
          });

          const handleRecognitionClick = (event) => {
            const button = event.target.closest('.recognize-control');

            if (!button) {
              return;
            }

            event.preventDefault();
            event.stopPropagation();

            const phraseId = button.dataset.phraseId;
            const phrase = phraseId ? getPhraseById(phraseId) : null;
            const dutchText =
              phrase && typeof phrase.nl === 'string' ? phrase.nl.trim() : '';

            if (!phrase || !dutchText) {
              return;
            }

            if (activeRecognitionButton) {
              try {
                recognition.abort();
              } catch (error) {
                /* noop */
              }
              releaseRecognitionButton();
            }

            targetPhrase = dutchText;
            recognitionTarget.textContent = dutchText;
            recognitionText.textContent = '-';
            recognitionScore.textContent = '-';
            hideRecognitionLive();

            activeRecognitionButton = button;
            button.disabled = true;
            button.classList.add('is-recording');
            const activeLabel = getDatasetValue(button, 'activeLabel', '録音中…');
            button.setAttribute('aria-label', activeLabel);

            try {
              recognition.start();
            } catch (error) {
              recognitionStatus.textContent =
                '音声認識の開始に失敗しました。もう一度お試しください。';
              recognitionStatus.dataset.state = 'idle';
              delete recognitionStatus.dataset.previousStatus;
              releaseRecognitionButton();
              targetPhrase = '';
              recognitionTarget.textContent = '-';
              recognitionText.textContent = '-';
              recognitionScore.textContent = '-';
              hideRecognitionLive();
            }
          };

          document.addEventListener('click', handleRecognitionClick);

          window.addEventListener('beforeunload', () => {
            try {
              recognition.stop();
            } catch (error) {
              /* noop */
            }
          });
        }
      }
    }

    const gameGrid = document.getElementById('game-grid');
    const gameStatus = document.getElementById('game-status');
    const stageDisplay = document.getElementById('game-stage');
    const scoreDisplay = document.getElementById('game-score');
    const streakDisplay = document.getElementById('game-streak');
    const bestDisplay = document.getElementById('game-best');
    const startButton = document.getElementById('game-start-button');
    const resetButton = document.getElementById('game-reset-button');
    const timeDisplay = document.getElementById('game-time');
    const countdownFill = document.getElementById('game-timer-fill');
    const correctDisplay = document.getElementById('game-correct');
    const mistakesDisplay = document.getElementById('game-mistakes');

    const TIME_LIMIT_SECONDS = 60;
    const TIME_LIMIT_MS = TIME_LIMIT_SECONDS * 1000;
    let timerAnimationFrame = null;

    const gameState = {
      stage: 0,
      score: 0,
      streak: 0,
      best: 0,
      matchesRemaining: 0,
      selection: [],
      busy: false,
      phraseQueue: [],
      columns: null,
      timeRemainingMs: TIME_LIMIT_MS,
      correctMatches: 0,
      mistakes: 0,
      timerStartedAt: null,
      roundActive: false,
    };

    const pulseElement = (element) => {
      if (!element) {
        return;
      }

      element.classList.remove('score-pulse');
      void element.offsetWidth;
      element.classList.add('score-pulse');
    };

    const MAX_VISIBLE_PAIRS = 5;

    const stagePairCount = (stage = 1) => {
      const totalPhrases = getAllPhrases().length;

      if (totalPhrases <= 0) {
        return 0;
      }

      return Math.min(stage * MAX_VISIBLE_PAIRS, totalPhrases);
    };

    const setStatus = (message) => {
      if (gameStatus) {
        gameStatus.textContent = message;
      }
    };

    const formatStatusWithSpeechCue = (didSpeak, message) =>
      didSpeak ? `🔊 オランダ語カードの発音を再生したよ。${message}` : message;

    const updateScoreboard = () => {
      if (stageDisplay) {
        stageDisplay.textContent = gameState.stage;
      }

      if (scoreDisplay) {
        scoreDisplay.textContent = gameState.score;
      }

      if (streakDisplay) {
        streakDisplay.textContent = gameState.streak;
      }

      if (bestDisplay) {
        bestDisplay.textContent = `BEST ${gameState.best}`;
      }

      if (correctDisplay) {
        correctDisplay.textContent = gameState.correctMatches;
      }

      if (mistakesDisplay) {
        mistakesDisplay.textContent = gameState.mistakes;
      }

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
        timeDisplay.textContent = seconds.toString();
      }
    };

    const setTimeRemaining = (remainingMs) => {
      const clamped = Math.max(0, Math.min(TIME_LIMIT_MS, remainingMs));
      gameState.timeRemainingMs = clamped;

      if (timeDisplay) {
        const seconds = Math.max(0, Math.ceil(clamped / 1000));
        timeDisplay.textContent = seconds.toString();
      }

      if (countdownFill) {
        const percentage = TIME_LIMIT_MS === 0 ? 0 : (clamped / TIME_LIMIT_MS) * 100;
        countdownFill.style.width = `${percentage}%`;
        countdownFill.classList.toggle('is-warning', percentage <= 50 && percentage > 20);
        countdownFill.classList.toggle('is-danger', percentage <= 20);
      }
    };

    const stopTimer = ({ resetToFull = false } = {}) => {
      if (timerAnimationFrame !== null) {
        cancelAnimationFrame(timerAnimationFrame);
        timerAnimationFrame = null;
      }

      gameState.roundActive = false;
      gameState.timerStartedAt = null;

      if (resetToFull) {
        setTimeRemaining(TIME_LIMIT_MS);
      }
    };

    const handleTimeUp = () => {
      if (gameState.matchesRemaining <= 0) {
        return;
      }

      setTimeRemaining(0);
      gameState.busy = true;
      gameState.roundActive = false;
      gameState.selection = [];
      gameState.streak = 0;

      if (gameGrid) {
        gameGrid.querySelectorAll('.game-card').forEach((card) => {
          card.classList.add('is-disabled');
          card.classList.remove('is-selected');
        });
      }

      const remainingPairs = gameState.matchesRemaining;
      const remainingPenalty = remainingPairs * 5;

      if (remainingPenalty > 0) {
        gameState.score = Math.max(0, gameState.score - remainingPenalty);
      }

      updateScoreboard();

      if (remainingPenalty > 0) {
        pulseElement(scoreDisplay);
      }

      pulseElement(streakDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'もう一度挑戦';
      }

      const summary = `⏰ タイムアップ！${gameState.correctMatches}組正解、ミス${gameState.mistakes}回。`;

      if (remainingPenalty > 0) {
        setStatus(
          `${summary}残り${remainingPairs}組で${remainingPenalty}点の減点…次の挑戦で挽回しよう！`
        );
      } else {
        setStatus(`${summary}あと少しだったね！`);
      }

      gameState.matchesRemaining = 0;
    };

    const tickTimer = (timestamp) => {
      if (!gameState.roundActive) {
        return;
      }

      if (gameState.timerStartedAt === null) {
        gameState.timerStartedAt = timestamp;
      }

      const elapsed = timestamp - gameState.timerStartedAt;
      const remaining = TIME_LIMIT_MS - elapsed;

      if (remaining <= 0) {
        stopTimer();
        handleTimeUp();
        return;
      }

      setTimeRemaining(remaining);
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const startTimer = () => {
      stopTimer();
      gameState.roundActive = true;
      gameState.timerStartedAt = null;
      timerAnimationFrame = window.requestAnimationFrame(tickTimer);
    };

    const createGameCard = (phrase, lang) => {
      const card = document.createElement('div');
      card.className = 'game-card';
      card.dataset.pairId = phrase.id;
      card.dataset.lang = lang;

      const mainButton = document.createElement('button');
      mainButton.type = 'button';
      mainButton.className = 'game-card-main';

      const labelText = lang === 'ja' ? '日本語カード' : 'オランダ語カード';
      const displayText = lang === 'ja' ? phrase.ja : phrase.nl;
      const actionHint =
        lang === 'nl'
          ? '。タップするとオランダ語の発音が再生されます。'
          : '。タップして対応するカードを見つけましょう。';
      mainButton.setAttribute('aria-label', `${labelText}: ${displayText}${actionHint}`);

      if (lang === 'nl') {
        mainButton.title = 'タップするとオランダ語の発音が再生されます';
        mainButton.setAttribute('aria-describedby', 'game-speech-instruction');
      } else {
        mainButton.title = 'タップして対応するカードを探しましょう';
      }

      const textSpan = document.createElement('span');
      textSpan.className = 'game-card-text';
      textSpan.textContent = displayText;

      mainButton.append(textSpan);

      card.append(mainButton);

      return card;
    };

    const speakCardIfDutch = ({ lang, pairId, alreadySelected = false } = {}) => {
      if (alreadySelected || lang !== 'nl' || !pairId) {
        return false;
      }

      if (typeof speakDutchPhrase !== 'function') {
        return false;
      }

      return speakDutchPhrase({ phraseId: pairId });
    };

    const createCardColumn = (lang) => {
      const column = document.createElement('div');
      column.className = 'game-card-column';
      column.dataset.lang = lang;
      column.setAttribute(
        'aria-label',
        lang === 'nl' ? 'オランダ語のカード' : '日本語のカード'
      );
      column.setAttribute('role', 'group');
      return column;
    };

    const rebuildGameColumns = () => {
      if (!gameGrid) {
        return null;
      }

      gameGrid.innerHTML = '';

      const dutchColumn = createCardColumn('nl');
      const japaneseColumn = createCardColumn('ja');

      const fragment = document.createDocumentFragment();
      fragment.append(dutchColumn, japaneseColumn);

      gameGrid.appendChild(fragment);

      return { dutchColumn, japaneseColumn };
    };

    const insertCardRandomly = (column, card) => {
      if (!column || !card) {
        return;
      }

      const insertionIndex = Math.floor(Math.random() * (column.childElementCount + 1));

      if (insertionIndex >= column.childElementCount) {
        column.appendChild(card);
        return;
      }

      column.insertBefore(card, column.children[insertionIndex]);
    };

    const dealPhrasePair = (phrase) => {
      if (!phrase || !gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      const dutchCard = createGameCard(phrase, 'nl');
      const japaneseCard = createGameCard(phrase, 'ja');

      insertCardRandomly(dutchColumn, dutchCard);
      insertCardRandomly(japaneseColumn, japaneseCard);
    };

    const replenishBoard = () => {
      if (!gameState.columns) {
        return;
      }

      const { dutchColumn, japaneseColumn } = gameState.columns;

      if (!dutchColumn || !japaneseColumn) {
        return;
      }

      while (
        gameState.phraseQueue.length > 0 &&
        dutchColumn.childElementCount < MAX_VISIBLE_PAIRS &&
        japaneseColumn.childElementCount < MAX_VISIBLE_PAIRS
      ) {
        const nextPhrase = gameState.phraseQueue.shift();

        if (!nextPhrase) {
          break;
        }

        dealPhrasePair(nextPhrase);
      }
    };

    const resetGame = (announce = true) => {
      stopTimer({ resetToFull: true });
      gameState.stage = 0;
      gameState.score = 0;
      gameState.streak = 0;
      gameState.best = 0;
      gameState.matchesRemaining = 0;
      gameState.selection = [];
      gameState.busy = false;
      gameState.phraseQueue = [];
      gameState.columns = null;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;
      gameState.timeRemainingMs = TIME_LIMIT_MS;
      updateScoreboard();

      if (gameGrid) {
        rebuildGameColumns();
        gameGrid.removeAttribute('aria-busy');
      }

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = 'ステージを始める';
      }

      if (announce) {
        setStatus(
          `ステージを始めて制限時間${TIME_LIMIT_SECONDS}秒以内にカードをマッチさせましょう！オランダ語カードをタップすると発音が流れます。`
        );
      }
    };

    const stageClearFeedback = () => {
      stopTimer();
      const remainingSeconds = Math.max(0, Math.ceil(gameState.timeRemainingMs / 1000));
      const timeBonus = Math.max(20, remainingSeconds * 2);
      gameState.score += timeBonus;
      updateScoreboard();
      pulseElement(scoreDisplay);

      if (startButton) {
        startButton.disabled = false;
        startButton.textContent = '次のステージへ';
      }

      setStatus(
        `✨ ステージ${gameState.stage}クリア！${gameState.correctMatches}組正解、ミス${gameState.mistakes}回。残り${remainingSeconds}秒でボーナス${timeBonus}点を獲得したよ。`
      );
    };

    let feedbackAudioContext = null;

    const ensureFeedbackAudioContext = () => {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;

      if (!AudioContextClass) {
        return null;
      }

      if (!feedbackAudioContext) {
        try {
          feedbackAudioContext = new AudioContextClass();
        } catch (error) {
          feedbackAudioContext = null;
          return null;
        }
      }

      if (feedbackAudioContext.state === 'suspended') {
        feedbackAudioContext.resume().catch(() => {
          /* noop */
        });
      }

      return feedbackAudioContext;
    };

    const playMatchFeedbackTone = (isMatch) => {
      const context = ensureFeedbackAudioContext();

      if (!context) {
        return;
      }

      try {
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        const now = context.currentTime;

        oscillator.type = 'sine';

        if (isMatch) {
          oscillator.frequency.setValueAtTime(660, now);
          oscillator.frequency.exponentialRampToValueAtTime(990, now + 0.18);
        } else {
          oscillator.frequency.setValueAtTime(240, now);
          oscillator.frequency.exponentialRampToValueAtTime(180, now + 0.18);
        }

        gainNode.gain.setValueAtTime(0.0001, now);
        gainNode.gain.exponentialRampToValueAtTime(0.18, now + 0.04);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

        oscillator.connect(gainNode);
        gainNode.connect(context.destination);

        oscillator.start(now);
        oscillator.stop(now + 0.3);
      } catch (error) {
        /* noop */
      }
    };

    const evaluateSelection = ({ didSpeak = false } = {}) => {
      if (gameState.selection.length < 2) {
        return;
      }

      gameState.busy = true;

      const [first, second] = gameState.selection;
      const isMatch = first.pairId === second.pairId && first.lang !== second.lang;

      const setStatusWithCue = (message) => {
        setStatus(formatStatusWithSpeechCue(didSpeak, message));
      };

      if (isMatch) {
        playMatchFeedbackTone(true);
        const phrase = getPhraseById(first.pairId);
        const matchedCards = [first.card, second.card];

        matchedCards.forEach((card) => {
          card.classList.remove('is-selected');
          card.classList.add('is-matched', 'is-disabled');
        });

        gameState.matchesRemaining -= 1;
        gameState.streak += 1;
        gameState.correctMatches += 1;

        if (gameState.streak > gameState.best) {
          gameState.best = gameState.streak;
        }

        const gained = 10 + gameState.streak * 2;
        gameState.score += gained;
        updateScoreboard();
        pulseElement(scoreDisplay);
        pulseElement(streakDisplay);
        pulseElement(correctDisplay);

        if (phrase) {
          setStatusWithCue(
            `🎉 正解！${gameState.correctMatches}組目の「${phrase.ja}」と「${phrase.nl}」で${gained}点ゲット！`
          );
        } else {
          setStatusWithCue(
            `🎉 正解！${gameState.correctMatches}組目で${gained}点ゲット！`
          );
        }

        gameState.selection = [];
        matchedCards.forEach((card) => {
          if (card && typeof card.remove === 'function') {
            card.remove();
          }
        });

        replenishBoard();

        gameState.busy = false;

        if (gameState.matchesRemaining === 0) {
          stageClearFeedback();
        }

        return;
      }

      playMatchFeedbackTone(false);
      gameState.mistakes += 1;
      const penalty = Math.max(5, 3 + gameState.stage * 2);

      if (penalty > 0) {
        gameState.score = Math.max(0, gameState.score - penalty);
      }

      gameState.streak = 0;
      updateScoreboard();
      pulseElement(streakDisplay);
      pulseElement(mistakesDisplay);

      if (penalty > 0) {
        pulseElement(scoreDisplay);
      }

      setStatusWithCue(
        penalty > 0
          ? `😅 ミス${gameState.mistakes}回目。${penalty}点減点だけど、まだ巻き返せるよ！`
          : `😅 ミス${gameState.mistakes}回目。次は当ててみよう！`
      );

      const [firstCard, secondCard] = [first.card, second.card];

      setTimeout(() => {
        firstCard.classList.remove('is-selected');
        secondCard.classList.remove('is-selected');
        gameState.selection = [];
        gameState.busy = false;
      }, 700);
    };

    const handleCardSelection = (card) => {
      if (!card || gameState.busy || !gameState.roundActive) {
        return;
      }

      if (card.classList.contains('is-matched') || card.classList.contains('is-disabled')) {
        return;
      }

      const pairId = card.getAttribute('data-pair-id');
      const lang = card.getAttribute('data-lang');

      if (!pairId || !lang) {
        return;
      }

      const isAlreadySelected = card.classList.contains('is-selected');

      if (gameState.selection.length === 0) {
        const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
        gameState.selection.push({ card, pairId, lang });
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'もう1枚選んでペアを作ろう！'));
        return;
      }

      const [firstSelection] = gameState.selection;

      if (firstSelection.card === card) {
        card.classList.remove('is-selected');
        gameState.selection = [];
        setStatus(formatStatusWithSpeechCue(false, 'カードを選び直したよ。'));
        return;
      }

      if (firstSelection.lang === lang) {
        const didSpeak = speakCardIfDutch({ lang, pairId });
        firstSelection.card.classList.remove('is-selected');
        gameState.selection = [{ card, pairId, lang }];
        card.classList.add('is-selected');
        setStatus(formatStatusWithSpeechCue(didSpeak, 'もう1枚選んでペアを作ろう！'));
        return;
      }

      const didSpeak = speakCardIfDutch({ lang, pairId, alreadySelected: isAlreadySelected });
      gameState.selection.push({ card, pairId, lang });
      card.classList.add('is-selected');
      evaluateSelection({ didSpeak });
    };

    const startStage = () => {
      if (!gameGrid) {
        return;
      }

      stopTimer({ resetToFull: true });

      const nextStage = gameState.stage + 1;
      const pairCount = stagePairCount(nextStage);

      if (pairCount <= 0) {
        setStatus('フレーズデータを読み込み中です。少し待ってからもう一度お試しください。');
        return;
      }

      const availablePhrases = getAllPhrases();

      if (availablePhrases.length === 0) {
        setStatus('フレーズデータを読み込み中です。少し待ってからもう一度お試しください。');
        return;
      }

      const selectedPairs = shuffleArray(availablePhrases).slice(0, pairCount);

      gameGrid.setAttribute('aria-busy', 'true');

      const columns = rebuildGameColumns();

      if (!columns) {
        gameGrid.removeAttribute('aria-busy');
        return;
      }

      gameState.columns = columns;
      gameState.phraseQueue = [...selectedPairs];

      replenishBoard();

      gameGrid.removeAttribute('aria-busy');

      gameState.stage = nextStage;
      gameState.matchesRemaining = selectedPairs.length;
      gameState.selection = [];
      gameState.busy = false;
      gameState.correctMatches = 0;
      gameState.mistakes = 0;

      if (startButton) {
        startButton.disabled = true;
        startButton.textContent = 'プレイ中…';
      }

      updateScoreboard();
      startTimer();
      setStatus(
        `ステージ${gameState.stage}スタート！制限時間${TIME_LIMIT_SECONDS}秒以内に同じ意味のカードをタップしてね。オランダ語カードはタップで発音が流れるよ。`
      );
    };

    if (gameGrid) {
      gameGrid.addEventListener('click', (event) => {
        const mainButton = event.target.closest('.game-card-main');

        if (mainButton) {
          event.preventDefault();
          const card = mainButton.closest('.game-card');
          handleCardSelection(card);
        }
      });
    }

    if (startButton) {
      startButton.addEventListener('click', () => {
        if (startButton.disabled) {
          return;
        }

        startStage();
      });
    }

    if (resetButton) {
      resetButton.addEventListener('click', () => {
        resetGame();
        if (startButton) {
          startButton.focus();
        }
      });
    }

    resetGame();
  </script>

</body>
</html>
